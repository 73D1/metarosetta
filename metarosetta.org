#+TITLE: Project Metarosetta Emacs Package

* Header
** Name and Definition
#+NAME: title
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el --- A semantically-driven interconnectivity framework -*- lexical-binding: t -*-
#+END_SRC
** Signature
#+NAME: signature
#+BEGIN_SRC emacs-lisp :tangle yes
;; Author: Bruno Tedeschi <me@btedeschi.com>
#+END_SRC
** Summary
#+NAME: summary
#+BEGIN_SRC text
This package adds Metarosetta expression language support to Org-mode.

It enables in-context definition of semantic protocols, within Org-mode, which automatically translate human-input text into a machine-digestible API-compatible structure particular to a given context.

For details and language specification, please refer to the original package documentation and source org file.
#+END_SRC

#+NAME: commentary
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
;;; Commentary:

;; <<summary>>
#+END_SRC
** Code Marker
#+NAME: code-marker
#+BEGIN_SRC emacs-lisp :tangle yes
;;; Code:
#+END_SRC
* Dependencies
#+NAME: dependencies
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'eieio)
#+END_SRC
* The Metalanguage
The metalanguage specification and parser.

** The Expression
An entity defining a particular expression. Using the metalanguage syntax as input, it constructs all underlying logic to parse textual input and structures to map semantic information to machine-readable output.

Designed as an inherently recursive fractal object.

*** Properties
All the properties contained within the expression object. These are of course defined as slots.

**** Definition
The metalanguage-specified definition of the expression in context.

This is stored as a quoted lisp list.

#+NAME: mldefinition
#+BEGIN_SRC emacs-lisp
(mldefinition
 :initarg :mldefinition
 :initform (error "Cannot create an expression without a definition!")
 :type list
 :documentation "The metalanguage-specified definition of the expression in context."
 :reader mrosetta-mldefinition)
#+END_SRC
**** Expression Type
Specifies the exact type of the expression in context.

The property itself is a ~symbol~ indicating the type of the expression.

#+NAME: extype
#+BEGIN_SRC emacs-lisp
(extype
 :type symbol
 :documentation "A symbol specifying the type of the encompassing expression instance. Can be either a :literal, :context, :word or :fractal."
 :reader mrosetta-extype)
#+END_SRC

The following are the possible expression types:

***** Literal Quote
Denotes the simplest expression defining statically quoted text which matches itself within any passed input.

The quote expression type is specified as a ~:literal~.
***** Variable Context
Defines variable context consisting of semantically insignificant text. While this text is unimportant for structured semantics, it remains an intrinsic part of the human-readable form.

These expressions are key in the ability to regenerate the human-readable text with updated semantic information from a machine-generated source. This enables true two-way trans-operability between the human and machine forms.

This type of expression is specified as ~:context~.
***** Matching Word
An expression matching semantically significant information.

A word expression is specified as a ~:word~.
***** Fractal
These are complex expressions consisting of one or more expressions within. Unless the entirety of the input text can be described with a single word expression, the /root/ expression is always a fractal.

In addition, fractals *never* have end values, but can have keys assigned to them matching the fractal-subtree structure contained within.

Such an expression is specified as a ~:fractal~.
**** Fractals
All the fractal elements existing within the encompassing expression instance. Only fractal expression types can contain fractals themselves.

The property itself is a list of ~mrosetta-expression~ instances.

#+NAME: fractals
#+BEGIN_SRC emacs-lisp
(fractals
 :initform '()
 :type list
 :documentation "A list of mrosetta-expression instances contained within the encompassing expression instance."
 :reader mrosetta-fractals)
#+END_SRC
**** Regular Expression Properties
This section contains all the properties pertaining to the encompassing expression's regex, its group keys and resulting matches of the current input, if processed.

***** Regex Keychain
In order to properly parse and distribute regex matches across the fractal expression tree, each expression object needs to have a number identifier unique to the encompassing tree.

To manage this, each tree has a single /keychain/ instance shared across all expression objects within a single fractal tree.

#+NAME: rkeychain
#+BEGIN_SRC emacs-lisp
(rkeychain
 :initarg :rkeychain
 :initform (mrosetta-keychain)
 :type mrosetta-keychain
 :documentation "The regex keychain instance managing keys for the encompassing expression tree."
 :reader mrosetta-rkeychain)
#+END_SRC

****** The Keychain
Key management is encapsulated within a simple keychain class which holds all generated keys, their respective assignments and is of course capable of generating keys unique within a single instance of the keychain object.

******* Class Definition
The class itself is designed as a no-argument constructor as the key generator is automatically initialized upon creation.

#+NAME: mrosetta-keychain
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-keychain ()
  ((lastkey
    :initform '0
    :type number
    :documentation "The last key generated and assigned to a group within the context of a single instance."
    :reader mrosetta-lastkey)
   (keys
    :initform '()
    :type list
    :documentation "A property list containing all the generated keys and corresponding references of respectively assigned objects."
    :reader mrosetta-keys))
  "A regex group key generator and manager.")
#+END_SRC
******* Behavior
This section covers all defined behavior for the keychain class.

******** Generate Key
Register for a new key with a particular expression instance.

#+NAME: mrosetta-generate-rkey
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-generate-rkey ((keychain mrosetta-keychain) mlexpression)
  "Register for a new key with a particular MLEXPRESSION instance within a provided KEYCHAIN."
  (let ((key (+ 1 (slot-value keychain 'lastkey))))
    (setf (slot-value keychain 'keys) (plist-put (slot-value keychain 'keys) key mlexpression))
    (setf (slot-value keychain 'lastkey) key)))
#+END_SRC
***** Regex Key
The regex group key awarded to the encompassing expression instance.

#+NAME: rkey
#+BEGIN_SRC emacs-lisp
(rkey
 :type number
 :documentation "The regex matching group key for the encompassing expression instance."
 :reader mrosetta-rkey)
#+END_SRC
***** Regular Expression
The compiled regular expression of the expression in context.

This is the regex used under the hood when parsing through human-readable input.

#+NAME: regex
#+BEGIN_SRC emacs-lisp
(regex
 :type string
 :documentation "The compiled regular expression of the expression in context."
 :reader mrosetta-regex)
#+END_SRC
***** Regex Match
If input is processed, this property contains the regular expression match for the encompassing expression instance.

The match is in raw text form.

#+NAME: rmatch
#+BEGIN_SRC emacs-lisp
(rmatch
 :type string
 :documentation "The textual match of the encompassing expression within the currently set input."
 :reader mrosetta-rmatch)
#+END_SRC
**** Key
The property key to which the expression output value is assigned, if the expression itself is denoted as such.

#+NAME: key
#+BEGIN_SRC emacs-lisp
(key
 :type string
 :documentation "The property key to which the expression output value is assigned, if any."
 :reader mrosetta-key)
#+END_SRC
**** Value
If the encompassing expression instance outputs an end value, this property contains the value within the currently set input text.

The property itself is either a string representation of the singular value, or a list of matched values, if the expression is marked as plural.

#+NAME: value
#+BEGIN_SRC emacs-lisp
(value
 :type (or string list)
 :documentation "The output value matching the encompassing expression instance within the currently set input."
 :reader mrosetta-value)
#+END_SRC
**** Specifier Properties
All specifier parameters defined for the encompassing expression instance.

***** Uppercase
Match only uppercase words.

#+NAME: is-uppercase
#+BEGIN_SRC emacs-lisp
(is-upparcase
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only uppercase words. Either non-nil or nil."
 :reader mrosetta-is-uppercase)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: is-capitalized
#+BEGIN_SRC emacs-lisp
(is-capitalized
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only capitalized words. Either non-nil or nil."
 :reader mrosetta-is-capitalized)
#+END_SRC
***** Content
Match only words containing specific characters or substrings.

#+NAME: match-substring
#+BEGIN_SRC emacs-lisp
(match-substring
 :initform 'nil
 :type (or null string)
 :documentation "Specifies a specific substring all possible expression matches should contain, if any. Either a string or nil."
 :reader mrosetta-match-substring)
#+END_SRC
***** Boundary Properties
Specifies whether the match of the encompassing expression has static left or right boundaries.

****** Left Boundary
Specifies a statically set match prefix, if the expression defines one.

#+NAME: match-prefix
#+BEGIN_SRC emacs-lisp
(match-prefix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the prefix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-prefix)
#+END_SRC
****** Right Boundary
Specifies a statically set match suffix, if the expression defines one.

#+NAME: match-suffix
#+BEGIN_SRC emacs-lisp
(match-suffix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the suffix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-suffix)
#+END_SRC
**** Modifier Properties
Modifier properties defined for the encompassing expression instance.

Modifiers are useful when matched text needs to be formatted and /normalized/ before being structured within the machine-digestible output.

***** Uppercase
Indicates whether matched text needs to be uppercased.

#+NAME: should-uppercase
#+BEGIN_SRC emacs-lisp
(should-uppercase
 :initform 'nil
 :documentation "Specifies whether the original encompassing expression match should get uppercased."
 :reader mrosetta-should-uppercase)
#+END_SRC
***** Lowercase
Indicates whether matched text needs to be lowercased.

#+NAME: should-lowercase
#+BEGIN_SRC emacs-lisp
(should-lowercase
 :initform 'nil
 :documentation "Specifies whether the original encompassing expression match should get lowercased."
 :reader mrosetta-should-lowercase)
#+END_SRC
**** Plurality
If the expression defines a plural match, then the ~value~ property is in list form and this property is non-nil.

#+NAME: has-plural-value
#+BEGIN_SRC emacs-lisp
(has-plural-value
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches plural values or just a single one. Either nil or non-nil."
 :reader mrosetta-has-plural-value)
#+END_SRC
**** Optionality
Specifies whether the entire expression and its fractals within (if any) are optional in presence.

#+NAME: is-optional
#+BEGIN_SRC emacs-lisp
(is-optional
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is optional to match within input text. Either non-nil or nil."
 :reader mrosetta-is-optional)
#+END_SRC
**** Assignment
Specifies whether the encompassing expression is assigned a specific key to include within the output structure.

#+NAME: has-key
#+BEGIN_SRC emacs-lisp
(has-key
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is assigned a key for its output. Either nil or non-nil."
 :reader mrosetta-has-key)
#+END_SRC
*** Class Definition
The /expression/ class is defined below, containing all the properties listed above.

#+NAME: mrosetta-mlexpression
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defclass mrosetta-mlexpression ()
  (
   <<mldefinition>>
   <<extype>>
   <<fractals>>
   <<rkeychain>>
   <<rkey>>
   <<regex>>
   <<rmatch>>
   <<key>>
   <<value>>
   <<is-uppercase>>
   <<is-capitalized>>
   <<match-substring>>
   <<match-prefix>>
   <<match-suffix>>
   <<should-uppercase>>
   <<should-lowercase>>
   <<has-plural-value>>
   <<is-optional>>
   <<has-key>>
  )
  "The Metarosetta Expression object used to define a contextual translational expression for semantic processing.")
#+END_SRC
** The Specification
The purpose of the language is to facilitate expressions which unambiguously define a translation protocol between human-readable text and machine-digestible data structures, with the semantics completely preserved, based on an arbitrarily defined pattern of human input within a specific context.

*** Literal Quote
The simplest element defining statically quoted text which should appear literally within input text.

#+NAME: mrosetta-compile-literal
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-compile-literal ((mlexpression mrosetta-mlexpression) buffer)
  "Compile the BUFFER content as a literal quote into the MLEXPRESSION instance in context."
  (when (eql (length buffer) 0)
    (error "Metalanguage syntax error: Literal expression without quoted content"))
  (let ((lit-quote (pop buffer)))
    (setf (slot-value mlexpression 'extype) :literal)
    (setf (slot-value mlexpression 'regex) lit-quote)))
#+END_SRC

#+NAME: mrosetta-compile-literal-symbol
#+BEGIN_SRC emacs-lisp
(literally 'mrosetta-compile-literal)
#+END_SRC
* Contexts
** Org
* Connectors
** Coda
* Registration
#+NAME: registration
#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'metarosetta)
#+END_SRC
* Footer
#+NAME: footer
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el ends here
#+END_SRC
