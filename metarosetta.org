#+TITLE: Project Metarosetta Emacs Package

* Header
** Name and Definition
#+NAME: title
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el --- Extract, structure and transpile contextual data from conventional text -*- lexical-binding: t; -*-
#+END_SRC
** Signature
#+NAME: signature
#+BEGIN_SRC emacs-lisp :tangle yes
;; Author: Bruno Tedeschi <me@btedeschi.com>
#+END_SRC
** Summary
#+NAME: summary
#+BEGIN_SRC text
An Emacs package introducing support for so-called metalanguage expressions.

Like regular expressions, but in English, these enable defining arbitrary textual conventions enabling capturing and parsing through matching textual snippets from within the Emacs editing environment.

Matches can be set to automatically produce machine-digestible data structures of parsed information, or to "transpile" the given data to a different textual convention, also defined by another, but data-compatible, metalanguage expression.

For details and language specification, in addition to examples and use cases, please refer to the original package documentation and source org file.
#+END_SRC

#+NAME: commentary
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
;;; Commentary:

;; <<summary>>
#+END_SRC
** Code Marker
#+NAME: code-marker
#+BEGIN_SRC emacs-lisp :tangle yes
;;; Code:
#+END_SRC
* Dependencies
#+NAME: dependencies
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'cl-lib)
(require 'eieio)
(require 'eieio-base)
(require 'dash)
(require 'org)
(require 'org-ml)
#+END_SRC
* Helpers
Helper objects and functions.

** The Keychain
Key management is encapsulated within a simple keychain class which holds all generated keys and is of course capable of generating keys unique to a single instance of the keychain.

*** Class Definition
The class itself is designed as a no-argument constructor as the key generator is automatically initialized upon creation.

#+NAME: mrosetta-keychain
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-keychain ()
  ((lastkey
    :initarg :lastkey
    :initform '0
    :type number
    :documentation "The last key generated and assigned within the context of a single keychain instance."
    :reader mrosetta-keychain-lastkey))
  "A key generator helper class.")
#+END_SRC
*** Behavior
This section covers all defined behavior for the keychain class.

**** Generate Key
Register for a new key with a particular keychain instance.

#+NAME: mrosetta-keychain-generate-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-keychain-generate-key ((keychain mrosetta-keychain))
  "Generate a new key within a provided KEYCHAIN."
  (let ((key (+ 1 (slot-value keychain 'lastkey))))
    (setf (slot-value keychain 'lastkey) key)))
#+END_SRC
* The Metalanguage
The metalanguage specification and parser.

** The Expression Object
An entity defining a particular expression. Using the metalanguage syntax as input, it composes all underlying logic to parse any matching text and creates a context-reflecting structure to output the captured data.

The object is of fractal design, meaning that it can be recursively nested to accommodate more complex patterns, such as lists, maps and sub-expressions.

*** Properties
All the properties contained within the expression object.

**** Definition
The metalanguage-specified definition of the expression in context.

This is stored in list form.

#+NAME: mrosetta-mlexpression-mldefinition
#+BEGIN_SRC emacs-lisp
(mldefinition
 :initarg :mldefinition
 :type list
 :documentation "The metalanguage-specified definition of the expression in context."
 :reader mrosetta-mlexpression-mldefinition)
#+END_SRC
**** Expression Type
Specifies the exact type of the expression in context.

The property itself is a ~symbol~ indicating the type of the expression.

#+NAME: mrosetta-mlexpression-extype
#+BEGIN_SRC emacs-lisp
(extype
 :type symbol
 :documentation "A symbol specifying the type of the encompassing expression instance. Can be either a :literal, :match or :fractal."
 :reader mrosetta-mlexpression-extype)
#+END_SRC

The following are the possible expression types:

***** Literal Quote
Denotes the simplest expression defining statically quoted text which matches itself within any passed input.

The quote expression type is specified as a ~:literal~.
***** Match
An expression matching semantically significant information. These are either words or paragraphs of captured text.

A match expression is specified as a ~:match~.
***** Fractal
An expression matching a sequence of its nested child expressions.

A fractal expression is specified as a ~:fractal~.
**** Fractals
All the fractal sub-elements existing within the encompassing expression instance. Only ~:fractal~ instances can contain sub-expressions themselves.

The property itself is a list of ~mrosetta-expression~ instances.

#+NAME: mrosetta-mlexpression-fractals
#+BEGIN_SRC emacs-lisp
(fractals
 :initform '()
 :type list
 :documentation "A list of mrosetta-expression instances contained within the encompassing expression instance."
 :reader mrosetta-mlexpression-fractals)
#+END_SRC
**** Regular Expression Properties
This section contains all the properties pertaining to the encompassing expression's regex, its group keys and resulting matches of the current input, if processed.

***** Regex Keychain
In order to properly parse and distribute regex matches across the fractal expression tree, each expression object needs to have a number identifier unique to the encompassing tree.

To manage this, each tree has a single /keychain/ instance shared across all expression objects within a single fractal tree.

#+NAME: mrosetta-mlexpression-rkeychain
#+BEGIN_SRC emacs-lisp
(rkeychain
 :initarg :rkeychain
 :initform (mrosetta-keychain)
 :type mrosetta-keychain
 :documentation "The regex keychain instance managing keys for the encompassing expression tree."
 :reader mrosetta-mlexpression-rkeychain)
#+END_SRC

***** Regular Expression
The compiled regular expression of the metalanguage expression in context.

This is the regex used under the hood when parsing through possible matches.

#+NAME: mrosetta-mlexpression-regex
#+BEGIN_SRC emacs-lisp
(regex
 :type string
 :documentation "The compiled regular expression of the expression in context."
 :reader mrosetta-mlexpression-regex)
#+END_SRC

In addition, each match-extracting regular expression has a corresponding group key by which the respective match is extracted.

#+NAME: mrosetta-mlexpression-regex-key
#+BEGIN_SRC emacs-lisp
(regex-key
 :type number
 :documentation "The regex matching group key for the encompassing expression instance."
 :reader mrosetta-mlexpression-regex-key)
#+END_SRC

Since the metalanguage supports plural matches of enumerable text clauses, an additional regular expression is required in order to capture a single instance of such clauses. In cases of single-matching expressions, ~regex~ is equivalent to ~rinstance~.

#+NAME: mrosetta-mlexpression-rinstance
#+BEGIN_SRC emacs-lisp
(rinstance
 :type string
 :documentation "The compiled regular expression matching a single instance of a possibly plural-matching expression."
 :reader mrosetta-mlexpression-rinstance)
#+END_SRC

#+NAME: mrosetta-mlexpression-rinstance-key
#+BEGIN_SRC emacs-lisp
(rinstance-key
 :type number
 :documentation "The regex group key for matching a single instance of a possibly plural-matching metalanguage expression in context."
 :reader mrosetta-mlexpression-rinstance-key)
#+END_SRC

****** Base
The foundational element from which the matching regular expression is constructed.

#+NAME: mrosetta-mlexpression-rbase
#+BEGIN_SRC emacs-lisp
(rbase
 :type string
 :documentation "The regular expression used as a foundational base in compilation of the match-extracting regular expression."
 :reader mrosetta-mlexpression-rbase)
#+END_SRC
****** Match
The regular expression of the match itself.

#+NAME: mrosetta-mlexpression-rmatch
#+BEGIN_SRC emacs-lisp
(rmatch
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression of the encompassing expression's textual match."
 :reader mrosetta-mlexpression-rmatch)
#+END_SRC

The regex is paired with its group key used for match extraction.

#+NAME: mrosetta-mlexpression-rmatch-key
#+BEGIN_SRC emacs-lisp
(rmatch-key
 :initform 'nil
 :type (or null number)
 :documentation "The regex group key for the encompassing expression's output value."
 :reader mrosetta-mlexpression-rmatch-key)
#+END_SRC
****** Prefix
The regular expression used for matching a specified prefix of the expression in context, if any.

#+NAME: mrosetta-mlexpression-rprefix
#+BEGIN_SRC emacs-lisp
(rprefix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified prefix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-mlexpression-rprefix)
#+END_SRC
****** Suffix
The regular expression used for matching a specified suffix of the expression in context, if any.

#+NAME: mrosetta-mlexpression-rsuffix
#+BEGIN_SRC emacs-lisp
(rsuffix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified suffix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-mlexpression-rsuffix)
#+END_SRC
****** Regex Boundaries
Regular expressions used for regex-specific boundaries around the match.

******* Left Boundary
The regular expression used for defining the left boundary of the match.

#+NAME: mrosetta-mlexpression-left-rboundary
#+BEGIN_SRC emacs-lisp
(left-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The left regex-specific boundary defining the beginning of the match."
 :reader mrosetta-mlexpression-left-rboundary)
#+END_SRC
******* Right Boundary
The regular expression used for defining the right boundary of the match.

#+NAME: mrosetta-mlexpression-right-rboundary
#+BEGIN_SRC emacs-lisp
(right-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The right regex-specific boundary defining the end of the match."
 :reader mrosetta-mlexpression-right-rboundary)
#+END_SRC
****** Surrounding Buffers
Regular expressions used for matching buffer characters surrounding the match.

By default, these are /whitespace/ characters between words and used purely for original text reconstruction with updated target data, or for text compilation off an entirely new, structure-compatible, data set.

To avoid redundancy, and useless regex overlaps, the convention is that each (sub-)expression captures the left surrounding buffer, while leaving the right one off to the subsequent expression to be captured as its respective left buffer. Of course, this implies that any rightmost buffer space is left unmatched, and as such omitted from any textual reconstruction. This in practice clears any trailing whitespace from (re)constructed text.

#+NAME: mrosetta-mlexpression-rbuffer
#+BEGIN_SRC emacs-lisp
(rbuffer
 :initform "[[:blank:]]*"
 :type string
 :documentation "The regular expression matching buffer characters surrounding the encompassing expression."
 :reader mrosetta-mlexpression-rbuffer)
#+END_SRC

******* Left Buffer
The regular expression group key for the left buffer.

#+NAME: mrosetta-mlexpression-rbuffer-key
#+BEGIN_SRC emacs-lisp
(rbuffer-key
 :type number
 :documentation "The regex group key for the encompassing expression's left buffer match."
 :reader mrosetta-mlexpression-rbuffer-key)
#+END_SRC
**** Key
The property key to which the expression output value is assigned, if the expression itself is denoted as such.

#+NAME: mrosetta-mlexpression-key
#+BEGIN_SRC emacs-lisp
(key
 :initform 'nil
 :type (or null symbol)
 :documentation "The property key to which the expression output value is assigned, if any. Either a string or nil."
 :reader mrosetta-mlexpression-key)
#+END_SRC
**** Specifier Properties
All specifier parameters defined for the encompassing expression instance.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-mlexpression-is-uppercase
#+BEGIN_SRC emacs-lisp
(is-uppercase
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only uppercase words. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-uppercase)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-mlexpression-is-capitalized
#+BEGIN_SRC emacs-lisp
(is-capitalized
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only capitalized words. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-capitalized)
#+END_SRC
***** Boundary Properties
Specifies whether the match of the encompassing expression has static left or right boundaries.

****** Left Boundary
Specifies a statically set match prefix, if the expression defines one.

#+NAME: mrosetta-mlexpression-match-prefix
#+BEGIN_SRC emacs-lisp
(match-prefix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the prefix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-prefix)
#+END_SRC
****** Right Boundary
Specifies a statically set match suffix, if the expression defines one.

#+NAME: mrosetta-mlexpression-match-suffix
#+BEGIN_SRC emacs-lisp
(match-suffix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the suffix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-suffix)
#+END_SRC
***** Content
Match only words containing specific characters or substrings.

#+NAME: mrosetta-mlexpression-match-substring
#+BEGIN_SRC emacs-lisp
(match-substring
 :initform 'nil
 :type (or null string)
 :documentation "Specifies a specific substring all possible expression matches should contain, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-substring)
#+END_SRC
***** Literal
Match only and exactly the literal text specified here.

This slot is only used in ~:literal~ expressions.

#+NAME: mrosetta-mlexpression-match-literal
#+BEGIN_SRC emacs-lisp
(match-literal
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the literal string that the expression maches exclusively. Either a string or nill."
 :reader mrosetta-mlexpression-match-literal)
#+END_SRC
***** Contextual
Elastically match a region of text depending on neighboring elements.

This slot is only used in ~paragraph~ ~:match~ expressions since paragraphs match any and all text, either based on specific criteria, such as explicit boundaries, or on neighboring matches which act as contextual criteria.

#+NAME: mrosetta-mlexpression-is-contextual
#+BEGIN_SRC emacs-lisp
(is-contextual
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is matched elastically depending on neighboring elements. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-contextual)
#+END_SRC
**** Modifier
Modifiers are useful when matched text needs to be formatted and /normalized/ before being structured within the output.

A modifier property is defined as a symbol referencing a stored function capable of a particular modification, like ~upcase~ for uppercasing the entirety of the output, or ~downcase~ for lowercasing.

#+NAME: mrosetta-mlexpression-modifier
#+BEGIN_SRC emacs-lisp
(modifier
 :initform 'nil
 :type (or null symbol)
 :documentation "Specifies a symbol referencing a stored modifier function, if any. Either a symbol or nil."
 :reader mrosetta-mlexpression-modifier)
#+END_SRC

In addition to the modifier, a reverse modifier is kept in order to support consistent textual reconstruction.

#+NAME: mrosetta-mlexpression-modifier-reverse
#+BEGIN_SRC emacs-lisp
(modifier-reverse
 :initform 'nil
 :type (or null symbol)
 :documentation "Specifies a symbol referencing a stored modifier function which effectively reverses the modifier in context of the expression, if any. Either symbol or nil."
 :reader mrosetta-mlexpression-modifier-reverse)
#+END_SRC

**** Optionality
Specifies whether the entire expression and its fractals within (if any) are optional in presence.

#+NAME: mrosetta-mlexpression-is-optional
#+BEGIN_SRC emacs-lisp
(is-optional
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is optional to match within input text. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-optional)
#+END_SRC
**** Ignorables
Specifies whether the encompassing expression should be disregarded in structured output. /Ignorable/ expressions are matched but never included in structured output.

#+NAME: mrosetta-mlexpression-should-ignore
#+BEGIN_SRC emacs-lisp
(should-ignore
 :initform 'nil
 :documentation "Specifies whether the encompassing expression should be matched but disregarded in output. Either non-nil or nil."
 :reader mrosetta-mlexpression-should-ignore)
#+END_SRC
**** Plurality
If the expression defines a plural match, then the output value is in list form and this property is non-nil.

#+NAME: mrosetta-mlexpression-is-plural
#+BEGIN_SRC emacs-lisp
(is-plural
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches plural values or just a single one. Either nil or non-nil."
 :reader mrosetta-mlexpression-is-plural)
#+END_SRC
*** Class Definition
The /expression/ class is defined below, containing all the properties listed above.

#+NAME: mrosetta-mlexpression
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defclass mrosetta-mlexpression ()
  (
   <<mrosetta-mlexpression-mldefinition>>
   <<mrosetta-mlexpression-extype>>
   <<mrosetta-mlexpression-fractals>>
   <<mrosetta-mlexpression-rkeychain>>
   <<mrosetta-mlexpression-regex>>
   <<mrosetta-mlexpression-regex-key>>
   <<mrosetta-mlexpression-rinstance>>
   <<mrosetta-mlexpression-rinstance-key>>
   <<mrosetta-mlexpression-rbase>>
   <<mrosetta-mlexpression-rmatch>>
   <<mrosetta-mlexpression-rmatch-key>>
   <<mrosetta-mlexpression-rprefix>>
   <<mrosetta-mlexpression-rsuffix>>
   <<mrosetta-mlexpression-left-rboundary>>
   <<mrosetta-mlexpression-right-rboundary>>
   <<mrosetta-mlexpression-rbuffer>>
   <<mrosetta-mlexpression-rbuffer-key>>
   <<mrosetta-mlexpression-key>>
   <<mrosetta-mlexpression-is-uppercase>>
   <<mrosetta-mlexpression-is-capitalized>>
   <<mrosetta-mlexpression-match-prefix>>
   <<mrosetta-mlexpression-match-suffix>>
   <<mrosetta-mlexpression-match-substring>>
   <<mrosetta-mlexpression-match-literal>>
   <<mrosetta-mlexpression-is-contextual>>
   <<mrosetta-mlexpression-modifier>>
   <<mrosetta-mlexpression-modifier-reverse>>
   <<mrosetta-mlexpression-is-optional>>
   <<mrosetta-mlexpression-should-ignore>>
   <<mrosetta-mlexpression-is-plural>>
  )
  "The Metarosetta Expression object which defines a contextual translational expression used for matching, parsing and structuring data from within conventional text.")
#+END_SRC

** Language Specification
The purpose of the language is to facilitate expressions which unambiguously define a translation protocol between human-readable text and machine-digestible data structures, with the semantics completely preserved, based on an arbitrarily defined pattern, or convention, of human input within a specific context.

All keywords within the specification are stored as symbols which map to their respective parsing functions.

#+NAME: mrosetta-mlsyntax
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax '())
#+END_SRC

*** Literal Quote
The simplest expression defining static quoted text which should appear literally within matched text.

#+NAME: mrosetta-parse-literal
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-literal ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the :right arg content within ARGS as a literal quote into the MLEXPRESSION instance in context."
  (let ((literal-quote (plist-get args :right)))
    (when (eq literal-quote nil)
      (error "Metalanguage syntax error: Literal expression without quoted content"))
    (setf (slot-value mlexpression 'extype) :literal)
    (setf (slot-value mlexpression 'rbase) (regexp-quote literal-quote))
    (setf (slot-value mlexpression 'match-literal) literal-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage itself defines this expression through the ~literal~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-literal-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(literal . mrosetta-parse-literal) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-literal-example
#+BEGIN_SRC text
(literal "Status Update:")
#+END_SRC
*** Word
An expression used to capture a variable word from within matched text.

#+NAME: mrosetta-parse-word
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'left-rboundary) "\\<")
  (setf (slot-value mlexpression 'rbase) "[[:word:]]+")
  (setf (slot-value mlexpression 'right-rboundary) "\\>")
  args)
#+END_SRC

The metalanguage defines this expression through the ~word~ keyword.

#+NAME: mrosetta-parse-word-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(word . mrosetta-parse-word) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-example
#+BEGIN_SRC text
(word)
#+END_SRC

**** Word Specifiers
In addition to the ability to match any kind of word, the metalanguage specification also supports matching only specific types of words based on different syntactic criteria.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-parse-word-uppercase
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-uppercase ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse an uppercase word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9]+")
  (setf (slot-value mlexpression 'is-uppercase) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~WORD~ keyword. Note that the metalanguage syntax is case-sensitive, where the casing itself is also part of the syntax.

#+NAME: mrosetta-parse-word-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(WORD . mrosetta-parse-word-uppercase) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-uppercase-example
#+BEGIN_SRC text
(WORD)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-parse-word-capitalized
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-capitalized ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a capitalized word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9][a-z0-9]+")
  (setf (slot-value mlexpression 'is-capitalized) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~Word~ keyword.

#+NAME: mrosetta-parse-word-capitalized-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(Word . mrosetta-parse-word-capitalized) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-capitalized-example
#+BEGIN_SRC text
(Word)
#+END_SRC
**** Word Plurality
Instead of a single value, capture all value occurrences matching defined criteria within the encompassing expression context.

#+NAME: mrosetta-parse-word-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural words expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~words~ keyword.

#+NAME: mrosetta-parse-word-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(words . mrosetta-parse-word-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-word-plurality-example
#+BEGIN_SRC text
(words)
#+END_SRC
*** Paragraph
An expression used to capture a variable-length paragraph from within matched text.

A paragraph is considered as the entire text within specified boundaries. If no boundaries are set, the entire input is matched.

#+NAME: mrosetta-parse-paragraph
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a paragraph epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) ".+?")
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraph~ keyword.

#+NAME: mrosetta-parse-paragraph-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraph . mrosetta-parse-paragraph) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-paragraph-example
#+BEGIN_SRC text
(paragraph)
#+END_SRC

**** Paragraph Plurality
Like words, it's possible to capture multiple paragraph occurrences matching the expression-defined criteria.

Note that this construct only makes sense if paragraphs are clearly bounded.

#+NAME: mrosetta-parse-paragraph-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural paragraph expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-paragraph mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraphs~ keyword.

#+NAME: mrosetta-parse-paragraph-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraphs . mrosetta-parse-paragraph-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-paragraph-plurality-example
#+BEGIN_SRC text
(";" suffixed paragraphs)
#+END_SRC
*** Specifiers
**** Content Specifier
Match only elements containing specific characters or content.

#+NAME: mrosetta-parse-substring
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-substring ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :right arg within ARGS as matching element substring into the MLEXPRESSION instance in context."
  (let* ((substring-quote (plist-get args :right))
         (rsubstring-quote (regexp-quote substring-quote))
         (rbase (slot-value mlexpression 'rbase)))
    (when (eq substring-quote nil)
      (error "Metalanguage syntax error: Substring match expression without quoted content"))
    (setf (slot-value mlexpression 'rmatch)
          (concat "\\(?:"
                  "\\(?:" "\\(?:" rbase "\\)?" rsubstring-quote "\\)*" rbase "\\(?:" rsubstring-quote "\\(?:" rbase "\\)?" "\\)+"
                  "\\|"
                  "\\(?:" "\\(?:" rbase "\\)?" rsubstring-quote "\\)+" rbase "\\(?:" rsubstring-quote "\\(?:" rbase "\\)?" "\\)*"
                  "\\)"))
    (setf (slot-value mlexpression 'match-substring) substring-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines this expression through the ~with~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-substring-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(with . mrosetta-parse-substring) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-substring-example
#+BEGIN_SRC text
(word with "-")
#+END_SRC
**** Boundaries
Match only elements with the specified prefix or suffix. Note that the prefix or suffix itself isn't part of the match.

***** Prefix
Match only elements prefixed with the supplied quoted content.

#+NAME: mrosetta-parse-prefix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-prefix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element prefix into the MLEXPRESSION instance in context."
  (let ((prefix-quote (plist-get args :left)))
    (when (eq prefix-quote nil)
      (error "Metalanguage syntax error: Prefix match expression without quoted content"))
    (setf (slot-value mlexpression 'rprefix) (regexp-quote prefix-quote))
    (setf (slot-value mlexpression 'match-prefix) prefix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~prefixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-prefix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(prefixed . mrosetta-parse-prefix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-prefix-example
#+BEGIN_SRC text
("#" prefixed word)
#+END_SRC
***** Suffix
Match only elements suffixed with the supplied quoted content.

#+NAME: mrosetta-parse-suffix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-suffix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element suffix into the MLEXPRESSION instance in context."
  (let ((suffix-quote (plist-get args :left)))
    (when (eq suffix-quote nil)
      (error "Metalanguage syntax error: Suffix match expression without quoted content"))
    (setf (slot-value mlexpression 'rsuffix) (regexp-quote suffix-quote))
    (setf (slot-value mlexpression 'match-suffix) suffix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~suffixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-suffix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(suffixed . mrosetta-parse-suffix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-suffix-example
#+BEGIN_SRC text
(";" suffixed word)
#+END_SRC
**** Contextual
Match elements based on contextual criteria of neighboring matches. Note that a contextual specifier is only applicable to ~paragraph~ expressions.

#+NAME: mrosetta-parse-contextual
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-contextual ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the contextual specifier into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-contextual) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~contextual~ keyword.

#+NAME: mrosetta-parse-contextual-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(contextual . mrosetta-parse-contextual) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-contextual-example
#+BEGIN_SRC text
(contextual paragraph)
#+END_SRC
*** Modifiers
Modify captured elements before structured output.

Modifiers are defined as contextual arguments succeeding the general modifier keyword.

#+NAME: mrosetta-mlsyntax-modifiers
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax-modifiers '())
#+END_SRC

In order to support consistent textual reconstruction, a reverse index of modifiers is kept.

#+NAME: mrosetta-mlsyntax-modifiers-reverse
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax-modifiers-reverse '())
#+END_SRC
**** Uppercase
Transform captured elements to uppercase format.

To do so, use the ~uppercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(uppercase . upcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

#+NAME: mrosetta-parse-modifier-uppercase-reverse-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(uppercase . downcase) mrosetta-mlsyntax-modifiers-reverse)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-uppercase-example
#+BEGIN_SRC text
(word to uppercase)
#+END_SRC
**** Lowercase
Transform captured elements to lowercase format.

To do so, use the ~lowercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-lowercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(lowercase . downcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

#+NAME: mrosetta-parse-modifier-lowercase-reverse-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(lowercase . upcase) mrosetta-mlsyntax-modifiers-reverse)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-lowercase-example
#+BEGIN_SRC text
(word to lowercase)
#+END_SRC
**** Modifier Argument Parser
All modifier contextual arguments are handled by a singular modifier parser.

#+NAME: mrosetta-parse-modifier
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-modifier ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the modifier symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((modifier-symbol (plist-get args :right)))
    (when (eq modifier-symbol nil)
      (error "Metalanguage syntax error: Modifier expression without contextual argument symbol"))
    (setf (slot-value mlexpression 'modifier)
          (cdr (assq modifier-symbol mrosetta-mlsyntax-modifiers)))
    (setf (slot-value mlexpression 'modifier-reverse)
          (cdr (assq modifier-symbol mrosetta-mlsyntax-modifiers-reverse))))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the modifier context through the ~to~ keyword followed by the contextual arguments listed above.

#+NAME: mrosetta-parse-modifier-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(to . mrosetta-parse-modifier) mrosetta-mlsyntax)
#+END_SRC

*** Optionality
Specify whether the encompassing expression should be considered as an optional, or required match.

Matching text without an optional expression match still gets processed, structured and put out. Any text not matching all mandatory expressions is disregarded.

All defined expressions are considered as mandatory by default.

#+NAME: mrosetta-parse-optionality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-optionality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse expression optionality into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-optional) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~optional~ keyword.

#+NAME: mrosetta-parse-optionality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(optional . mrosetta-parse-optionality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-optionality-example
#+BEGIN_SRC text
(optional word)
#+END_SRC
*** Assignment
Assign a key to the resulting value of the encompassing expression.

#+NAME: mrosetta-parse-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-key ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the key symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((key-symbol (plist-get args :right)))
    (when (eq key-symbol nil)
      (error "Metalanguage syntax error: Key assignment without contextual key symbol"))
    (setf (slot-value mlexpression 'key) key-symbol))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the assignment expression through the ~as~ keyword followed by the key symbol.

#+NAME: mrosetta-parse-key-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(as . mrosetta-parse-key) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-key-example
#+BEGIN_SRC text
(word as a_property)
#+END_SRC
*** Ignorables
Specify whether the encompassing expression should be ignored from structured output. /Ignorable/ expressions are matched but never included in structured output.

Ignorables are considered as semantically insignificant text occurring before and after the match itself.

While this text is unimportant for structured semantics, it remains an intrinsic part of the human-readable form. This provides an ability to regenerate the human-readable text with updated semantic information from a structured, perhaps machine-generated, source. I.e., it enables true two-way trans-operability between the human-readable and structured forms.

#+NAME: mrosetta-parse-ignorable
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-ignorable ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the ignorable property into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'should-ignore) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~ignorable~ keyword.

#+NAME: mrosetta-parse-ignorable-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(ignorable . mrosetta-parse-ignorable) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-ignorable-example
#+BEGIN_SRC text
(ignorable ":" suffixed paragraph)
#+END_SRC
*** Collections
Instead of matching a single occurrence of a complex expression, repetitively capture the corresponding expression within matching text containing the recurring pattern, while structuring the resulting output in list form.

Collections are essential in extraction of targeted semantics from within enumerated or iterating clauses of text.

The metalanguage defines collection expressions through two keywords: ~list~ and ~of~.

The ~list~ specifies the type of the encompassing /parent/ expression, while the ~of~ designates its iterating content.

#+NAME: mrosetta-parse-list
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-list ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the list expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

#+NAME: mrosetta-parse-list-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(list . mrosetta-parse-list) mrosetta-mlsyntax)
#+END_SRC

In addition to the ~list~ specifier denoting a plural collection, there are cases where it's convenient to frame a /singular collection/ for the ability to define properties directly upon parts of the complex expression, such as assigning a key to a particular part of an expression, or to structure and explicitly group big linear expressions.

Singular collections are defined through the ~element~ keyword, of course followed by ~of~ designating the inner content of the element in context.

#+NAME: mrosetta-parse-element
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-element ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the element expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) nil)
  args)
#+END_SRC

#+NAME: mrosetta-parse-element-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(element . mrosetta-parse-element) mrosetta-mlsyntax)
#+END_SRC

#+NAME: mrosetta-parse-of
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-of ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the sub-expression from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((sub-expression (plist-get args :right)))
    (when (or (eq sub-expression nil) (nlistp sub-expression))
      (error "Metalanguage syntax error: Sub-expression assignment without contextual expression"))
    (mrosetta-parse mlexpression :sub sub-expression))
  (plist-put args :right nil))
#+END_SRC

#+NAME: mrosetta-parse-of-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(of . mrosetta-parse-of) mrosetta-mlsyntax)
#+END_SRC

** Expression Parsing
Parse the metalanguage-specified definition within an expression instance.

#+NAME: mrosetta-parse
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the metalanguage-specified definition within the MLEXPRESSION instance. Optionally, parse the explicitly-set :sub definition in ARGS instead."
  (let* ((sub-definition (plist-get args :sub))
         (mldefinition (if (eq sub-definition nil)
                           (copy-tree (slot-value mlexpression 'mldefinition))
                         (copy-tree sub-definition)))
         (larg)
         (element)
         (rarg))
    (while (> (length mldefinition) 0)
      (setq element (pop mldefinition)
            rarg (car mldefinition))
      (when (symbolp element)
        ;; The element is a metalanguage keyword, so lookup the corresponding function and parse accordingly
        (let ((leftout-args (funcall (cdr (assq element mrosetta-mlsyntax)) mlexpression :left larg :right rarg)))
          (setq larg nil)
          (when (eq (plist-get leftout-args :right) nil)
            (pop mldefinition))))
      (when (and (listp element) (> (length element) 0))
        ;; The element is a nested fractal expression
        (setf (slot-value mlexpression 'extype) :fractal)
        (let ((fractal-mlexpression (mrosetta-mlexpression :mldefinition element :rkeychain (slot-value mlexpression 'rkeychain))))
          (setf (slot-value mlexpression 'fractals) `(,@(slot-value mlexpression 'fractals) ,fractal-mlexpression))
          (mrosetta-parse fractal-mlexpression))
        (setq larg nil))
      (when (stringp element)
        ;; The element is a quoted string, so just pass it along
        (setq larg element)))))
#+END_SRC

** Expression Compilation
Compile the entire fractal tree within the root expression instance into a regular expression structure.

#+NAME: mrosetta-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-compile ((mlexpression mrosetta-mlexpression))
  "Compile the MLEXPRESSION instance into a regular expression structure."
  (let* ((rkeychain (slot-value mlexpression 'rkeychain))
         (regex)
         (regex-key (mrosetta-keychain-generate-key rkeychain))
         (rinstance)
         (rinstance-key (mrosetta-keychain-generate-key rkeychain))
         (rmatch (slot-value mlexpression 'rmatch))
         (rmatch-key (mrosetta-keychain-generate-key rkeychain))
         (rprefix (slot-value mlexpression 'rprefix))
         (rsuffix (slot-value mlexpression 'rsuffix))
         (left-rboundary (slot-value mlexpression 'left-rboundary))
         (right-rboundary (slot-value mlexpression 'right-rboundary))
         (rbuffer (slot-value mlexpression 'rbuffer))
         (rbuffer-key (mrosetta-keychain-generate-key rkeychain))
         (is-contextual (slot-value mlexpression 'is-contextual))
         (is-optional (slot-value mlexpression 'is-optional))
         (is-plural (slot-value mlexpression 'is-plural)))
    (if (eq (slot-value mlexpression 'extype) :fractal)
        ;; Recursively compile all nested fractal expression instances
        (let ((fractals (slot-value mlexpression 'fractals)))
          ;; Fractal Expressions cannot have end-matches
          (when rmatch
            (error "Metalanguage syntax error: End-matching expressions, like words or paragraphs, must be defined within parentheses"))
          (dolist (fractal fractals)
            (setq rmatch (concat rmatch (mrosetta-compile fractal)))))
      ;; Literal or end Match
      (when (eq rmatch nil)
        (setq rmatch (slot-value mlexpression 'rbase))))
    ;; Compile the total match, instance and expression-encompassing regular expressions
    (setq rmatch (concat "\\(?" (number-to-string rmatch-key) ":" rmatch "\\)"))
    (setq rinstance (concat "\\(?" (number-to-string rinstance-key) ":"
                            "\\(?" (number-to-string rbuffer-key) ":" rbuffer "\\)"
                            (when (not is-contextual)
                              (or rprefix left-rboundary))
                            rmatch
                            (when (not is-contextual)
                              (or rsuffix right-rboundary))
                            "\\)"))
    (setq regex (concat "\\(?" (number-to-string regex-key) ":"
                        rinstance
                        (when is-plural "+")
                        "\\)"
                        (when is-optional "?")))
    (setf (slot-value mlexpression 'rmatch-key) rmatch-key
          (slot-value mlexpression 'rmatch) rmatch
          (slot-value mlexpression 'rbuffer-key) rbuffer-key
          (slot-value mlexpression 'rinstance-key) rinstance-key
          (slot-value mlexpression 'rinstance) rinstance
          (slot-value mlexpression 'regex-key) regex-key
          (slot-value mlexpression 'regex) regex)))
#+END_SRC

* Text Processing
Process human-readable source text and output the semantically-significant data structure, as defined by the metalanguage expression in context.

#+NAME: mrosetta-process
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-process ((mlexpression mrosetta-mlexpression) htext)
  "Process human-readable text HTEXT and return the semantically-significant data structure as defined by the MLEXPRESSION instance."
  (when (mrosetta-mlexpression-should-ignore mlexpression)
    (error "Metalanguage semantic error: Root expressions cannot be ignorable"))
  (let ((exregex (mrosetta-mlexpression-regex mlexpression))
        (exrinstance (mrosetta-mlexpression-rinstance mlexpression))
        (exdata '())
        (case-fold-search nil))
    (when (mrosetta-mlexpression-is-contextual mlexpression)
      ;; Ensure complete matches of contextual expressions
      (setq exregex (concat "^" exregex "$"))
      (when (mrosetta-mlexpression-is-plural mlexpression)
        (error "Metalanguage semantic error: Contextual expressions cannot be plural"))
      (setq exrinstance (concat "^" exrinstance "$")))
    (save-match-data
      (and htext
           (string-match exregex htext)
           ;; Found match for the entirety of the expression
           (let ((extext (match-string (mrosetta-mlexpression-regex-key mlexpression) htext))
                 (pos))
             (save-match-data
               ;; Iterate over all instance occurrences within the expression-matching text
               (while (string-match exrinstance extext pos)
                 (setq pos (match-end 0))
                 ;; Process the exact match as defined by the expression
                 (let ((instance-exdata))
                   ;; Cases where the expression is a :fractal
                   (when (eq (mrosetta-mlexpression-extype mlexpression) :fractal)
                     ;; Recursively process all non-ignorable fractals within
                     (let ((fractals (mrosetta-mlexpression-fractals mlexpression)))
                       (dolist (fractal fractals)
                         (when (not (mrosetta-mlexpression-should-ignore fractal))
                           (let ((fractal-exdata (mrosetta-process fractal (match-string (mrosetta-mlexpression-regex-key fractal) extext))))
                             (when fractal-exdata
                               (setq instance-exdata `(,@instance-exdata ,fractal-exdata))))))))
                   ;; Cases where the expression is a :match
                   (when (eq (mrosetta-mlexpression-extype mlexpression) :match)
                     ;; Just store the end-match, modified if defined as such
                     (let ((match (match-string (mrosetta-mlexpression-rmatch-key mlexpression) extext))
                           (modifier (mrosetta-mlexpression-modifier mlexpression)))
                       (when modifier
                         (setq match (funcall modifier match)))
                       (setq instance-exdata match)))
                   (when instance-exdata
                     (setq exdata `(,@exdata ,instance-exdata)))))
               (when exdata
                 ;; Splice instance data in case of a singular expression
                 (when (not (mrosetta-mlexpression-is-plural mlexpression))
                   (setq exdata (car exdata)))
                 ;; Return the structured data object
                 `(,(or (mrosetta-mlexpression-key mlexpression) :nokey) . ,exdata))))))))
#+END_SRC

* Text Updating
Process human-readable source text and output the original text semantically updated with the provided data structure.

#+NAME: mrosetta-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-update ((mlexpression mrosetta-mlexpression) htext sdata)
  "Process human readable text HTEXT and return the semantically updated text based on the provided SDATA structure, as defined by the MLEXPRESSION instance."
  (let ((exregex (mrosetta-mlexpression-regex mlexpression))
        (exrinstance (mrosetta-mlexpression-rinstance mlexpression))
        (exkey (car sdata))
        (exdata-is-set (cdr sdata))
        (exdata (copy-tree (cdr sdata)))
        (newtext)
        (case-fold-search nil))
    (when (and exdata
               (not (eq exkey
                        (or (mrosetta-mlexpression-key mlexpression) :nokey))))
      (error "Data structure error: Key mismatch"))
    (when (mrosetta-mlexpression-is-contextual mlexpression)
      ;; Ensure complete matches of contextual expressions
      (setq exregex (concat "^" exregex "$"))
      (when (mrosetta-mlexpression-is-plural mlexpression)
        (error "Metalanguage semantic error: Contextual expressions cannot be plural"))
      (setq exrinstance (concat "^" exrinstance "$")))
    (save-match-data
      (and htext
           (string-match exregex htext)
           ;; Found metalanguage expression match
           (let ((extext (match-string (mrosetta-mlexpression-regex-key mlexpression) htext))
                 (pos '()))
             (save-match-data
               (while (or (and (string-match exrinstance extext (car pos))
                               ;; Handle plural expressions, including variations in length between updated and original sets
                               (or (not (mrosetta-mlexpression-is-plural mlexpression))
                                   ;; Expression is plural, but check if there is any updated data to insert
                                   (not exdata-is-set)
                                   ;; Updated list data is set, but only continue if any updated instances are left
                                   ;; Otherwise, just dispose of the remainder of the original
                                   exdata)
                               ;; An instance matched within the original text, update pos and enter iteration
                               (push (match-end 0) pos))
                          (and exdata
                               ;; No instances left within original text, but exdata still holding additional elements
                               (mrosetta-mlexpression-is-plural mlexpression)
                               ;; Reuse the last matched instance from the original text as a template
                               (string-match exrinstance extext (cadr pos))))
                 ;; Update each instance
                 (let ((instance-exdata (if (mrosetta-mlexpression-is-plural mlexpression) (pop exdata) exdata))
                       (instance-newtext))
                   (if (eq (mrosetta-mlexpression-extype mlexpression) :fractal)
                       ;; Recursively update all fractals within
                       (let ((fractals (mrosetta-mlexpression-fractals mlexpression)))
                         (dolist (fractal fractals)
                           (let* ((fractal-exdata (assq (mrosetta-mlexpression-key fractal) instance-exdata))
                                  (fractal-text (match-string (mrosetta-mlexpression-regex-key fractal) extext))
                                  (fractal-newtext (mrosetta-update fractal fractal-text fractal-exdata)))
                             (setq instance-newtext (concat instance-newtext fractal-newtext)))))
                     ;; Update leaf elements
                     (when (eq (mrosetta-mlexpression-extype mlexpression) :match)
                       ;; Update match text, including ignorable matches
                       (let* ((buffer (match-string (mrosetta-mlexpression-rbuffer-key mlexpression) extext))
                              (prefix (mrosetta-mlexpression-match-prefix mlexpression))
                              (suffix (mrosetta-mlexpression-match-suffix mlexpression))
                              (modifier-reverse (mrosetta-mlexpression-modifier-reverse mlexpression))
                              (match (or (when (and modifier-reverse instance-exdata)
                                           (funcall modifier-reverse instance-exdata))
                                         instance-exdata
                                         (match-string (mrosetta-mlexpression-rmatch-key mlexpression) extext))))
                         (setq instance-newtext (concat buffer prefix match suffix))))
                     (when (eq (mrosetta-mlexpression-extype mlexpression) :literal)
                       ;; Just include the literal instance
                       (setq instance-newtext (match-string (mrosetta-mlexpression-rinstance-key mlexpression) extext))))
                   (setq newtext (concat newtext instance-newtext))))
               ;; Return the updated text
               newtext))))))
#+END_SRC

* Demos
This section covers various examples of metalanguage syntax.

#+NAME: demo-init
#+BEGIN_SRC emacs-lisp :noweb yes :session mrosetta-demo
;; Set lexical binding
(setq lexical-binding t)

<<dependencies>>

<<mrosetta-keychain>>
<<mrosetta-keychain-generate-key>>

<<mrosetta-mlexpression>>

<<mrosetta-mlsyntax>>
<<mrosetta-mlsyntax-modifiers>>

<<mrosetta-parse-literal>>
<<mrosetta-parse-literal-symbol>>
<<mrosetta-parse-word>>
<<mrosetta-parse-word-symbol>>
<<mrosetta-parse-word-uppercase>>
<<mrosetta-parse-word-uppercase-symbol>>
<<mrosetta-parse-word-capitalized>>
<<mrosetta-parse-word-capitalized-symbol>>
<<mrosetta-parse-word-plurality>>
<<mrosetta-parse-word-plurality-symbol>>
<<mrosetta-parse-paragraph>>
<<mrosetta-parse-paragraph-symbol>>
<<mrosetta-parse-paragraph-plurality>>
<<mrosetta-parse-paragraph-plurality-symbol>>
<<mrosetta-parse-substring>>
<<mrosetta-parse-substring-symbol>>
<<mrosetta-parse-prefix>>
<<mrosetta-parse-prefix-symbol>>
<<mrosetta-parse-suffix>>
<<mrosetta-parse-suffix-symbol>>
<<mrosetta-parse-contextual>>
<<mrosetta-parse-contextual-symbol>>
<<mrosetta-parse-modifier-uppercase-symbol>>
<<mrosetta-parse-modifier-lowercase-symbol>>
<<mrosetta-parse-modifier>>
<<mrosetta-parse-modifier-symbol>>
<<mrosetta-parse-optionality>>
<<mrosetta-parse-optionality-symbol>>
<<mrosetta-parse-key>>
<<mrosetta-parse-key-symbol>>
<<mrosetta-parse-ignorable>>
<<mrosetta-parse-ignorable-symbol>>
<<mrosetta-parse-list>>
<<mrosetta-parse-list-symbol>>
<<mrosetta-parse-element>>
<<mrosetta-parse-element-symbol>>
<<mrosetta-parse-of>>
<<mrosetta-parse-of-symbol>>

<<mrosetta-parse>>
<<mrosetta-compile>>
<<mrosetta-process>>
<<mrosetta-update>>

mrosetta-mlsyntax
#+END_SRC

#+RESULTS: demo-init
: ((of . mrosetta-parse-of) (element . mrosetta-parse-element) (list . mrosetta-parse-list) (ignorable . mrosetta-parse-ignorable) (as . mrosetta-parse-key) (optional . mrosetta-parse-optionality) (to . mrosetta-parse-modifier) (contextual . mrosetta-parse-contextual) (suffixed . mrosetta-parse-suffix) (prefixed . mrosetta-parse-prefix) (with . mrosetta-parse-substring) (paragraphs . mrosetta-parse-paragraph-plurality) (paragraph . mrosetta-parse-paragraph) (words . mrosetta-parse-word-plurality) (Word . mrosetta-parse-word-capitalized) (WORD . mrosetta-parse-word-uppercase) (word . mrosetta-parse-word) (literal . mrosetta-parse-literal))

Note that by metalanguage syntax, the outermost expression is auto-parenthesized, thus making it a legitimate list expression.

#+NAME: demo-mlexpression
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input="" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition)))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-process mlexpression input))
#+END_SRC

** Words
*** Uppercase Word
Match a single uppercase word.

#+NAME: demo-word-uppercase
#+BEGIN_EXAMPLE
WORD as status
#+END_EXAMPLE

We'll use a following example of input text.

#+NAME: demo-word-uppercase-text
#+BEGIN_EXAMPLE
The current status is OPERATIONAL.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-uppercase, input=demo-word-uppercase-text )

#+RESULTS:
: (status . "OPERATIONAL")

*** Capitalized Word
Match a single capitalized word.

#+NAME: demo-word-capitalized
#+BEGIN_EXAMPLE
Word as title
#+END_EXAMPLE

#+NAME: demo-word-capitalized-text
#+BEGIN_EXAMPLE
Report: All systems operational
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-capitalized, input=demo-word-capitalized-text )

#+RESULTS:
: (title . "Report")

*** A Prefixed Word
Match a single word defined by a specific prefix.

#+NAME: demo-word-prefixed
#+BEGIN_EXAMPLE
"#" prefixed word as tag
#+END_EXAMPLE

#+NAME: demo-word-prefixed-text
#+BEGIN_EXAMPLE
A new task has been created for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-prefixed, input=demo-word-prefixed-text )

#+RESULTS:
: (tag . "devops")

*** A Suffixed Word
Match a single word defined by a specific suffix.

#+NAME: demo-word-suffixed
#+BEGIN_EXAMPLE
"!" suffixed word as priority
#+END_EXAMPLE

#+NAME: demo-word-suffixed-text
#+BEGIN_EXAMPLE
A new critical! issue submitted.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-suffixed, input=demo-word-suffixed-text )

#+RESULTS:
: (priority . "critical")

*** Word with Specific Content
Match a word containing specific content, such as a single character or substring.

#+NAME: demo-word-content
#+BEGIN_EXAMPLE
word with "/" as project
#+END_EXAMPLE

#+NAME: demo-word-content-text
#+BEGIN_EXAMPLE
A new card added in backend/api.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-content, input=demo-word-content-text )

#+RESULTS:
: (project . "backend/api")

*** Word to Uppercase
Modify the matched word to uppercase.

#+NAME: demo-word-to-uppercase
#+BEGIN_EXAMPLE
"!" prefixed word as priority to uppercase
#+END_EXAMPLE

#+NAME: demo-word-to-uppercase-text
#+BEGIN_EXAMPLE
[!high] Received a new support ticket.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-uppercase, input=demo-word-to-uppercase-text )

#+RESULTS:
: (priority . "HIGH")

*** Word to Lowercase
Modify the matched word to lowercase.

#+NAME: demo-word-to-lowercase
#+BEGIN_EXAMPLE
"#" prefixed word as label to lowercase
#+END_EXAMPLE

#+NAME: demo-word-to-lowercase-text
#+BEGIN_EXAMPLE
New message received marked for #Support!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-lowercase, input=demo-word-to-lowercase-text )

#+RESULTS:
: (label . "support")

*** List of Words
Match a list of words matching defined criteria.

#+NAME: demo-word-list
#+BEGIN_EXAMPLE
":" prefixed words as tags
#+END_EXAMPLE

#+NAME: demo-word-list-text
#+BEGIN_EXAMPLE
Task completed successfully :devops :api!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-list, input=demo-word-list-text )

#+RESULTS:
: (tags "devops" "api")

** Paragraphs
*** Paragraph Based on Criteria
Match a paragraph of text conforming to specified criteria. Note that in order to successfully match a paragraph of text, both boundaries need to be either explicitly or contextually specified.

When explicitly setting boundaries, the left boundary is implicitly the first possibly matched character.

#+NAME: demo-paragraph
#+BEGIN_EXAMPLE
": " prefixed "." suffixed paragraph as status
#+END_EXAMPLE

#+NAME: demo-paragraph-text
#+BEGIN_EXAMPLE
Status update: API service started successfully.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph, input=demo-paragraph-text )

#+RESULTS:
: (status . "API service started successfully")

*** List of Paragraphs
Match a list of consecutive paragraphs defined by specified criteria.

#+NAME: demo-paragraph-list
#+BEGIN_EXAMPLE
"." suffixed paragraphs as statements to lowercase
#+END_EXAMPLE

#+NAME: demo-paragraph-list-text
#+BEGIN_EXAMPLE
One task completed. Three tasks updated. Two tasks created.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph-list, input=demo-paragraph-list-text )

#+RESULTS:
: (statements "one task completed" "three tasks updated" "two tasks created")

** Complex Expressions
*** All-inclusive Match
Match multiple elements alongside /ignorable/ information within human readable text. Structure the match within a root property.

#+NAME: demo-complex
#+BEGIN_EXAMPLE
element of ((WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)) as task
#+END_EXAMPLE

#+NAME: demo-complex-text
#+BEGIN_EXAMPLE
CRITICAL Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex, input=demo-complex-text )

#+RESULTS:
: (task (priority . "critical") (project . "backend/api") (type . "devops"))

*** Optional Matches
Match multiple elements, one or more of which are optional in presence and aren't required to trigger a semantic match.

#+NAME: demo-complex-optional
#+BEGIN_EXAMPLE
(optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)
#+END_EXAMPLE

The following text example doesn't contain an optional element. As expected, the structured data output is processed and matched, excluding the missing optional element.

#+NAME: demo-complex-optional-text
#+BEGIN_EXAMPLE
Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-optional-text )

#+RESULTS:
: (:nokey (project . "backend/api") (type . "devops"))

By passing the example from above, containing the optional priority element, the output structure includes and matches the element.

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-text )

#+RESULTS:
: (:nokey (priority . "critical") (project . "backend/api") (type . "devops"))

*** Complex Collections
Match multiple occurrences of expressions containing multiple elements.

#+NAME: demo-complex-collection
#+BEGIN_EXAMPLE
"!" suffixed list of ((optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types)) as tasks
#+END_EXAMPLE

#+NAME: demo-complex-collection-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops! Task created in web/home for #frontend #design! BLOCKER task created in backend/api for #backend!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-collection, input=demo-complex-collection-text )

#+RESULTS:
: (tasks ((priority . "critical") (project . "backend/api") (types "devops")) ((project . "web/home") (types "frontend" "design")) ((priority . "blocker") (project . "backend/api") (types "backend")))

** Text Regeneration
Update the original text with new semantic information provided by the structured input data.

#+NAME: demo-mlexpression-update
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input-text="" input-data=""" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition))
       (sdata `(:nokey . ,(car (read-from-string (concat "(" input-data ")"))))))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-update mlexpression input-text sdata))
#+END_SRC

#+NAME: demo-regen
#+BEGIN_EXAMPLE
(WORD as priority) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types) (ignorable contextual paragraph)
#+END_EXAMPLE

#+NAME: demo-regen-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops #backend!
#+END_EXAMPLE

The structured data from input text will look like so:

#+CALL: demo-mlexpression( definition=demo-regen, input=demo-regen-text )

#+RESULTS:
: (:nokey (priority . "CRITICAL") (project . "backend/api") (types "devops" "backend"))

Now, we can pass in an updated property or two. The properties not included will remain intact.

#+NAME: demo-regen-data
#+BEGIN_EXAMPLE
(priority . "BLOCKER") (types "backend" "frontend" "devops")
#+END_EXAMPLE

#+CALL: demo-mlexpression-update( definition=demo-regen, input-text=demo-regen-text, input-data=demo-regen-data )

#+RESULTS:
: "BLOCKER task created in backend/api for #backend #frontend #devops!"

* Interface
This section defines and implements the model of interface between the Metarosetta matching engine and the Emacs editing environment.

** Configuration Directory
The directory containing all Metarosetta's configuration org files.

#+NAME: mrosetta-configuration-directory
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-configuration-directory nil
  "Metarosetta's active configuration directory.")
#+END_SRC

** Indices
These indices and reverse indices enable various types of lookups needed to create and synchronize matches throughout the Emacs environment.

*** Connector Index
All registered connectors, indexed by their respective compatible syntax types.

#+NAME: mrosetta-index-connectors
#+begin_src emacs-lisp :tangle yes
(defvar mrosetta-index-connectors '()
  "Metarosetta's global index of registered output connectors by the target syntax type symbol.")
#+end_src

*** Configuration Index
All the loaded configuration files, defined around their respective /root/ metalanguage expressions used to check against potential matches, and indexed by these expressions' keys.

#+NAME: mrosetta-index-configurations
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-index-configurations '()
  "Metarosetta's global index of loaded configurations by their respective root metalanguage expression key symbols.")
#+END_SRC

*** Match Source Reverse Index
For implicit synchronization to work, there needs to be a reverse index on all the source files, as well as output files, containing tracked matches. Each entry holds a cons pair containing the type symbol of the file in context for proper routing and the total number of tracked matches within the file in context.

#+NAME: mrosetta-index-sources
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-index-sources (make-hash-table :test 'equal)
  "Metarosetta's global reverse index of all the tracked matches by their residential file name, each entry holding a cons cell with the file type symbol and the total number of matches within.")
#+END_SRC

** Match Identification
Each unit of text, when successfully matched, gets a globally unique match identifier appended to it. This enables proper tracking between original and transpiled matches as well as continuous two-way synchronization.

*** Identifier Delimiters
A global variable defining the left and right delimiter of the identifier portion of the match in context.

#+NAME: mrosetta-id-delimiters
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-id-delimiters '("[" . "]")
  "A cons cell defining the left and right Metarosetta match identifier delimiters, respectively.")
#+END_SRC

*** Identifier Regular Expression
A helper function used to generate a regular expression matching the match identifier pattern. Each ID consists of the matching /root/ metalanguage expression key followed by a /serial/ number of the match in scope of the matching expression.

In cases of transpiled outputs, the corresponding output expression's key is appended to the original match identifier. This provides unambiguous means of distinction between original and output matches, as well as a clear indication of each output's original source match.

#+NAME: mrosetta-id-generate-re
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-id-generate-re (&rest args)
  "Generate a regular expression matching the Metarosetta match identifier pattern. Within ARGS, optionally set the :root-gkey, :match-gkey as well as the :output-gkey regex group key integers."
  (let ((left-delimiter (car mrosetta-id-delimiters))
        (right-delimiter (cdr mrosetta-id-delimiters))
        (root-gkey (plist-get args :root-gkey))
        (match-gkey (plist-get args :match-gkey))
        (output-gkey (plist-get args :output-gkey)))
    (concat "\\" left-delimiter
            "\\(?" (when root-gkey (number-to-string root-gkey)) ":"
            "[[:alpha:]]+"
            "\\)"
            "\\-"
            "\\(?" (when match-gkey (number-to-string match-gkey)) ":"
            "[[:digit:]]+"
            "\\)"
            "\\(?:"
            "\\-"
            "\\(?" (when output-gkey (number-to-string output-gkey)) ":"
            "[[:alpha:]]+"
            "\\)"
            "\\)?"
            "\\" right-delimiter)))
#+END_SRC

*** Parse Match Identifier
Given a match identifier string, parse it and return its defining components consisting of the root metalanguage expression key, the match serial key and the optional output metalanguage expression key if present.

#+NAME: mrosetta-id-parse-match-identifier
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-id-parse-match-identifier (match-identifier)
  "Parse the MATCH-IDENTIFIER and return a property list containing the root metalanguage expression key under :root-key, match serial key under :match-serial and the optional output expression key under :output-key. Given an invalid match, return nil."
  (save-match-data
    (and match-identifier
         (string-match (concat "^"
                               (mrosetta-id-generate-re :root-gkey 1
                                                        :match-gkey 2
                                                        :output-gkey 3)
                               "$")
                       match-identifier)
         ;; Provided match identifier is of valid format
         (let* ((root-key (intern (match-string 1 match-identifier)))
                (match-serial (string-to-number (match-string 2 match-identifier)))
                (output-key-string (match-string 3 match-identifier))
                (output-key (when output-key-string
                              (intern output-key-string))))
           ;; Return the parsed identifier
           `(:root-key ,root-key
             :match-serial ,match-serial
             :output-key ,output-key)))))
#+END_SRC

*** Parse Match with Identifier
Given a full match, including the match identifier, parse the identifier portion and return the core match in addition to the parsed match identifier consisting of the matching root metalanguage expression key, the serial key of the match in context and an optional output metalanguage expression key in cases of output matches.

#+NAME: mrosetta-id-parse-match
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-id-parse-match (full-match)
  "Parse the match identifier portion of the FULL-MATCH, and return a property list containing the root metalanguage expression key under :root-key, match serial key under :match-serial and the optional output expression key under :output-key, and lastly the core match under :core-match. Given an invalid match, return nil."
  (let ((full-match-regex (concat "^"
                                  ;; Match the core portion of the full match
                                  "\\(?1:.+\\)"
                                  " "
                                  ;; Match the identifier portion of the full match
                                  (mrosetta-id-generate-re :root-gkey 2
                                                           :match-gkey 3
                                                           :output-gkey 4)
                                  "$")))
    (save-match-data
      (and full-match
           (string-match full-match-regex full-match)
           ;; Provided full match is of valid format
           (let* ((core-match (match-string 1 full-match))
                  (root-key (intern (match-string 2 full-match)))
                  (match-serial (string-to-number (match-string 3 full-match)))
                  (output-key-string (match-string 4 full-match))
                  (output-key (when output-key-string
                                (intern output-key-string))))
             ;; Return the parsed data structure
             `(:root-key ,root-key
               :match-serial ,match-serial
               :output-key ,output-key
               :core-match ,core-match))))))
#+END_SRC

*** Serialize Identifier
Given the root expression key, match serial key and an optional output expression key, compose the string representation of the match identifier.

#+NAME: mrosetta-id-serialize-match-identifier
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-id-serialize-match-identifier (&rest args)
  "Serialize the match identifier to string form from ARGS containing the root expression key symbol under :root-key, the match serial key integer under :match-serial and an optional output expression key symbol under :output-key."
  (let ((root-key (plist-get args :root-key))
        (match-serial (plist-get args :match-serial))
        (output-key (plist-get args :output-key))
        (left-delimiter (car mrosetta-id-delimiters))
        (right-delimiter (cdr mrosetta-id-delimiters)))
    ;; Return the match identifier in string form
    (concat left-delimiter
            (symbol-name root-key)
            "-"
            (number-to-string match-serial)
            (when output-key
              (concat "-"
                      (symbol-name output-key)))
            right-delimiter)))
#+END_SRC

*** Serialize Match with Identifier
Given a core match string, along with a root expression key, match serial key and an optional output expression key, return the full string representation of the match including the match identifier.

#+NAME: mrosetta-id-serialize-match
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-id-serialize-match (&rest args)
  "Serialize the full match string by composing the match identifier from the :root-key, :match-serial and an optional :output-key within ARGS and ultimately appending it to the :core-match in string form."
  (concat (plist-get args :core-match)
          " "
          (apply 'mrosetta-id-serialize-match-identifier args)))
#+END_SRC

** Org Configuration File
The definition and configuration of particular metalanguage expressions is organized around specifically-structured org files.

Each individual org configuration file defines a /root/ metalanguage expression, used to parse matching text from any source within the Emacs editing environment, in addition to one or more /output/ expressions, which define data-compatible /target/ formats for parsed data output as well as continuous two-way synchronization.

*** Configuration Objects
The org configuration file is structured as a list of so-called configuration objects defined by their respective metalanguage expressions, and containing all the tracked matches with their corresponding and relevant metadata.

**** Expression Object
The basic building block is the expression configuration object, which corresponds to a root-level org headline with org properties for various configuration parameters, as well as sub-headings representing all the respective matches processed so far.

Note that all matches are indexed by their unique match ID, enabling lookup for match updates. For sake of simplicity, this is currently implemented as a simple alist, but will probably be converted to a proper hash table later on, to improve lookup performance.

#+NAME: mrosetta-org-expression
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-org-expression ()
  ((mlexpression
    :type mrosetta-mlexpression
    :documentation "The actual metalanguage expression of the org expression object in context.")
   (key
    :type symbol
    :documentation "The symbol uniquely representing the expression in context. All expression matches contained within are prefixed with this key."
    :reader mrosetta-org-expression-key)
   (match-type
    :type symbol
    :documentation "The symbol of the specific mrosetta-org-match subclass defining all the tracked matches within this expression object.")
   (matches
    :type list
    :documentation "A serial.match alist containing the org match objects corresponding to all the processed and tracked matches of the expression in context."))
  "The Metarosetta org configuration object representing a specific metalanguage expression."
  :abstract t)
#+END_SRC

***** Match Object
This is an object corresponding to an org headline element representing a single match of the parent metalanguage expression.

#+NAME: mrosetta-org-match
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-org-match ()
  ((raw-match
    :initarg :raw-match
    :type string
    :documentation "The full textual match in context."
    :reader mrosetta-org-match-raw
    :writer mrosetta-org-match-raw-set)
   (parsed-match
    :initarg :parsed-match
    :type list
    :documentation "The parsed match structure, generated by processing the textual match through the metalanguage expression in context."
    :reader mrosetta-org-match-parsed
    :writer mrosetta-org-match-parsed-set)
   (match-hash
    :initarg :match-hash
    :type number
    :documentation "An integer hash of the raw match in context. This is used for tracking any potential updates to the match."
    :reader mrosetta-org-match-hash
    :writer mrosetta-org-match-hash-set)
   (root-key
    :initarg :root-key
    :type symbol
    :documentation "The key symbol of the root configuration object defining the match origin."
    :reader mrosetta-org-match-root-key)
   (serial
    :initarg :serial
    :type number
    :documentation "The serial number of the match in context, in scope of the matching expression."
    :reader mrosetta-org-match-serial)
   (last-updated
    :initarg :last-updated
    :type string
    :documentation "The human-readable string of a timestamp when the match in context was last updated."
    :writer mrosetta-org-match-last-updated-set)
   (op-type
    :initarg :op-type
    :type symbol
    :documentation "A keyword symbol specifying the type of the last operation done on the match in context. Can either be :created, :downloaded or :uploaded."
    :writer mrosetta-org-match-op-type-set))
  "The Metarosetta org configuration object representing a single match of a given metalanguage expression."
  :abstract t)
#+END_SRC

**** Root Expression Object
The first root-level headline within the org configuration file.

It represents the /root/ metalanguage expression in context of the org file. This is the expression used to pattern-match any text when invoking Metarosetta from within any source file of any textual type.

#+NAME: mrosetta-org-expression-root
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-org-expression-root (mrosetta-org-expression)
  ((match-type
    :initform 'mrosetta-org-match-original)
   (match-keychain
    :type mrosetta-keychain
    :documentation "The keychain instance responsible for generating unique original match keys in scope of the org expression object in context."))
  "The Metarosetta org configuration object representing the root metalanguage expression in context of its containing org file.")
#+END_SRC

***** Original Match Object
An org match object representing a single respective match of its root metalanguage expression.

#+NAME: mrosetta-org-match-original
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-org-match-original (mrosetta-org-match)
  ((source-filename
    :initarg :source-filename
    :type string
    :documentation "The filename of the source file where the match in context originally resides."
    :reader mrosetta-org-match-original-source-filename))
  "The Metarosetta org configuration object representing a single original match of its defining root metalanguage expression.")
#+END_SRC

***** Original Match Source Filename Getter
A lookup method for a source filename of a given original match object.

#+NAME: mrosetta-org-expression-root-match-source-filename
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-expression-root-match-source-filename ((oexpression mrosetta-org-expression-root) match-serial)
  "Given the provided MATCH-SERIAL key, return the source filename of the corresponding original match in context of the OEXPRESSION Metarosetta root expression configuration object. If no such match exists, return nil."
  (let ((match (cdr (assq match-serial
                          (slot-value oexpression 'matches)))))
    ;; Return source filename if match found
    (when match
      (mrosetta-org-match-original-source-filename match))))
#+END_SRC

**** Output Expression Object
An org configuration object representing an /output/ metalanguage expression.

Within a single org configuration file, there can be one or more expressions of this type, defined as root-level headlines following the /root/ expression.

These are used to format the output of the data structure generated by matching original text instances against the /root/ expression. Naturally, this implies that output expressions can *only* contain keys defined within the /root/ metalanguage expression, and as such present in the generated data structure.

#+NAME: mrosetta-org-expression-output
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-org-expression-output (mrosetta-org-expression)
  ((match-type
    :initform 'mrosetta-org-match-output)
   (target-type
    :type symbol
    :documentation "A symbol denoting the type of the target file or endpoint where the match in context should be appended to, or sent to.")
   (target-endpoint-template
    :type string
    :documentation "The template of the target filename, or URI, where the match in context should be added to. In addition to literal elements along the path, $-prefixed expression key symbols can be used to interpolate processed expression elements into the path itself.")
   (target-section-template
    :type string
    :documentation "The template of the '/'-delimited section path defining the exact section within the target under which the match should reside or be sent to. In addition to literal sections along the path, $-prefixed expression key symbols can be used to interpolate expression elements into the path itself.")
   (template
    :type string
    :documentation "A string used as an output template based on which the expression in context will generate the output text itself."))
  "The Metarosetta org configuration object representing an output expression in context of its containing org file.")
#+END_SRC

***** Output Match Object
An org match object representing an output respective to the original match, as defined by its encompassing output expression.

#+NAME: mrosetta-org-match-output
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-org-match-output (mrosetta-org-match)
  ((output-key
    :initarg :output-key
    :type symbol
    :documentation "The key symbol of the output configuration object defining the match output."
    :reader mrosetta-org-match-output-key)
   (target-type
    :initarg :target-type
    :type symbol
    :documentation "A symbol denoting the type of the target file or endpoint where the match in context should be appended to, or sent to.")
   (target-endpoint
    :initarg :target-endpoint
    :type string
    :documentation "The literal filename, or URI, of the target where the match in context should be appended to, or sent to."
    :reader mrosetta-org-match-output-target-endpoint
    :writer mrosetta-org-match-output-target-endpoint-set)
   (target-section
    :initarg :target-section
    :type string
    :documentation "The full section path defining the exact section within the target under which the match should reside or be sent to."
    :reader mrosetta-org-match-output-target-section))
  "The Metarosetta org configuration object representing an output match defined by its encompassing output expression.")
#+END_SRC

**** Configuration Set Object
The configuration set represents an all-encompassing configuration object in context of a particular Metarosetta configuration file.

A configuration set consists of a single /root/ expression and one or more /output/ expressions.

#+NAME: mrosetta-org-config
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-org-config ()
  ((source-filename
    :initarg :source-filename
    :type string
    :documentation "The filename of the source org file for the configuration in context."
    :reader mrosetta-org-config-source-filename)
   (root-expression
    :type mrosetta-org-expression-root
    :documentation "The root expression configuration object in context of the configuration set.")
   (output-expressions
    :type list
    :documentation "An alist of output expression configuration objects by their respective expression keys in context of the configuration set."))
  "The Metarosetta org configuration object ")
#+END_SRC

***** Configuration Set Key
Each configuration set's key is simply its defining root configuration's key.

#+NAME: mrosetta-org-config-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-config-key ((oconfig mrosetta-org-config))
  "Return the unique key symbol defining the OCONFIG Metarosetta org configuration object."
  (mrosetta-org-expression-key (slot-value oconfig 'root-expression)))
#+END_SRC

***** Root Expression's Original Match Source Filename Getter
Look up the original match source filename given its serial key.

#+NAME: mrosetta-org-config-original-match-source-filename
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-config-original-match-source-filename ((oconfig mrosetta-org-config) match-serial)
  "Given the provided MATCH-SERIAL key, return the source filename of the corresponding original match in context of the root expression within the OCONFIG Metarosetta configuration set object. If no such match exists, return nil."
  (mrosetta-org-expression-root-match-source-filename (slot-value oconfig 'root-expression) match-serial))
#+END_SRC

*** Parsing and Serializing The Org File Structure
All the configuration objects defined above are serialized and persisted as org elements. This allows for inherent human interoperability, seamless configuration as well as a single source of truth.

**** Configuration Objects
All configuration objects have their respective (de)serialization function pairs, encapsulating the parsing semantics in context of corresponding objects.

***** Expression Object
The parsing and serialization concerning the org expression object's base properties.

****** Parse Object
Given the containing org headline element, parse its title as the metalanguage definition for the initialization of the metalanguage expression defining the org configuration object in context. In addition, parse all the defined headline properties as well as contained subheadlines into match objects.

#+NAME: mrosetta-org-parse-expression
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-parse ((oexpression mrosetta-org-expression) oelement)
  "Parse and compile the metalanguage expression, along with other properties, defined by the org-ml headline element OELEMENT into the OEXPRESSION instance. Recursively parse all match elements contained within OELEMENT."
  ;; Parse the metalanguage expression
  (let* ((mldefinition-string (car (org-ml-get-property :title oelement)))
         (mldefinition (car (read-from-string (concat "(" mldefinition-string ")"))))
         (mlexpression (mrosetta-mlexpression :mldefinition mldefinition)))
    ;; Parse and compile the loaded metalanguage expression, so it's ready for textual processing
    (mrosetta-parse mlexpression)
    (mrosetta-compile mlexpression)
    ;; Finally, store the initialized metalanguage expression into the configuration object
    (setf (slot-value oexpression 'mlexpression) mlexpression))
  ;; Parse the expression's key symbol
  (let ((key (intern (org-ml-headline-get-node-property "KEY" oelement))))
    (setf (slot-value oexpression 'key) key))
  ;; Recursively parse all tracked matches
  (let ((match-type (slot-value oexpression 'match-type)))
    (setf (slot-value oexpression 'matches)
          (mapcar (lambda (match-oelement)
                    (let ((omatch (mrosetta-org-parse (make-instance match-type) match-oelement)))
                      `(,(mrosetta-org-match-serial omatch) . ,omatch)))
                  (org-ml-headline-get-subheadlines oelement))))
  ;; Return the parsed object
  oexpression)
#+END_SRC

****** Serialize Object
Serialize the org configuration expression object into its corresponding org headline element. Recursively serialize all the contained matches into subheadlines.

#+NAME: mrosetta-org-serialize-expression
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-serialize ((oexpression mrosetta-org-expression))
  "Serialize the OEXPRESSION into an org-ml headline element. Also, recursively serialize all the contained match objects."
  (let* ((mlexpression (slot-value oexpression 'mlexpression))
         (key (slot-value oexpression 'key))
         (matches (slot-value oexpression 'matches))
         (mldefinition (slot-value mlexpression 'mldefinition))
         ;; Serialize the metalanguage definition to string form
         (mldefinition-string (mapconcat 'prin1-to-string mldefinition " "))
         ;; Serialize the expression key's symbol to string form
         (key-string (symbol-name key))
         ;; Create the org-ml headline element with the serialized ml definition as title
         (oelement (org-ml-build-headline :level 1 :title `(,mldefinition-string))))
    ;; Append the expression key within the headline element property drawer
    (setq oelement (org-ml-headline-set-node-property "KEY" key-string oelement))
    ;; Recursively serialize contained matches and set them as element subheadlines
    (setq oelement (org-ml-headline-set-subheadlines (mapcar (lambda (match-pair)
                                                               (let ((match (cdr match-pair)))
                                                                 (mrosetta-org-serialize match)))
                                                             matches)
                                                     oelement))
    ;; Return the serialized org-ml element
    oelement))
#+END_SRC

***** Match Object
The parsing and serialization of the org match object's base properties.

****** Parse Object
Given an org headline element, parse the textual match itself, along with its metadata, into a org configuration object in context.

#+NAME: mrosetta-org-parse-match
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-parse ((omatch mrosetta-org-match) oelement)
  "Parse the textual match and its corresponding metadata defined by the org-ml headline element OELEMENT into the OMATCH instance."
  ;; Parse the raw textual match
  (let ((raw-match (car (org-ml-get-property :title oelement))))
    (setf (slot-value omatch 'raw-match) raw-match))
  ;; Parse the processed match structure from the contained source block
  (let* ((source-block (cadr (org-ml-headline-get-section oelement)))
         (parsed-match (car (read-from-string (org-ml-get-property :value source-block)))))
    (setf (slot-value omatch 'parsed-match) parsed-match))
  ;; Parse the integer hash of the raw match used for comparison purposes
  (let ((match-hash (string-to-number (org-ml-headline-get-node-property "HASH" oelement))))
    (setf (slot-value omatch 'match-hash) match-hash))
  ;; Set the match root key
  (let ((root-key (intern (org-ml-headline-get-node-property "ROOT-KEY" oelement))))
    (setf (slot-value omatch 'root-key) root-key))
  ;; Set the actual match identifier
  (let ((serial (string-to-number (org-ml-headline-get-node-property "SERIAL" oelement))))
    (setf (slot-value omatch 'serial) serial))
  ;; Set the last updated metadata property
  (let ((last-updated (org-ml-headline-get-node-property "LAST-UPDATED" oelement)))
    (setf (slot-value omatch 'last-updated) last-updated))
  ;; Set the operation type keyword in context of the last update
  (let ((op-type (intern (org-ml-headline-get-node-property "OPERATION-TYPE" oelement))))
    (setf (slot-value omatch 'op-type) op-type))
  ;; Return the parsed object
  omatch)
#+END_SRC

****** Serialize Object
Serialize the org configuration match object into its corresponding org headline element.

#+NAME: mrosetta-org-serialize-match
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-serialize ((omatch mrosetta-org-match))
  "Serialize the OMATCH into an org-ml headline element."
  (let* ((raw-match (slot-value omatch 'raw-match))
         (parsed-match (slot-value omatch 'parsed-match))
         (match-hash (slot-value omatch 'match-hash))
         (root-key (slot-value omatch 'root-key))
         (serial (slot-value omatch 'serial))
         (last-updated (slot-value omatch 'last-updated))
         (op-type (slot-value omatch 'op-type))
         ;; Create the org-ml headline element with the raw match as its title
         (oelement (org-ml-build-headline :level 2 :title `(,raw-match)))
         ;; Serialize the parsed match Lisp structure into an org source block
         (source-block (org-ml-build-src-block :language "emacs-lisp"
                                               :value (prin1-to-string parsed-match))))
    ;; Set the serialized source block as the org element's inner section
    (setq oelement (org-ml-headline-set-section `(,source-block) oelement))
    ;; Append the match hash and identifier, as well as last updated and operation type metadata properties within the headline element property drawer
    (setq oelement (->> (org-ml-headline-set-node-property "HASH" (number-to-string match-hash) oelement)
                        (org-ml-headline-set-node-property "ROOT-KEY" (symbol-name root-key))
                        (org-ml-headline-set-node-property "SERIAL" (number-to-string serial))
                        (org-ml-headline-set-node-property "LAST-UPDATED" last-updated)
                        (org-ml-headline-set-node-property "OPERATION-TYPE" (symbol-name op-type))))
    ;; Return the serialized org-ml element
    oelement))
#+END_SRC

***** Root Expression Object
The parsing and serialization of the root expression configuration object.

****** Parse Object
Parse all the root expression's specific properties along with all the general expression ones.

#+NAME: mrosetta-org-parse-expression-root
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-parse ((oexpression mrosetta-org-expression-root) oelement)
  "Parse and compile the root metalanguage expression, along with other properties, defined by the org-ml headline element OELEMENT into the OEXPRESSION instance. Recursively parse all original match elements contained within OELEMENT."
  ;; First parse the base expression properties, including the metalanguage expression as well as child matches
  (cl-call-next-method)
  ;; Parse the last serial match key, and use it to initialize the keychain in context of the expression
  (let ((last-match-key (string-to-number (or (org-ml-headline-get-node-property "LAST-MATCH-KEY" oelement)
                                              ;; If no last key property recorded, just initialize with an empty string resulting in the integer 0
                                              ""))))
    (setf (slot-value oexpression 'match-keychain) (mrosetta-keychain :lastkey last-match-key)))
  ;; Return the parsed object
  oexpression)
#+END_SRC

****** Serialize Object
Serialize the org configuration object of the root expression into a corresponding org headline element.

#+NAME: mrosetta-org-serialize-expression-root
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-serialize ((oexpression mrosetta-org-expression-root))
  "Serialize the root OEXPRESSION into an org-ml headline element. ALso, recursively serialize all the contained original match objects."
  (let* ((match-keychain (slot-value oexpression 'match-keychain))
         (last-match-key (mrosetta-keychain-lastkey match-keychain))
         ;; Serialize the base properties first
         (oelement (cl-call-next-method)))
    ;; Append the root expression-specific properties within the headline element property drawer
    (setq oelement (org-ml-headline-set-node-property "LAST-MATCH-KEY" (number-to-string last-match-key) oelement))
    ;; Return the serialized org-ml element
    oelement))
#+END_SRC

***** Original Match Object
The parsing and serialization of a particular tracked and processed original match.

****** Parse Object
Parse all the original match properties from a given org headline element located within the root expression org section.

#+NAME: mrosetta-org-parse-match-original
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-parse ((omatch mrosetta-org-match-original) oelement)
  "Parse the textual original match and its corresponding metadata defined by the org-ml headline element OELEMENT into the OMATCH instance."
  ;; Parse the base properties first
  (cl-call-next-method)
  ;; Parse the source filename where the original match is tracked from
  (let ((source-filename (org-ml-headline-get-node-property "SOURCE-FILE" oelement)))
    (setf (slot-value omatch 'source-filename) source-filename)
    ;; Update the reverse index of sources
    (let ((index-entry (gethash source-filename
                                mrosetta-index-sources
                                '(:root . 0))))
      (puthash source-filename
               `(,(car index-entry) . ,(1+ (cdr index-entry)))
               mrosetta-index-sources)))
  ;; Return the parsed object
  omatch)
#+END_SRC

****** Serialize Object
Serialize the org configuration object of an original match and its metadata into a corresponding org headline element.

#+NAME: mrosetta-org-serialize-match-original
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-serialize ((omatch mrosetta-org-match-original))
  "Serialize the original match object OMATCH into an org-ml headline element."
  (let ((source-filename (slot-value omatch 'source-filename))
        ;; Serialize the base properties first
        (oelement (cl-call-next-method)))
    ;; Append the source filename within the headline element property drawer
    (setq oelement (org-ml-headline-set-node-property "SOURCE-FILE" source-filename oelement))
    ;; Return the serialized org-ml element
    oelement))
#+END_SRC

***** Output Expression Object
The parsing and serialization of the org configuration object defining a particular output expression, specifying the format and place where matches get transpiled to.

****** Parse Object
Parse all the output expression properties from a given headline element.

#+NAME: mrosetta-org-parse-expression-output
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-parse ((oexpression mrosetta-org-expression-output) oelement)
  "Parse and compile the metalanguage expression, along with other output expression properties, defined by the org-ml headline element OELEMENT into the OEXPRESSION instance. Recursively parse all match output elements contained within OELEMENT."
  ;; First parse the base expression properties, including the metalanguage expression as well as child matches
  (cl-call-next-method)
  ;; Parse the target type symbol, referencing the corresponding output connector
  (let ((target-type (intern (org-ml-headline-get-node-property "TARGET-TYPE" oelement))))
    (setf (slot-value oexpression 'target-type) target-type))
  ;; Parse the target endpoint template
  (let ((target-endpoint-template (org-ml-headline-get-node-property "TARGET-ENDPOINT-TEMPLATE" oelement)))
    (setf (slot-value oexpression 'target-endpoint-template) target-endpoint-template))
  ;; Parse the target section template
  (let ((target-section-template (org-ml-headline-get-node-property "TARGET-SECTION-TEMPLATE" oelement)))
    (setf (slot-value oexpression 'target-section-template) target-section-template))
  ;; Parse the output template string
  (let ((template (org-ml-headline-get-node-property "TEMPLATE" oelement)))
    (setf (slot-value oexpression 'template) template))
  ;; Return the parsed object
  oexpression)
#+END_SRC

****** Serialize Object
Serialize the org configuration object of the output expression into a corresponding headline element.

#+NAME: mrosetta-org-serialize-expression-output
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-serialize ((oexpression mrosetta-org-expression-output))
  "Serialize the output OEXPRESSION into an org-ml headline element. Also, recursively serialize all the contained match objects."
  (let ((target-type (slot-value oexpression 'target-type))
        (target-endpoint-template (slot-value oexpression 'target-endpoint-template))
        (target-section-template (slot-value oexpression 'target-section-template))
        (template (slot-value oexpression 'template))
        ;; Serialize the base properties first
        (oelement (cl-call-next-method)))
    ;; Append all the essential output expression properties within the headline element property drawer
    (setq oelement (->> (org-ml-headline-set-node-property "TARGET-TYPE" (symbol-name target-type) oelement)
                        (org-ml-headline-set-node-property "TARGET-ENDPOINT-TEMPLATE" target-endpoint-template)
                        (org-ml-headline-set-node-property "TARGET-SECTION-TEMPLATE" target-section-template)
                        (org-ml-headline-set-node-property "TEMPLATE" template)))
    ;; Return the serialized org-ml element
    oelement))
#+END_SRC

***** Output Match Object
The parsing and serialization of a particular transpiled match instance.

****** Parse Object
Parse all the output match properties from a given headline element.

#+NAME: mrosetta-org-parse-match-output
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-parse ((omatch mrosetta-org-match-output) oelement)
  "Parse the textual output match and its corresponding metadata defined by the org-ml headline element OELEMENT into the OMATCH instance."
  ;; Parse the base properties first
  (cl-call-next-method)
  ;; Set the match output key
  (let ((output-key (intern (org-ml-headline-get-node-property "OUTPUT-KEY" oelement))))
    (setf (slot-value omatch 'output-key) output-key))
  ;; Parse the target type as well as endpoint where the output match is placed to
  (let ((target-type (intern (org-ml-headline-get-node-property "TARGET-TYPE" oelement)))
        (target-endpoint (org-ml-headline-get-node-property "TARGET-ENDPOINT" oelement)))
    (setf (slot-value omatch 'target-type) target-type)
    (setf (slot-value omatch 'target-endpoint) target-endpoint)
    ;; Update the reverse index of sources
    (let ((index-entry (gethash target-endpoint
                                mrosetta-index-sources
                                `(,target-type . 0))))
      (puthash target-endpoint
               `(,(car index-entry) . ,(1+ (cdr index-entry)))
               mrosetta-index-sources)))
  ;; Parse the target section path defining the section within which the output match is placed
  (let ((target-section (org-ml-headline-get-node-property "TARGET-SECTION" oelement)))
    (setf (slot-value omatch 'target-section) target-section))
  ;; Return the parsed object
  omatch)
#+END_SRC

****** Serialize Object
Serialize the org configuration object of an output match and its metadata into a corresponding org headline element.

#+NAME: mrosetta-org-serialize-match-output
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-serialize ((omatch mrosetta-org-match-output))
  "Serialize the output match object OMATCH into an org-ml headline element."
  (let ((output-key (slot-value omatch 'output-key))
        (target-type (slot-value omatch 'target-type))
        (target-endpoint (slot-value omatch 'target-endpoint))
        (target-section (slot-value omatch 'target-section))
        ;; Serialize the base properties first
        (oelement (cl-call-next-method)))
    ;; Append the target endpoint as well as the section path within the headline element property drawer
    (setq oelement (->> (org-ml-headline-set-node-property "OUTPUT-KEY" (symbol-name output-key) oelement)
                        (org-ml-headline-set-node-property "TARGET-TYPE" (symbol-name target-type))
                        (org-ml-headline-set-node-property "TARGET-ENDPOINT" target-endpoint)
                        (org-ml-headline-set-node-property "TARGET-SECTION" target-section)))
    ;; Return the serialized org-ml element
    oelement))
#+END_SRC

***** Configuration Set Object
The parsing and serialization of an encompassing configuration set object.

****** Parse Object
Parse the entire configuration set from an org-ml subtree.

#+NAME: mrosetta-org-parse-config
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-parse ((oconfig mrosetta-org-config) otree)
  "Parse the configuration tree defined by the org-ml subtree OTREE into the OCONFIG instance."
  ;; Parse the root and output expressions respectively
  (let ((root-oelement (car otree))
        (output-oelements (cdr otree)))
    ;; Parse the single root expression object
    (setf (slot-value oconfig 'root-expression)
          (mrosetta-org-parse (mrosetta-org-expression-root) root-oelement))
    ;; Parse and map all the output expression objects contained within the configuration tree
    (setf (slot-value oconfig 'output-expressions)
          (mapcar (lambda (output-oelement)
                    (let ((output-oexpression (mrosetta-org-parse (mrosetta-org-expression-output) output-oelement)))
                      `(,(mrosetta-org-expression-key output-oexpression) . ,output-oexpression)))
                  output-oelements)))
  ;; Return the parsed object
  oconfig)
#+END_SRC

****** Serialize Object
Serialize the configuration set object into an org-ml subtree.

#+NAME: mrosetta-org-serialize-config
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-serialize ((oconfig mrosetta-org-config))
  "Serialize the configuration set object OCONFIG into a corresponding org-ml subtree."
  (let ((root-expression (slot-value oconfig 'root-expression))
        (output-expressions (slot-value oconfig 'output-expressions)))
    ;; Return the serialized org-ml subtree
    `(,(mrosetta-org-serialize root-expression)
      ,@(mapcar (lambda (output-expression-pair)
                  (let ((output-expression (cdr output-expression-pair)))
                    (mrosetta-org-serialize output-expression)))
                output-expressions))))
#+END_SRC

*** Managing Matches
This section covers the core operations of match additions and updates within the context of Metarosetta configuration objects.

**** Adding New Matches
Add brand new potential matches to the configuration.

Note that an add operation results in actual addition only in cases where the provided text correctly matches with the metalanguage expression in context.

***** Root Expression
Add a new original match in context of the root expression object.

#+NAME: mrosetta-org-expression-root-add
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-expression-root-add ((oexpression mrosetta-org-expression-root) raw-match-candidate source-filename)
  "Match the RAW-MATCH-CANDIDATE from SOURCE-FILENAME against the metalanguage expression in context of the provided OEXPRESSION Metarosetta configuration object. If successful, add the new match into configuration and return it. Otherwise return nil."
  (let* ((root-key (slot-value oexpression 'key))
         (mlexpression (slot-value oexpression 'mlexpression))
         (match-keychain (slot-value oexpression 'match-keychain))
         (parsed-match (mrosetta-process mlexpression raw-match-candidate))
         new-match)
    ;; Proceed only if match correctly processed
    (when parsed-match
      ;; Create the new match configuration object
      (setq new-match (mrosetta-org-match-original :raw-match raw-match-candidate
                                                   :parsed-match parsed-match
                                                   ;; Generate and save an equality-check-suitable hash
                                                   :match-hash (sxhash-equal raw-match-candidate)
                                                   :root-key root-key
                                                   ;; Generate a new serial for the new match
                                                   :serial (mrosetta-keychain-generate-key match-keychain)
                                                   :last-updated (current-time-string)
                                                   :op-type :created
                                                   :source-filename source-filename))
      ;; Add the match to the top of the matches association list, by its serial key
      (push `(,(mrosetta-org-match-serial new-match) . ,new-match)
            (slot-value oexpression 'matches))
      ;; Add the match to the reverse index by the source file name
      (let ((index-entry (gethash source-filename
                                  mrosetta-index-sources
                                  '(:root . 0))))
        (puthash source-filename
                 `(,(car index-entry) . ,(1+ (cdr index-entry)))
                 mrosetta-index-sources))
      ;; Return the newly added match
      new-match)))
#+END_SRC

***** Output Expression
Generate a new output match in context of the output expression object, based on the structured data parsed from the original match and the output's template.

#+NAME: mrosetta-org-expression-output-add
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-expression-output-add ((oexpression mrosetta-org-expression-output) original-match)
  "Based on the provided ORIGINAL-MATCH, generate a new output match by interpolating the original's parsed data into the template in context of the OEXPRESSION Metarosetta configuration object, add the match into configuration and finally return it."
  (let* ((output-key (slot-value oexpression 'key))
         (mlexpression (slot-value oexpression 'mlexpression))
         (target-type (slot-value oexpression 'target-type))
         (connector (cdr (assq target-type mrosetta-index-connectors)))
         (target-endpoint-template (slot-value oexpression 'target-endpoint-template))
         (target-endpoint "")
         (target-section-template (slot-value oexpression 'target-section-template))
         (target-section "")
         (template (slot-value oexpression 'template))
         (raw-match (mrosetta-update mlexpression template (mrosetta-org-match-parsed original-match)))
         (parsed-match (mrosetta-process mlexpression raw-match))
         new-match)
    ;; Interpolate data into endpoint and section templates first
    (cl-labels ((interpolate-into-path (path)
                                       (when (and path
                                                  (> (length path) 0))
                                         ;; Use regular expression to split the path between static and dynamic parts
                                         (save-match-data
                                           (or (when (string-match "^\\(?1:\\(?:/?[^/]+\\)*\\)\\(?2:/\\)?\\$\\(?3:[[:word:]]+\\)\\(?4:.*\\)$" path)
                                                 ;; Replace the path element's key symbol with the corresponding data value
                                                 (let* ((static-path (match-string 1 path))
                                                        ;; Grab the possible separator, depending on key location within the path
                                                        (path-element-separator (match-string 2 path))
                                                        (path-element-key (intern (match-string 3 path)))
                                                        ;; By convention, path keys should reside just under the root metalanguage expression key
                                                        (path-element (cdr (assq path-element-key (cdr (mrosetta-org-match-parsed original-match)))))
                                                        (rest-of-path (match-string 4 path)))
                                                   ;; If path element is a list, convert it to path
                                                   (when (listp path-element)
                                                     (setq path-element (string-join path-element "/")))
                                                   ;; Recursively parse through all path element key symbols
                                                   (concat static-path
                                                           path-element-separator path-element
                                                           (interpolate-into-path rest-of-path))))
                                               ;; No dynamic path elements left
                                               path)))))
      (setq target-endpoint (interpolate-into-path target-endpoint-template)
            target-section (interpolate-into-path target-section-template)))
    ;; Create the new output match configuration object
    (setq new-match (mrosetta-org-match-output :raw-match raw-match
                                               :parsed-match parsed-match
                                               :match-hash (sxhash-equal raw-match)
                                               :root-key (mrosetta-org-match-root-key original-match)
                                               :serial (mrosetta-org-match-serial original-match)
                                               :output-key output-key
                                               :last-updated (current-time-string)
                                               :op-type :created
                                               :target-type target-type
                                               :target-endpoint target-endpoint
                                               :target-section target-section))
    ;; Add the match to the top of the matches association list, by its serial key
    (push `(,(mrosetta-org-match-serial new-match) . ,new-match)
          (slot-value oexpression 'matches))
    ;; Push out the new output match through the connector, and get the ultimate endpoint
    (setq target-endpoint (mrosetta-out-add connector
                                            target-endpoint target-section
                                            `(:root-key ,(mrosetta-org-match-root-key new-match)
                                              :match-serial ,(mrosetta-org-match-serial new-match)
                                              :output-key ,(mrosetta-org-match-output-key new-match)
                                              :core-match ,(mrosetta-org-match-raw new-match))))
    ;; Update the endpoint within the match
    (mrosetta-org-match-output-target-endpoint-set new-match target-endpoint)
    ;; Add the match to the reverse index by the output endpoint name
    (let ((index-entry (gethash target-endpoint
                                mrosetta-index-sources
                                `(,target-type . 0))))
      (puthash target-endpoint
               `(,(car index-entry) . ,(1+ (cdr index-entry)))
               mrosetta-index-sources))
    ;; Return the newly added output match
    new-match))
#+END_SRC

***** Configuration Set
Add a new original match in context of the encompassing configuration set object.

#+NAME: mrosetta-org-config-add
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-config-add ((oconfig mrosetta-org-config) raw-match-candidate source-filename)
  "Try to add the RAW-MATCH-CANDIDATE from SOURCE-FILENAME into the OCONFIG Metarosetta org configuration. If it is successfully added, return the newly added original match property list containing the :root-key, :match-serial and :core-match. Otherwise return nil."
  (let* ((root-oexpression (slot-value oconfig 'root-expression))
         (output-oexpressions (slot-value oconfig 'output-expressions))
         (added-match (mrosetta-org-expression-root-add root-oexpression raw-match-candidate source-filename)))
    ;; Proceed only if match successfully added to root configuration object
    (when added-match
      ;; Pass along the added original match to all the configured output expressions
      (mapc (lambda (output-oexpression-pair)
              (let ((output-oexpression (cdr output-oexpression-pair)))
                (mrosetta-org-expression-output-add output-oexpression added-match)))
            output-oexpressions)
      ;; Return the newly added original match
      `(:root-key ,(mrosetta-org-match-root-key added-match)
        :match-serial ,(mrosetta-org-match-serial added-match)
        :core-match ,(mrosetta-org-match-raw added-match)))))
#+END_SRC

**** Updating Matches
Update an existing match as it is edited in its source, or output, environment. Also propagate these changes downstream to all the defined outputs in cases of original match updates, or upstream in cases of output match updates.

Potential updates are confirmed first by comparing integer hashes of match raw values. Although there is a theoretical possibility of a falsely-negative result of change between the hashes, as per Elisp documentation on ~sxhash-equal~, integer-based hash comparison should prove more efficient than manual string comparison.

***** Update Original Match
Update an existing original match as it is edited in its source file. Propagate all the parsed changes downstream to all the outputs in context.

****** Root Expression
Update an existing match based on an updated raw value.

#+NAME: mrosetta-org-expression-root-update-from-source
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-expression-root-update-from-source ((oexpression mrosetta-org-expression-root) possibly-updated-match-plist)
  "If the core match value of the POSSIBLY-UPDATED-MATCH-PLIST is indeed an updated version of a corresponding match in context of the OEXPRESSION Metarosetta root expression configuration object, update the match configuration object and return it. Otherwise return nil."
  (let* ((root-key (slot-value oexpression 'key))
         (mlexpression (slot-value oexpression 'mlexpression))
         (match-root-key (plist-get possibly-updated-match-plist :root-key))
         (match-serial (plist-get possibly-updated-match-plist :match-serial))
         (raw-match (plist-get possibly-updated-match-plist :core-match))
         (existing-match (cdr (assq match-serial (slot-value oexpression 'matches)))))
    ;; Proceed only if the match is in context of the root expression configuration
    (when (eq root-key match-root-key)
      (let ((match-hash (sxhash-equal raw-match)))
        ;; Check if the match has indeed been updated
        (when (not (eq match-hash
                       (mrosetta-org-match-hash existing-match)))
          ;; Match has been updated
          (let ((parsed-match (mrosetta-process mlexpression raw-match)))
            (when (not parsed-match)
              ;; The newly updated match is no longer syntactically compatible
              (error "Match update error: %s is no longer syntactically compatible with its metalanguage expression"
                     (mrosetta-id-serialize-match-identifier :root-key match-root-key
                                                             :match-serial match-serial)))
            ;; Store and process the newly updated match values
            (mrosetta-org-match-raw-set existing-match raw-match)
            (mrosetta-org-match-parsed-set existing-match parsed-match)
            (mrosetta-org-match-hash-set existing-match match-hash)
            (mrosetta-org-match-last-updated-set existing-match (current-time-string))
            (mrosetta-org-match-op-type-set existing-match :downloaded))
          ;; Return the updated match
          existing-match)))))
#+END_SRC

****** Output Expression
Update an existing output match based on an updated original.

#+NAME: mrosetta-org-expression-output-update-from-original
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-expression-output-update-from-original ((oexpression mrosetta-org-expression-output) original-match)
  "Based on the updated values of the provided ORIGINAL-MATCH, update the corresponding output match in context of the OEXPRESSION Metarosetta output expression configuration object and return the updated output match."
  (let* ((mlexpression (slot-value oexpression 'mlexpression))
         (target-type (slot-value oexpression 'target-type))
         (connector (cdr (assq target-type mrosetta-index-connectors)))
         (template (slot-value oexpression 'template))
         (existing-match (cdr (assq (mrosetta-org-match-serial original-match)
                                    (slot-value oexpression 'matches))))
         (target-endpoint (mrosetta-org-match-output-target-endpoint existing-match))
         (target-section (mrosetta-org-match-output-target-section existing-match)))
    ;; Update and process the newly updated values
    (mrosetta-org-match-raw-set existing-match
                                (mrosetta-update mlexpression template (mrosetta-org-match-parsed original-match)))
    (mrosetta-org-match-parsed-set existing-match
                                   (mrosetta-process mlexpression (mrosetta-org-match-raw existing-match)))
    (mrosetta-org-match-hash-set existing-match
                                 (sxhash-equal (mrosetta-org-match-raw existing-match)))
    (mrosetta-org-match-last-updated-set existing-match (current-time-string))
    (mrosetta-org-match-op-type-set existing-match :uploaded)
    ;; Propagate all the updates through the connector
    (mrosetta-out-update connector
                         target-endpoint target-section
                         `(:root-key ,(mrosetta-org-match-root-key existing-match)
                           :match-serial ,(mrosetta-org-match-serial existing-match)
                           :output-key ,(mrosetta-org-match-output-key existing-match)
                           :core-match ,(mrosetta-org-match-raw existing-match)))
    ;; Return the updated match
    existing-match))
#+END_SRC

****** Configuration Set
Update an existing original match from its source file in context of its encompassing configuration set object.

#+NAME: mrosetta-org-config-update-from-source
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-config-update-from-source ((oconfig mrosetta-org-config) possibly-updated-original-match-plist)
  "Based on the possibly updated values of the POSSIBLY-UPDATED-ORIGINAL-MATCH-PLIST, update the corresponding original as well as output match objects in context of the OCONFIG Metarosetta org configuration. If the match is indeed updated, return the updated property list of the original match. Otherwise return nil."
  (let* ((root-oexpression (slot-value oconfig 'root-expression))
         (output-oexpressions (slot-value oconfig 'output-expressions))
         (updated-match (mrosetta-org-expression-root-update-from-source root-oexpression possibly-updated-original-match-plist)))
    ;; Proceed only if original match actually updated
    (when updated-match
      ;; Pass along the updated original match to all the configured output expressions
      (mapc (lambda (output-oexpression-pair)
              (let ((output-oexpression (cdr output-oexpression-pair)))
                (mrosetta-org-expression-output-update-from-original output-oexpression updated-match)))
            output-oexpressions)
      ;; Return the updated original match
      `(:root-key ,(mrosetta-org-match-root-key updated-match)
        :match-serial ,(mrosetta-org-match-serial updated-match)
        :core-match ,(mrosetta-org-match-raw updated-match)))))
#+END_SRC

***** Update Output Match
Update the output match as it is edited in its output file or general endpoint. Propagate all the changes upstream to the original match, as well as any eventual co-existing outputs alongside the one in context.

****** Root Expression
Update an existing original match based on an updated output match.

#+NAME: mrosetta-org-expression-root-update-from-output
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-expression-root-update-from-output ((oexpression mrosetta-org-expression-root) output-match)
  "Based on the updated values of the provided OUTPUT-MATCH, update the corresponding original match in context of the OEXPRESSION Metarosetta root expression configuration object and return the updated original match."
  (let* ((mlexpression (slot-value oexpression 'mlexpression))
         (existing-match (cdr (assq (mrosetta-org-match-serial output-match)
                                    (slot-value oexpression 'matches))))
         (source-filename (slot-value existing-match 'source-filename)))
    ;; Update and process the newly updated values
    (mrosetta-org-match-raw-set existing-match
                                (mrosetta-update mlexpression
                                                 (mrosetta-org-match-raw existing-match)
                                                 (mrosetta-org-match-parsed output-match)))
    (mrosetta-org-match-parsed-set existing-match
                                   (mrosetta-process mlexpression (mrosetta-org-match-raw existing-match)))
    (mrosetta-org-match-hash-set existing-match
                                 (sxhash-equal (mrosetta-org-match-raw existing-match)))
    (mrosetta-org-match-last-updated-set existing-match (current-time-string))
    (mrosetta-org-match-op-type-set existing-match :uploaded)
    ;; Propagate the updates to the source file itself
    (mrosetta-source-update source-filename
                            `(:root-key ,(mrosetta-org-match-root-key existing-match)
                              :match-serial ,(mrosetta-org-match-serial existing-match)
                              :core-match ,(mrosetta-org-match-raw existing-match)))
    ;; Return the updated match
    existing-match))
#+END_SRC

****** Output Expression
Update an existing output match based on a possibly updated raw value.

#+NAME: mrosetta-org-expression-output-update-from-endpoint
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-expression-output-update-from-endpoint ((oexpression mrosetta-org-expression-output) possibly-updated-match-plist)
  "If the core match value of the POSSIBLY-UPDATED-MATCH-PLIST is indeed an updated version of a corresponding match in context of the OEXPRESSION Metarosetta output expression configuration object, update the match configuration object and return it. Otherwise return nil."
  (let* ((output-key (slot-value oexpression 'key))
         (mlexpression (slot-value oexpression 'mlexpression))
         (match-root-key (plist-get possibly-updated-match-plist :root-key))
         (match-output-key (plist-get possibly-updated-match-plist :output-key))
         (match-serial (plist-get possibly-updated-match-plist :match-serial))
         (raw-match (plist-get possibly-updated-match-plist :core-match))
         (existing-match (cdr (assq match-serial (slot-value oexpression 'matches)))))
    ;; Proceed only if the match is in context of the output expression configuration
    (when (eq output-key match-output-key)
      (let ((match-hash (sxhash-equal raw-match)))
        ;; Check if the hash has been changed
        (when (not (eq match-hash
                       (mrosetta-org-match-hash existing-match)))
          ;; Match has indeed been updated
          (let ((parsed-match (mrosetta-process mlexpression raw-match)))
            (when (not parsed-match)
              (error "Output match update error: %s is no longer syntactically compatible with its metalanguage expression"
                     (mrosetta-id-serialize-match-identifier :root-key match-root-key
                                                             :match-serial match-serial
                                                             :output-key match-output-key)))
            ;; Store and process the newly updated match values
            (mrosetta-org-match-raw-set existing-match raw-match)
            (mrosetta-org-match-parsed-set existing-match parsed-match)
            (mrosetta-org-match-hash-set existing-match match-hash)
            (mrosetta-org-match-last-updated-set existing-match (current-time-string))
            (mrosetta-org-match-op-type-set existing-match :downloaded))
          ;; Return the updated output match
          existing-match)))))
#+END_SRC

****** Configuration Set
Update an existing output match from its endpoint in context of its encompassing configuration set object.

#+NAME: mrosetta-org-config-update-from-endpoint
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-org-config-update-from-endpoint ((oconfig mrosetta-org-config) possibly-updated-output-match-plist)
  "Based on the possibly updated values of the POSSIBLY-UPDATED-OUTPUT-MATCH-PLIST, update the corresponding output match in addition to its upstream original, as well as all the other eventually co-existing output match objects in context of the OCONFIG Metarosetta org configuration. If the match is indeed updated, return the updated property list of the output match. Othwerwise return nil."
  (let* ((output-key (plist-get possibly-updated-output-match-plist :output-key))
         (root-oexpression (slot-value oconfig 'root-expression))
         (output-oexpressions (slot-value oconfig 'output-expressions))
         (contextual-output-oexpression (cdr (assq output-key output-oexpressions)))
         (updated-output-match (mrosetta-org-expression-output-update-from-endpoint contextual-output-oexpression possibly-updated-output-match-plist)))
    ;; Proceed only if the output match in context is actually updated
    (when updated-output-match
      ;; First update the original match
      (let ((updated-original-match (mrosetta-org-expression-root-update-from-output root-oexpression updated-output-match)))
        ;; Now pass along the updated original match to any configured output expressions other than the one in context
        (mapc (lambda (output-oexpression-pair)
                (let ((output-oexpression-key (car output-oexpression-pair))
                      (output-oexpression (cdr output-oexpression-pair)))
                  (when (not (eq output-oexpression-key output-key))
                    (mrosetta-org-expression-output-update-from-original output-oexpression updated-original-match))))
              output-oexpressions))
      ;; Return the updated output match in context
      `(:root-key ,(mrosetta-org-match-root-key updated-output-match)
        :match-serial ,(mrosetta-org-match-serial updated-output-match)
        :output-key ,(mrosetta-org-match-output-key updated-output-match)
        :core-match ,(mrosetta-org-match-raw updated-output-match)))))
#+END_SRC

** Original Match Source Handling
This section covers functions enabling original match retrievals and updates within its native source environment. Metarosetta is designed to support matching and synchronization of metalanguage matches from both code and prose.

*** Read Original Matches
From a given source file, find and return all of the Metarosetta-tracked matches.

#+NAME: mrosetta-source-read
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-source-read (source-file number-of-matches)
  "From the SOURCE-FILE, find and return NUMBER-OF-MATCHES of the tracked Metarosetta metalanguage match instances in their full form."
  (let ((match-id-re (mrosetta-id-generate-re))
        (matches '()))
    (with-temp-buffer
      (insert-file-contents source-file)
      ;; Start search from the beginning
      (goto-char (point-min))
      ;; Search for the specified number of matches
      (while (> number-of-matches 0)
        (save-match-data
          ;; Find the next match by searching for the identifier pattern
          (re-search-forward (concat match-id-re "$"))
          ;; Extract the raw match
          (let ((raw-match (string-trim (buffer-substring-no-properties (line-beginning-position) (line-end-position)))))
            ;; Push the parsed match to the resulting list
            (push (mrosetta-id-parse-match raw-match)
                  matches)))
        ;; Decrease the number of matches left to read
        (setq number-of-matches (1- number-of-matches))))
    ;; Return the matches
    matches))
#+END_SRC

*** Update Original Match
Update the provided original match in its original source file.

#+NAME: mrosetta-source-update
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-source-update (source-file match-plist)
  "Given the original :core-match, along with its :root-key and :match-serial from within MATCH-PLIST, update the match in-place within its SOURCE-FILE."
  (let ((match-identifier (apply 'mrosetta-id-serialize-match-identifier match-plist))
        (raw-match (apply 'mrosetta-id-serialize-match match-plist)))
    (with-temp-file source-file
      (insert-file-contents source-file)
      ;; Star search from the beginning
      (goto-char (point-min))
      ;; Find the line of the match in context
      (re-search-forward (concat (regexp-quote match-identifier) "$"))
      ;; Place point at correct indentation
      (beginning-of-line)
      (re-search-forward "^[[:blank:]]*"
                         ;; Limit search to line at point
                         (line-end-position)
                         ;; In case of no indentation just move on
                         t)
      ;; Delete the current match string
      (delete-region (point) (line-end-position))
      ;; Insert the new match string
      (insert raw-match))
    ;; Return affirmatively
    t))
#+END_SRC

** Output Connectors
For Metarosetta to be at all useful, the parsed and transpiled matches ought to be put out in a desired format, to a specific file or endpoint, for humans or machines to consume.

This section contains, a hopefully ever-growing, list of connectors enabling such output.

*** Connector Interface
The basic functionality each connector should have.

#+NAME: mrosetta-out
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-out ()
  ((syntax-type
    :initarg :syntax-type
    :type symbol
    :documentation "A symbol defining the syntax type the output connector in context conforms to."
    :reader mrosetta-out-syntax-type))
  "The foundational output connector object all Metarosetta connectors should extend on."
  :abstract t)
#+END_SRC

**** Add Match
Add an output match to a specified target via the connector.

#+NAME: mrosetta-out-add
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defgeneric mrosetta-out-add ((connector mrosetta-out) endpoint section output-match-plist)
  "Via the output CONNECTOR, add the output match defined by the OUTPUT-MATCH-PLIST to the provided ENDPOINT within the specified SECTION. If successful, return the endpoint where added. In cases of symlinks or link forwarding setups, this can vary from ENDPOINT.")
#+END_SRC

**** Read Match
Read a given amount of output matches from a specified target via the connector.

#+NAME: mrosetta-out-read
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defgeneric mrosetta-out-read ((connector mrosetta-out) endpoint number-of-matches)
  "Via the output CONNECTOR, read NUMBER-OF-MATCHES from the specified ENDPOINT across all sections.")
#+END_SRC

**** Update Match
Update an existing match in a specified target via the connector.

#+NAME: mrosetta-out-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defgeneric mrosetta-out-update ((connector mrosetta-out) endpoint section output-match-plist)
  "Via the output CONNECTOR, update the output match defined by the OUTPUT-MATCH-PLIST located in the specified ENDPOINT within a specific SECTION. If successful, return the endpoint where updated. In cases of symlinks or link forwarding setups, this can vary from ENDPOINT.")
#+END_SRC

*** Structured Text Output Connectors
Connectors for output to structured textual file formats, like Markdown or org-mode.

Since most such formats follow common foundational patterns in basic structuring, but differ only in syntactic details such as heading or item marks, it's sensible to implement a general connector with agnostic functionality for all such formats.

#+NAME: mrosetta-out-to-structured-text
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-out-to-structured-text (mrosetta-out)
  ((heading-mark
    :initarg :heading-mark
    :type string
    :documentation "A string representing the heading mark in a given structure syntax.")
   (item-mark
    :initarg :item-mark
    :type string
    :documentation "A string representing the list item mark in a given structure syntax."))
  "A Metarosetta output connector object which serves as an agnostic base for various output file connectors dealing with structured text, such as Markdown or org-mode.")
#+END_SRC

**** Output Functions
This section contains the syntax-agnostic implementation of all connector methods pertaining to commonly structured file formats, where matches are put out as unordered list items within a section defined by a given heading path.

***** Helper Functions
Functions dealing with common actions shared across all connector methods.

****** Navigate to Section
Move point into the target section along the provided section path, in context of a current buffer.

#+NAME: mrosetta-out-to-structured-text-goto-section
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-out-to-structured-text-goto-section ((connector mrosetta-out-to-structured-text) section)
  "The structured text output CONNECTOR's helper method to set the point, in context of the current buffer, to the beginning of the target section defined by the SECTION path. Return a cons cell containing the starting and ending points, respectively."
  (let ((heading-mark (slot-value connector 'heading-mark))
        section-heading-mark
        (headings (split-string section "/")))
    ;; Assuming the context of a current buffer, start search from the beginning
    (goto-char (point-min))
    ;; Navigate to targeted section and get the section's heading mark
    (setq section-heading-mark
          (cl-reduce (lambda (last-heading-mark heading)
                       ;; Compile the current heading mark, based on heading depth
                       (let* ((current-heading-mark (concat last-heading-mark heading-mark))
                              (full-heading (concat current-heading-mark " " heading)))
                         ;; All sections along the path are expected to be in place, i.e. none are implicitly created
                         (search-forward full-heading)
                         ;; Push the current heading mark to the next iteration
                         current-heading-mark))
                     headings
                     :initial-value ""))
    ;; Recursively get the end position of the section at point, and return both points
    `(,(point) . ,(cl-labels ((section-end-position (current-heading-mark)
                                                    (when (> (length current-heading-mark) 0)
                                                      (save-excursion
                                                        (let ((parent-end-position (section-end-position (substring current-heading-mark 0 -1))))
                                                          (or (re-search-forward (concat "^[[:blank:]]*"
                                                                                         (regexp-quote current-heading-mark))
                                                                                 parent-end-position
                                                                                 t)
                                                              parent-end-position))))))
                    (section-end-position section-heading-mark)))))
#+END_SRC

***** Add Match
Append a new transpiled match within the heading-specified section of the provided file.

#+NAME: mrosetta-out-to-structured-text-add
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-out-add ((connector mrosetta-out-to-structured-text) endpoint section output-match-plist)
  "Via the structured text output CONNECTOR, append the output match defined by the OUTPUT-MATCH-PLIST to the ENDPOINT file within the specified SECTION. If successful, return the actual endpoint where added. In cases of symlinks, this can vary from ENDPOINT."
  (let* (section-bounds
         (item-mark (slot-value connector 'item-mark))
         (full-item (concat item-mark " " (apply 'mrosetta-id-serialize-match output-match-plist))))
    ;; Follow through the symlink, if such, and get the absolute file name
    (setq endpoint (file-truename endpoint))
    (with-temp-file endpoint
      (insert-file-contents endpoint)
      ;; Navigate to section in context, and get section bounds
      (setq section-bounds (mrosetta-out-to-structured-text-goto-section connector section))
      ;; Navigate to the end of the list within the target section
      (while (search-forward item-mark
                             ;; Limit the search to the encompassing section only
                             (cdr section-bounds)
                             ;; When search eventually fails, just return nil and exit the loop
                             t))
      ;; Insert the new list item after the last one
      (end-of-line)
      (newline-and-indent)
      (insert full-item))
    ;; Return with the endpoint file name
    endpoint))
#+END_SRC

***** Read Match
Read a given amount of matches from within a given section of the output file.

#+NAME: mrosetta-out-to-structured-text-read
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-out-read ((connector mrosetta-out-to-structured-text) endpoint number-of-matches)
  "Via the structured text output CONNECTOR, read NUMBER-OF-MATCHES from the specified ENDPOINT across all sections."
  (let ((item-mark (slot-value connector 'item-mark))
        (match-id-re (mrosetta-id-generate-re))
        (matches '()))
    (with-temp-buffer
      (insert-file-contents endpoint)
      ;; Start search from the beginning
      (goto-char (point-min))
      ;; Search for the specified number of matches
      (while (> number-of-matches 0)
        (save-match-data
          ;; Find the next match line by searching for the identifier pattern
          (re-search-forward (concat match-id-re "$"))
          ;; Set point at the beginning of the actual match
          (beginning-of-line)
          (search-forward (concat item-mark " ")
                          (line-end-position))
          ;; Extract the raw match
          (let ((raw-match (buffer-substring-no-properties (point) (line-end-position))))
            ;; Push the parsed match to the resulting list
            (push (mrosetta-id-parse-match raw-match)
                  matches)))
        ;; Decrease the number of matches left to read
        (setq number-of-matches (1- number-of-matches))))
    ;; Return the matches
    matches))
#+END_SRC

***** Update Match
Update an output match within a given section of the output file defined by a specific match id.

#+NAME: mrosetta-out-to-structured-text-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-out-update ((connector mrosetta-out-to-structured-text) endpoint section output-match-plist)
  "Via the structured text output CONNECTOR, update the match defined by the OUTPUT-MATCH-PLIST located in the specified ENDPOINT within a specific SECTION. If successful, return the actual endpoint where added. In cases of symlinks, this can vary from ENDPOINT."
  (let (section-bounds
        (item-mark (slot-value connector 'item-mark))
        (match-identifier (apply 'mrosetta-id-serialize-match-identifier output-match-plist))
        (raw-match (apply 'mrosetta-id-serialize-match output-match-plist)))
    ;; Follow through the symlink, if such, and get the absolute file name
    (setq endpoint (file-truename endpoint))
    (with-temp-file endpoint
      (insert-file-contents endpoint)
      ;; Navigate to section in context, and get section bounds
      (setq section-bounds (mrosetta-out-to-structured-text-goto-section connector section))
      ;; Search for the item line containing the match ID
      (re-search-forward (concat (regexp-quote match-identifier) "$")
                      ;; Limit the search to the encompassing section only
                      (cdr section-bounds))
      ;; Set point at the beginning of the item's line
      (beginning-of-line)
      ;; Move past the item mark
      (search-forward (concat item-mark " ")
                      (line-end-position))
      ;; Delete the current item
      (delete-region (point) (line-end-position))
      ;; Insert the updated match at point
      (insert raw-match))
    ;; Return with the endpoint file name
    endpoint))
#+END_SRC

** Setup
The functions initializing all the configuration required for package workflows.

*** Register Connectors
A function enabling the registration of a specific output connector with its designated syntax type.

#+NAME: mrosetta-register-connectors
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-register-connectors (&rest connectors)
  "Register one or more Metarosetta output CONNECTORS."
  (setq mrosetta-index-connectors
        (mapcar (lambda (connector)
                  ;; Check if the connector is of the proper class
                  (when (not (object-of-class-p connector 'mrosetta-out))
                    (error "Invalid output connector error: All output connectors must inherit from the mrosetta-out class"))
                  ;; Create an alist element for the connector indexed by its type symbol
                  `(,(mrosetta-out-syntax-type connector) . ,connector))
                connectors)))

#+END_SRC

*** Load Configuration
Load all configuration org files from a given folder.

#+NAME: mrosetta-load
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-load (configuration-directory)
  "Load all the Metarosetta org configuration files located within the provided CONFIGURATION-DIRECTORY."
  ;; First set the configuration directory
  (setq mrosetta-configuration-directory configuration-directory)
  ;; Load, parse and initialize all Metarosetta configurations
  (let ((configuration-files (directory-files configuration-directory
                                              ;; Get the full path
                                              'full
                                              ;; Return only org files
                                              ".+\\.org$")))
    ;; Parse all configuration files and add them to the global index by their respective keys
    (setq mrosetta-index-configurations
          (mapcar (lambda (configuration-file)
                    (with-temp-buffer
                      (insert-file-contents configuration-file)
                      (let ((oconfig (mrosetta-org-parse (mrosetta-org-config :source-filename configuration-file)
                                                         (org-ml-parse-subtrees 'all))))
                        ;; Repport successful load
                        (message "Metarosetta successfully loaded %s" configuration-file)
                        ;; Return configuration pair
                        `(,(mrosetta-org-config-key oconfig) . ,oconfig))))
                  configuration-files))))
#+END_SRC

*** Save Configuration
Save all the configuration org files to the configuration directory.

#+NAME: mrosetta-save
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-save ()
  "Save all the indexed Metarosetta org configuration files to the set configuration directory."
  ;; Save each configuration
  (mapc (lambda (configuration-pair)
          (let* ((configuration (cdr configuration-pair))
                 (configuration-file (mrosetta-org-config-source-filename configuration)))
            (with-temp-file configuration-file
              (insert-file-contents configuration-file)
              ;; Skip over any non-heading data
              (goto-char (point-min))
              (re-search-forward "^*")
              (goto-char (1- (point)))
              ;; Delete any currently saved configuration data
              (delete-region (point) (point-max))
              ;; Insert the serialized org data
              (insert (string-join (mapcar 'org-ml-to-string
                                           (mrosetta-org-serialize configuration))
                                   ;; Join all headline elements directly
                                   "")))
            ;; Report successful save
            (message "Metarosetta successfully saved %s" configuration-file)))
        mrosetta-index-configurations))
#+END_SRC

** User Interaction
This section contains all the user-facing functions enabling the use of metalanguage expressions for conventional text matching, parsing, and of course transpiling and two-way synchronization.

*** Match Line at Point
Try to match the line at point against any of the configured metalanguage expressions. Successful matches are added to the corresponding org configuration and are tracked for changes and two-way synchronization, according to the respectively defined output expressions and their connectors.

#+NAME: mrosetta-match
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-match ()
  "Try to add the text from line at point to any compatible Metarosetta configuration currently active and tracking."
  (interactive)
  (let ((source-filename (buffer-file-name)))
    ;; If the current buffer is visiting a valid file, grab the current line's text to match
    (when source-filename
      (let ((text-to-match (string-trim (buffer-substring-no-properties (line-beginning-position) (line-end-position)))))
        ;; Only proceed if there's text to actually process
        (when (> (length text-to-match) 0)
          (let ((configurations mrosetta-index-configurations))
            ;; Iterate over all indexed configurations until one matches
            (while (and configurations
                        (not (let* ((configuration (cdar configurations))
                                    ;; Try to match the current configuration
                                    (match-plist (mrosetta-org-config-add configuration text-to-match source-filename)))
                               ;; If matched, update the text at point
                               (when match-plist
                                 ;; Place point at correct indentation
                                 (beginning-of-line)
                                 (re-search-forward "^[[:blank:]]*"
                                                    ;; Limit seatch to line at point
                                                    (line-end-position)
                                                    ;; In case of no indentation, move on
                                                    t)
                                 ;; Delete the current text
                                 (delete-region (point) (line-end-position))
                                 ;; Insert the full match string
                                 (insert (apply 'mrosetta-id-serialize-match match-plist))
                                 ;; Report the successful match to the user
                                 (message "Metarosetta successfully matched text at point.")
                                 ;; Explicitly return affirmatively
                                 t))))
              ;; Move on to the next configuration
              (setq configurations (cdr configurations)))
            ;; Report if no match found
            (when (not configurations)
              (message "Metarosetta failed to match text at point."))))))))
#+END_SRC

*** Synchronize Matches in Current Buffer
Grab all the matches from current buffer, if any, and synchronize for potential updates.

This function is best utilized when hooked up to the ~after-save-hook~, so any potential matches are automatically synchronized on each save.

#+NAME: mrosetta-sync
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-sync ()
  "Synchronize all the possibly updated Metarosetta match instances within the current buffer."
  (interactive)
  (let ((source-filename (buffer-file-name)))
    ;; If the current buffer is visiting a valid file, check the reverse index for tracked matches
    (when source-filename
      (let ((source-index-item (gethash source-filename
                                        mrosetta-index-sources)))
        ;; Only proceed if file in context is indexed
        (when source-index-item
          (let* ((source-type (car source-index-item))
                 (number-of-matches (cdr source-index-item))
                 ;; Fetch all the matches depending on source type
                 (matches (if (eq source-type :root)
                              ;; Fetch source matches
                              (mrosetta-source-read source-filename number-of-matches)
                            ;; Fetch output matches using the corresponding connector
                            (let ((connector (cdr (assq source-type mrosetta-index-connectors))))
                              (mrosetta-out-read connector source-filename number-of-matches)))))
            ;; Iterate over each match and update configuration if needed
            (mapc (lambda (match-plist)
                    (let* ((configuration (cdr (assq (plist-get match-plist :root-key)
                                                     mrosetta-index-configurations)))
                           ;; Depending on match type, update downstream or upstream
                           (updated-match-plist (if (not (plist-get match-plist :output-key))
                                                    ;; An original match, update downstream
                                                    (mrosetta-org-config-update-from-source configuration match-plist)
                                                  ;; An output match, update upstream
                                                  (mrosetta-org-config-update-from-endpoint configuration match-plist))))
                      ;; Report if the match is indeed updated
                      (when updated-match-plist
                        (message "Metarosetta successfully updated match %s."
                                 (apply 'mrosetta-id-serialize-match-identifier updated-match-plist)))))
                  matches)))))))
#+END_SRC

*** Go to Original Match
With point set on an output match line, jump to the original match in its source environment.

#+NAME: mrosetta-jump
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-jump ()
  "With current buffer visiting an output endpoint, and current point set on a valid output match, jump to the original match at its source file. If a buffer visiting the source exists, switch there, otherwise create a new buffer."
  (interactive)
  (let ((match-id-plist (save-excursion
                          ;; Start identifier search at the beginning of the line
                          (beginning-of-line)
                          (save-match-data
                            ;; Search for the identifier pattern and parse it
                            (and (re-search-forward (concat (mrosetta-id-generate-re) "$")
                                                    ;; Limit search to current line only
                                                    (line-end-position)
                                                    ;; Return nil if no identifier found
                                                    t)
                                 ;; Identifier pattern found, parse it
                                 (mrosetta-id-parse-match-identifier (match-string 0)))))))
    ;; If match identifier found, look up the source file name
    (when match-id-plist
      (let* ((configuration (cdr (assq (plist-get match-id-plist :root-key)
                                       mrosetta-index-configurations)))
             (source-filename (mrosetta-org-config-original-match-source-filename configuration
                                                                                  (plist-get match-id-plist :match-serial))))
        ;; Jump to source filename buffer
        (find-file source-filename)
        ;; Set point to original match in context
        (goto-char (point-min))
        (let ((source-match-id (mrosetta-id-serialize-match-identifier :root-key (plist-get match-id-plist :root-key)
                                                                       :match-serial (plist-get match-id-plist :match-serial))))
          (save-match-data
            (re-search-forward (concat (regexp-quote source-match-id) "$"))))))))
#+END_SRC

* Registration
#+NAME: registration
#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'metarosetta)
#+END_SRC
* Footer
#+NAME: footer
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el ends here
#+END_SRC
