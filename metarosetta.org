#+TITLE: Project Metarosetta Emacs Package

* Header
** Name and Definition
#+NAME: title
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el --- A semantically-driven interconnectivity framework -*- lexical-binding: t -*-
#+END_SRC
** Signature
#+NAME: signature
#+BEGIN_SRC emacs-lisp :tangle yes
;; Author: Bruno Tedeschi <me@btedeschi.com>
#+END_SRC
** Summary
#+NAME: summary
#+BEGIN_SRC text
This package adds Metarosetta expression language support to Org-mode.

It enables in-context definition of semantic protocols, within Org-mode, which automatically translate human-input text into a machine-digestible API-compatible structure particular to a given context.

For details and language specification, please refer to the original package documentation and source org file.
#+END_SRC

#+NAME: commentary
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
;;; Commentary:

;; <<summary>>
#+END_SRC
** Code Marker
#+NAME: code-marker
#+BEGIN_SRC emacs-lisp :tangle yes
;;; Code:
#+END_SRC
* Dependencies
#+NAME: dependencies
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'eieio)
(require 'eieio-base)
(require 'url)
(require 'url-http)
(require 'web-server)
(require 'org)
#+END_SRC
* Helpers
Helper objects and functions.

** The Keychain
Key management is encapsulated within a simple keychain class which holds all generated keys and is of course capable of generating keys unique to a single instance of the keychain.

*** Class Definition
The class itself is designed as a no-argument constructor as the key generator is automatically initialized upon creation.

#+NAME: mrosetta-keychain
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-keychain ()
  ((lastkey
    :initarg :lastkey
    :initform '0
    :type number
    :documentation "The last key generated and assigned within the context of a single keychain instance."
    :reader mrosetta-keychain-lastkey))
  "A key generator helper class.")
#+END_SRC
*** Behavior
This section covers all defined behavior for the keychain class.

**** Generate Key
Register for a new key with a particular keychain instance.

#+NAME: mrosetta-keychain-generate-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-keychain-generate-key ((keychain mrosetta-keychain))
  "Generate a new key within a provided KEYCHAIN."
  (let ((key (+ 1 (slot-value keychain 'lastkey))))
    (setf (slot-value keychain 'lastkey) key)))
#+END_SRC
* The Metalanguage
The metalanguage specification and parser.

** The Expression Object
An entity defining a particular expression. Using the metalanguage syntax as input, it constructs all underlying logic to parse textual input and structures to map semantic information to machine-readable output.

Designed as an inherently recursive fractal object.

*** Properties
All the properties contained within the expression object. These are of course defined as slots.

**** Definition
The metalanguage-specified definition of the expression in context.

This is stored as a quoted lisp list.

#+NAME: mrosetta-mlexpression-mldefinition
#+BEGIN_SRC emacs-lisp
(mldefinition
 :initarg :mldefinition
 :type list
 :documentation "The metalanguage-specified definition of the expression in context."
 :reader mrosetta-mlexpression-mldefinition)
#+END_SRC
**** Expression Type
Specifies the exact type of the expression in context.

The property itself is a ~symbol~ indicating the type of the expression.

#+NAME: mrosetta-mlexpression-extype
#+BEGIN_SRC emacs-lisp
(extype
 :type symbol
 :documentation "A symbol specifying the type of the encompassing expression instance. Can be either a :literal, :match or :fractal."
 :reader mrosetta-mlexpression-extype)
#+END_SRC

The following are the possible expression types:

***** Literal Quote
Denotes the simplest expression defining statically quoted text which matches itself within any passed input.

The quote expression type is specified as a ~:literal~.
***** Match
An expression matching semantically significant information. These are either words or paragraphs of captured text.

A match expression is specified as a ~:match~.
***** Fractal
An expression matching a sequence of its nested child expressions.

A fractal expression is specified as a ~:fractal~.
**** Fractals
All the fractal elements existing within the encompassing expression instance. Only ~:fractal~ instances can contain sub-expressions themselves.

The property itself is a list of ~mrosetta-expression~ instances.

#+NAME: mrosetta-mlexpression-fractals
#+BEGIN_SRC emacs-lisp
(fractals
 :initform '()
 :type list
 :documentation "A list of mrosetta-expression instances contained within the encompassing expression instance."
 :reader mrosetta-mlexpression-fractals)
#+END_SRC
**** Regular Expression Properties
This section contains all the properties pertaining to the encompassing expression's regex, its group keys and resulting matches of the current input, if processed.

***** Regex Keychain
In order to properly parse and distribute regex matches across the fractal expression tree, each expression object needs to have a number identifier unique to the encompassing tree.

To manage this, each tree has a single /keychain/ instance shared across all expression objects within a single fractal tree.

#+NAME: mrosetta-mlexpression-rkeychain
#+BEGIN_SRC emacs-lisp
(rkeychain
 :initarg :rkeychain
 :initform (mrosetta-keychain)
 :type mrosetta-keychain
 :documentation "The regex keychain instance managing keys for the encompassing expression tree."
 :reader mrosetta-mlexpression-rkeychain)
#+END_SRC

***** Regular Expression
The compiled regular expression of the metalanguage expression in context.

This is the regex used under the hood when parsing through human-readable input.

#+NAME: mrosetta-mlexpression-regex
#+BEGIN_SRC emacs-lisp
(regex
 :type string
 :documentation "The compiled regular expression of the expression in context."
 :reader mrosetta-mlexpression-regex)
#+END_SRC

In addition, each match-extracting regular expression has a corresponding group key by which the respective match is extracted.

#+NAME: mrosetta-mlexpression-regex-key
#+BEGIN_SRC emacs-lisp
(regex-key
 :type number
 :documentation "The regex matching group key for the encompassing expression instance."
 :reader mrosetta-mlexpression-regex-key)
#+END_SRC

Since the metalanguage supports plural matches of enumerable text clauses, an additional regular expression is required in order to capture a single instance of such clauses. In cases of single-matching expressions, ~regex~ is equivalent to ~rinstance~.

#+NAME: mrosetta-mlexpression-rinstance
#+BEGIN_SRC emacs-lisp
(rinstance
 :type string
 :documentation "The compiled regular expression matching a single instance of a possibly plural-matching expression."
 :reader mrosetta-mlexpression-rinstance)
#+END_SRC

#+NAME: mrosetta-mlexpression-rinstance-key
#+BEGIN_SRC emacs-lisp
(rinstance-key
 :type number
 :documentation "The regex group key for matching a single instance of a possibly plural-matching metalanguage expression in context."
 :reader mrosetta-mlexpression-rinstance-key)
#+END_SRC

****** Base
The foundational element from which the matching regular expression is constructed.

#+NAME: mrosetta-mlexpression-rbase
#+BEGIN_SRC emacs-lisp
(rbase
 :type string
 :documentation "The regular expression used as a foundational base in compilation of the match-extracting regular expression."
 :reader mrosetta-mlexpression-rbase)
#+END_SRC
****** Match
The regular expression of the match itself.

#+NAME: mrosetta-mlexpression-rmatch
#+BEGIN_SRC emacs-lisp
(rmatch
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression of the encompassing expression's semantic match."
 :reader mrosetta-mlexpression-rmatch)
#+END_SRC

The regex is paired with its group key used for match extraction.

#+NAME: mrosetta-mlexpression-rmatch-key
#+BEGIN_SRC emacs-lisp
(rmatch-key
 :initform 'nil
 :type (or null number)
 :documentation "The regex group key for the encompassing expression's output value match."
 :reader mrosetta-mlexpression-rmatch-key)
#+END_SRC
****** Prefix
The regular expression used for matching a specified prefix of the expression in context, if any.

#+NAME: mrosetta-mlexpression-rprefix
#+BEGIN_SRC emacs-lisp
(rprefix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified prefix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-mlexpression-rprefix)
#+END_SRC
****** Suffix
The regular expression used for matching a specified suffix of the expression in context, if any.

#+NAME: mrosetta-mlexpression-rsuffix
#+BEGIN_SRC emacs-lisp
(rsuffix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified suffix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-mlexpression-rsuffix)
#+END_SRC
****** Regex Boundaries
Regular expressions used for regex-specific boundaries around the match.

******* Left Boundary
The regular expression used for defining the left boundary of the match.

#+NAME: mrosetta-mlexpression-left-rboundary
#+BEGIN_SRC emacs-lisp
(left-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The left regex-specific boundary defining the beginning of the match."
 :reader mrosetta-mlexpression-left-rboundary)
#+END_SRC
******* Right Boundary
The regular expression used for defining the right boundary of the match.

#+NAME: mrosetta-mlexpression-right-rboundary
#+BEGIN_SRC emacs-lisp
(right-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The right regex-specific boundary defining the end of the match."
 :reader mrosetta-mlexpression-right-rboundary)
#+END_SRC
****** Surrounding Buffers
Regular expressions used for matching buffer characters surrounding the match.

By default, these are /whitespace/ characters between words and used purely for original text reconstruction with updated semantics.

#+NAME: mrosetta-mlexpression-rbuffer
#+BEGIN_SRC emacs-lisp
(rbuffer
 :initform "[[:blank:]]*"
 :type string
 :documentation "The regular expression matching buffer characters surrounding the encompassing expression."
 :reader mrosetta-mlexpression-rbuffer)
#+END_SRC

******* Left Buffer
The regular expression group key for the left buffer.

#+NAME: mrosetta-mlexpression-left-rbuffer-key
#+BEGIN_SRC emacs-lisp
(left-rbuffer-key
 :type number
 :documentation "The regex group key for the encompassing expression's left buffer match."
 :reader mrosetta-mlexpression-left-rbuffer-key)
#+END_SRC
******* Right Buffer
The regular expression group key for the right buffer.

#+NAME: mrosetta-mlexpression-right-rbuffer-key
#+BEGIN_SRC emacs-lisp
(right-rbuffer-key
 :type number
 :documentation "The regex group key for the encompassing expression's right buffer match."
 :reader mrosetta-mlexpression-right-rbuffer-key)
#+END_SRC
**** Key
The property key to which the expression output value is assigned, if the expression itself is denoted as such.

#+NAME: mrosetta-mlexpression-key
#+BEGIN_SRC emacs-lisp
(key
 :initform 'nil
 :type (or null symbol)
 :documentation "The property key to which the expression output value is assigned, if any. Either a string or nil."
 :reader mrosetta-mlexpression-key)
#+END_SRC
**** Specifier Properties
All specifier parameters defined for the encompassing expression instance.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-mlexpression-is-uppercase
#+BEGIN_SRC emacs-lisp
(is-uppercase
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only uppercase words. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-uppercase)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-mlexpression-is-capitalized
#+BEGIN_SRC emacs-lisp
(is-capitalized
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only capitalized words. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-capitalized)
#+END_SRC
***** Boundary Properties
Specifies whether the match of the encompassing expression has static left or right boundaries.

****** Left Boundary
Specifies a statically set match prefix, if the expression defines one.

#+NAME: mrosetta-mlexpression-match-prefix
#+BEGIN_SRC emacs-lisp
(match-prefix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the prefix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-prefix)
#+END_SRC
****** Right Boundary
Specifies a statically set match suffix, if the expression defines one.

#+NAME: mrosetta-mlexpression-match-suffix
#+BEGIN_SRC emacs-lisp
(match-suffix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the suffix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-suffix)
#+END_SRC
***** Content
Match only words containing specific characters or substrings.

#+NAME: mrosetta-mlexpression-match-substring
#+BEGIN_SRC emacs-lisp
(match-substring
 :initform 'nil
 :type (or null string)
 :documentation "Specifies a specific substring all possible expression matches should contain, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-substring)
#+END_SRC
***** Literal
Match only and exactly the literal text specified here.

This slot is only used in ~:literal~ expressions.

#+NAME: mrosetta-mlexpression-match-literal
#+BEGIN_SRC emacs-lisp
(match-literal
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the literal string that the expression maches exclusively. Either a string or nill."
 :reader mrosetta-mlexpression-match-literal)
#+END_SRC
***** Contextual
Elastically match a region of text depending on neighboring elements.

This slot is only used in ~paragraph~ ~:match~ expressions since paragraphs match any and all text, either based on specific criteria, such as explicit boundaries, or on neighboring matches which act as contextual criteria.

#+NAME: mrosetta-mlexpression-is-contextual
#+BEGIN_SRC emacs-lisp
(is-contextual
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is matched elastically depending on neighboring elements. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-contextual)
#+END_SRC
**** Modifier
Modifiers are useful when matched text needs to be formatted and /normalized/ before being structured within the machine-digestible output.

A modifier property is defined as a symbol referencing a stored function capable of a particular modification, like ~upcase~ for uppercasing the entirety of the output, or ~downcase~ for lowercasing.

#+NAME: mrosetta-mlexpression-modifier
#+BEGIN_SRC emacs-lisp
(modifier
 :initform 'nil
 :type (or null symbol)
 :documentation "Specifies a symbol referencing a stored modifier function, if any. Either a symbol or nil."
 :reader mrosetta-mlexpression-modifier)
#+END_SRC
**** Optionality
Specifies whether the entire expression and its fractals within (if any) are optional in presence.

#+NAME: mrosetta-mlexpression-is-optional
#+BEGIN_SRC emacs-lisp
(is-optional
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is optional to match within input text. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-optional)
#+END_SRC
**** Ignorables
Specifies whether the encompassing expression should be disregarded in structured output. Ignorable expressions are matched but never included in structured semantic output.

#+NAME: mrosetta-mlexpression-should-ignore
#+BEGIN_SRC emacs-lisp
(should-ignore
 :initform 'nil
 :documentation "Specifies whether the encompassing expression should be matched but disregarded in output. Either non-nil or nil."
 :reader mrosetta-mlexpression-should-ignore)
#+END_SRC
**** Plurality
If the expression defines a plural match, then the output value is in list form and this property is non-nil.

#+NAME: mrosetta-mlexpression-is-plural
#+BEGIN_SRC emacs-lisp
(is-plural
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches plural values or just a single one. Either nil or non-nil."
 :reader mrosetta-mlexpression-is-plural)
#+END_SRC
*** Class Definition
The /expression/ class is defined below, containing all the properties listed above.

#+NAME: mrosetta-mlexpression
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defclass mrosetta-mlexpression ()
  (
   <<mrosetta-mlexpression-mldefinition>>
   <<mrosetta-mlexpression-extype>>
   <<mrosetta-mlexpression-fractals>>
   <<mrosetta-mlexpression-rkeychain>>
   <<mrosetta-mlexpression-regex>>
   <<mrosetta-mlexpression-regex-key>>
   <<mrosetta-mlexpression-rinstance>>
   <<mrosetta-mlexpression-rinstance-key>>
   <<mrosetta-mlexpression-rbase>>
   <<mrosetta-mlexpression-rmatch>>
   <<mrosetta-mlexpression-rmatch-key>>
   <<mrosetta-mlexpression-rprefix>>
   <<mrosetta-mlexpression-rsuffix>>
   <<mrosetta-mlexpression-left-rboundary>>
   <<mrosetta-mlexpression-right-rboundary>>
   <<mrosetta-mlexpression-rbuffer>>
   <<mrosetta-mlexpression-left-rbuffer-key>>
   <<mrosetta-mlexpression-right-rbuffer-key>>
   <<mrosetta-mlexpression-key>>
   <<mrosetta-mlexpression-is-uppercase>>
   <<mrosetta-mlexpression-is-capitalized>>
   <<mrosetta-mlexpression-match-prefix>>
   <<mrosetta-mlexpression-match-suffix>>
   <<mrosetta-mlexpression-match-substring>>
   <<mrosetta-mlexpression-match-literal>>
   <<mrosetta-mlexpression-is-contextual>>
   <<mrosetta-mlexpression-modifier>>
   <<mrosetta-mlexpression-is-optional>>
   <<mrosetta-mlexpression-should-ignore>>
   <<mrosetta-mlexpression-is-plural>>
  )
  "The Metarosetta Expression object used to define a contextual translational expression for semantic processing.")
#+END_SRC

** Language Specification
The purpose of the language is to facilitate expressions which unambiguously define a translation protocol between human-readable text and machine-digestible data structures, with the semantics completely preserved, based on an arbitrarily defined pattern of human input within a specific context.

All keywords within the specification are stored as symbols which map to their respective parse functions.

#+NAME: mrosetta-mlsyntax
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax '())
#+END_SRC

*** Literal Quote
The simplest expression defining statically quoted text which should appear literally within input text.

#+NAME: mrosetta-parse-literal
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-literal ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the :right arg content within ARGS as a literal quote into the MLEXPRESSION instance in context."
  (let ((literal-quote (plist-get args :right)))
    (when (eq literal-quote nil)
      (error "Metalanguage syntax error: Literal expression without quoted content"))
    (setf (slot-value mlexpression 'extype) :literal)
    (setf (slot-value mlexpression 'rbase) (regexp-quote literal-quote))
    (setf (slot-value mlexpression 'match-literal) literal-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage itself defines this expression through the ~literal~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-literal-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(literal . mrosetta-parse-literal) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-literal-example
#+BEGIN_SRC text
(literal "Status Update:")
#+END_SRC
*** Word
An expression used to capture a variable word from within input text.

#+NAME: mrosetta-parse-word
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'left-rboundary) "\\<")
  (setf (slot-value mlexpression 'rbase) "[[:word:]]+")
  (setf (slot-value mlexpression 'right-rboundary) "\\>")
  args)
#+END_SRC

The metalanguage defines this expression through the ~word~ keyword.

#+NAME: mrosetta-parse-word-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(word . mrosetta-parse-word) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-example
#+BEGIN_SRC text
(word)
#+END_SRC

**** Word Specifiers
In addition to the ability to match any kind of word, the metalanguage specification also supports matching only specific words based on different criteria.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-parse-word-uppercase
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-uppercase ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse an uppercase word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9]+")
  (setf (slot-value mlexpression 'is-uppercase) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~WORD~ keyword. Note that the metalanguage syntax is case-sensitive, where case is also part of the syntax itself.

#+NAME: mrosetta-parse-word-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(WORD . mrosetta-parse-word-uppercase) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-uppercase-example
#+BEGIN_SRC text
(WORD)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-parse-word-capitalized
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-capitalized ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a capitalized word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9][a-z0-9]+")
  (setf (slot-value mlexpression 'is-capitalized) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~Word~ keyword.

#+NAME: mrosetta-parse-word-capitalized-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(Word . mrosetta-parse-word-capitalized) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-capitalized-example
#+BEGIN_SRC text
(Word)
#+END_SRC
**** Word Plurality
Instead of a single value, capture all value occurrences matching defined criteria within the encompassing expression context.

#+NAME: mrosetta-parse-word-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural words expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~words~ keyword.

#+NAME: mrosetta-parse-word-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(words . mrosetta-parse-word-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-word-plurality-example
#+BEGIN_SRC text
(words)
#+END_SRC
*** Paragraph
An expression used to capture a variable paragraph from within input text.

A paragraph is considered all text within specified boundaries. If no boundaries are set, the entire input is matched.

#+NAME: mrosetta-parse-paragraph
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a paragraph epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) (concat ".+?"))
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraph~ keyword.

#+NAME: mrosetta-parse-paragraph-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraph . mrosetta-parse-paragraph) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-paragraph-example
#+BEGIN_SRC text
(paragraph)
#+END_SRC

**** Paragraph Plurality
Like words, it's possible to capture multiple paragraph occurrences matching the expression-defined criteria.

Note that this construct only makes sense if paragraphs are clearly bounded.

#+NAME: mrosetta-parse-paragraph-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural paragraph expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-paragraph mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraphs~ keyword.

#+NAME: mrosetta-parse-paragraph-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraphs . mrosetta-parse-paragraph-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-paragraph-plurality-example
#+BEGIN_SRC text
(";" suffixed paragraphs)
#+END_SRC
*** Specifiers
**** Content Specifier
Match only elements containing specific characters or content.

#+NAME: mrosetta-parse-substring
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-substring ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :right arg within ARGS as matching element substring into the MLEXPRESSION instance in context."
  (let* ((substring-quote (plist-get args :right))
         (rsubstring-quote (regexp-quote substring-quote))
         (rbase (slot-value mlexpression 'rbase)))
    (when (eq substring-quote nil)
      (error "Metalanguage syntax error: Substring match expression without quoted content"))
    (setf (slot-value mlexpression 'rmatch)
          (concat "\\(?:"
                  "\\(?:" rsubstring-quote "\\)?" rbase "\\(?:" rsubstring-quote "\\(?:" rbase "\\)?" "\\)+"
                  "\\|"
                  "\\(?:" "\\(?:" rbase "\\)?" rsubstring-quote "\\)+" rbase "\\(?:" rsubstring-quote "\\)?"
                  "\\)"))
    (setf (slot-value mlexpression 'match-substring) substring-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines this expression through the ~with~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-substring-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(with . mrosetta-parse-substring) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-substring-example
#+BEGIN_SRC text
(word with "-")
#+END_SRC
**** Boundaries
Match only elements with the specified prefix or suffix. Note that the prefix or suffix itself isn't part of the match.

***** Prefix
Match only elements prefixed with the supplied quoted content.

#+NAME: mrosetta-parse-prefix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-prefix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element prefix into the MLEXPRESSION instance in context."
  (let ((prefix-quote (plist-get args :left)))
    (when (eq prefix-quote nil)
      (error "Metalanguage syntax error: Prefix match expression without quoted content"))
    (setf (slot-value mlexpression 'rprefix) (regexp-quote prefix-quote))
    (setf (slot-value mlexpression 'match-prefix) prefix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~prefixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-prefix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(prefixed . mrosetta-parse-prefix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-prefix-example
#+BEGIN_SRC text
("#" prefixed word)
#+END_SRC
***** Suffix
Match only elements suffixed with the supplied quoted content.

#+NAME: mrosetta-parse-suffix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-suffix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element suffix into the MLEXPRESSION instance in context."
  (let ((suffix-quote (plist-get args :left)))
    (when (eq suffix-quote nil)
      (error "Metalanguage syntax error: Suffix match expression without quoted content"))
    (setf (slot-value mlexpression 'rsuffix) (regexp-quote suffix-quote))
    (setf (slot-value mlexpression 'match-suffix) suffix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~suffixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-suffix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(suffixed . mrosetta-parse-suffix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-suffix-example
#+BEGIN_SRC text
(";" suffixed word)
#+END_SRC
**** Contextual
Match elements based on contextual criteria of neighboring matches. Note that a contextual specifier is only applicable to ~paragraph~ expressions.

#+NAME: mrosetta-parse-contextual
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-contextual ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the contextual specifier into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-contextual) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~contextual~ keyword.

#+NAME: mrosetta-parse-contextual-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(contextual . mrosetta-parse-contextual) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-contextual-example
#+BEGIN_SRC text
(contextual paragraph)
#+END_SRC
*** Modifiers
Modify captured elements before structured output.

Modifiers are defined as contextual arguments succeeding the general modifier keyword.

#+NAME: mrosetta-mlsyntax-modifiers
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax-modifiers '())
#+END_SRC

**** Uppercase
Transform captured elements to uppercase format.

To do so, use the ~uppercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(uppercase . upcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-uppercase-example
#+BEGIN_SRC text
(word to uppercase)
#+END_SRC
**** Lowercase
Transform captured elements to lowercase format.

To do so, use the ~lowercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-lowercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(lowercase . downcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-lowercase-example
#+BEGIN_SRC text
(word to lowercase)
#+END_SRC
**** Modifier Argument Parser
All modifier contextual arguments are handled by a central modifier parser.

#+NAME: mrosetta-parse-modifier
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-modifier ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the modifier symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((modifier-symbol (plist-get args :right)))
    (when (eq modifier-symbol nil)
      (error "Metalanguage syntax error: Modifier expression without contextual argument symbol"))
    (setf (slot-value mlexpression 'modifier)
          (cdr (assq modifier-symbol mrosetta-mlsyntax-modifiers))))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the modifier context through the ~to~ keyword followed by the contextual arguments listed above.

#+NAME: mrosetta-parse-modifier-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(to . mrosetta-parse-modifier) mrosetta-mlsyntax)
#+END_SRC

*** Optionality
Specify whether the encompassing expression should be considered as an optional, or required match.

Input text without an optional expression match still gets processed, structured and output. Any input not matching all mandatory expressions is disregarded.

All defined expressions are considered as mandatory by default.

#+NAME: mrosetta-parse-optionality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-optionality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse expression optionality into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-optional) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~optional~ keyword.

#+NAME: mrosetta-parse-optionality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(optional . mrosetta-parse-optionality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-optionality-example
#+BEGIN_SRC text
(optional word)
#+END_SRC
*** Assignment
Assign a key to the resulting value of the encompassing expression.

#+NAME: mrosetta-parse-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-key ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the key symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((key-symbol (plist-get args :right)))
    (when (eq key-symbol nil)
      (error "Metalanguage syntax error: Key assignment without contextual key symbol"))
    (setf (slot-value mlexpression 'key) key-symbol))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the assignment expression through the ~as~ keyword followed by the key symbol.

#+NAME: mrosetta-parse-key-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(as . mrosetta-parse-key) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-key-example
#+BEGIN_SRC text
(word as a_property)
#+END_SRC
*** Ignorables
Specify whether the encompassing expression should be ignored from structured output. As noted above, ignorable expressions are matched but never included in structured semantic output.

Ignorables are considered as semantically insignificant text occurring before and after the semantic match itself.

While this text is unimportant for structured semantics, it remains an intrinsic part of the human-readable form. This provides an ability to regenerate the human-readable text with updated semantic information from a machine-generated source. I.e., it enables true two-way trans-operability between the human and machine forms.

#+NAME: mrosetta-parse-ignorable
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-ignorable ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the ignorable property into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'should-ignore) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~ignorable~ keyword.

#+NAME: mrosetta-parse-ignorable-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(ignorable . mrosetta-parse-ignorable) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-ignorable-example
#+BEGIN_SRC text
(ignorable ":" suffixed paragraph)
#+END_SRC
*** Collections
Instead of matching a single occurrence of a complex expression, repetitively capture the corresponding expression within input text containing the recurring pattern, while structuring the resulting match as a list.

Collections are essential in matching of targeted semantics from within enumerated clauses of text.

The metalanguage defines collection expressions through two keywords: ~list~ and ~of~.

The ~list~ specifies the type of the encompassing /parent/ expression, while the ~of~ designates its fractal content.

#+NAME: mrosetta-parse-list
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-list ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the list epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

#+NAME: mrosetta-parse-list-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(list . mrosetta-parse-list) mrosetta-mlsyntax)
#+END_SRC

In addition to the ~list~ specifier denoting a plural collection, there are cases where it's convenient to denote a /singular collection/ for the ability to define properties directly upon the complex expression, such as setting a property name to a subset of an expression, or to structure and group big linear expressions.

Singular collections are defined through the ~element~ keyword, of course followed by the ~of~ keyword designating the fractal content of the element in context.

#+NAME: mrosetta-parse-element
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-element ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the element expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) nil)
  args)
#+END_SRC

#+NAME: mrosetta-parse-element-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(element . mrosetta-parse-element) mrosetta-mlsyntax)
#+END_SRC

#+NAME: mrosetta-parse-of
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-of ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the sub-expression from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((sub-expression (plist-get args :right)))
    (when (or (eq sub-expression nil) (nlistp sub-expression))
      (error "Metalanguage syntax error: Sub-expression assignment without contextual expression"))
    (mrosetta-parse mlexpression :sub sub-expression))
  (plist-put args :right nil))
#+END_SRC

#+NAME: mrosetta-parse-of-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(of . mrosetta-parse-of) mrosetta-mlsyntax)
#+END_SRC

** Expression Parsing
Parse the metalanguage-specified definition within an expression instance.

#+NAME: mrosetta-parse
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the metalanguage-specified definition within the MLEXPRESSION instance. Optionally, parse the explicitly-set :sub definition in ARGS instead."
  (let* ((sub-definition (plist-get args :sub))
         (mldefinition (if (eq sub-definition nil)
                           (copy-tree (slot-value mlexpression 'mldefinition))
                         (copy-tree sub-definition)))
         (larg)
         (element)
         (rarg))
    (while (> (length mldefinition) 0)
      (setq element (pop mldefinition)
            rarg (car mldefinition))
      (when (symbolp element)
        ;; The element is a metalanguage keyword, so lookup the corresponding function and parse accordingly
        (let ((leftout-args (funcall (cdr (assq element mrosetta-mlsyntax)) mlexpression :left larg :right rarg)))
          (setq larg nil)
          (when (eq (plist-get leftout-args :right) nil)
            (pop mldefinition))))
      (when (and (listp element) (> (length element) 0))
        ;; The element is a nested fractal expression
        (setf (slot-value mlexpression 'extype) :fractal)
        (let ((fractal-mlexpression (mrosetta-mlexpression :mldefinition element :rkeychain (slot-value mlexpression 'rkeychain))))
          (setf (slot-value mlexpression 'fractals) `(,@(slot-value mlexpression 'fractals) ,fractal-mlexpression))
          (mrosetta-parse fractal-mlexpression))
        (setq larg nil))
      (when (stringp element)
        ;; The element is a quoted string, so just pass it along
        (setq larg element)))))
#+END_SRC

** Expression Compilation
Compile the entire fractal tree within the root expression instance into a regular expression structure.

#+NAME: mrosetta-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-compile ((mlexpression mrosetta-mlexpression))
  "Compile the MLEXPRESSION instance into a regular expression structure."
  (let* ((rkeychain (slot-value mlexpression 'rkeychain))
         (regex)
         (regex-key (mrosetta-keychain-generate-key rkeychain))
         (rinstance)
         (rinstance-key (mrosetta-keychain-generate-key rkeychain))
         (rmatch (slot-value mlexpression 'rmatch))
         (rmatch-key (mrosetta-keychain-generate-key rkeychain))
         (rprefix (slot-value mlexpression 'rprefix))
         (rsuffix (slot-value mlexpression 'rsuffix))
         (left-rboundary (slot-value mlexpression 'left-rboundary))
         (right-rboundary (slot-value mlexpression 'right-rboundary))
         (rbuffer (slot-value mlexpression 'rbuffer))
         (left-rbuffer-key (mrosetta-keychain-generate-key rkeychain))
         (right-rbuffer-key (mrosetta-keychain-generate-key rkeychain))
         (is-contextual (slot-value mlexpression 'is-contextual))
         (is-optional (slot-value mlexpression 'is-optional))
         (is-plural (slot-value mlexpression 'is-plural)))
    (if (eq (slot-value mlexpression 'extype) :fractal)
        ;; Recursively compile all nested fractal expression instances
        (let ((fractals (slot-value mlexpression 'fractals)))
          ;; Fractal Expressions cannot have end-matches
          (when rmatch
            (error "Metalanguage syntax error: End-matching expressions, like words or paragraphs, must be defined with parentheses"))
          (dolist (fractal fractals)
            (setq rmatch (concat rmatch (mrosetta-compile fractal)))))
      ;; Literal or end Match
      (when (eq rmatch nil)
        (setq rmatch (slot-value mlexpression 'rbase))))
    ;; Compile the total match, instance and expression-encompassing regular expressions
    (setq rmatch (concat "\\(?" (number-to-string rmatch-key) ":" rmatch "\\)"))
    (setq rinstance (concat "\\(?" (number-to-string rinstance-key) ":"
                            (when (not is-contextual)
                              (concat "\\(?" (number-to-string left-rbuffer-key) ":" rbuffer "\\)"
                                      (or rprefix left-rboundary)))
                            rmatch
                            (when (not is-contextual)
                              (concat (or rsuffix right-rboundary)
                                      "\\(?" (number-to-string right-rbuffer-key) ":" rbuffer "\\)"))
                            "\\)"))
    (setq regex (concat "\\(?" (number-to-string regex-key) ":"
                        rinstance
                        (when is-plural "+")
                        "\\)"
                        (when is-optional "?")))
    (setf (slot-value mlexpression 'rmatch-key) rmatch-key
          (slot-value mlexpression 'rmatch) rmatch
          (slot-value mlexpression 'left-rbuffer-key) left-rbuffer-key
          (slot-value mlexpression 'right-rbuffer-key) right-rbuffer-key
          (slot-value mlexpression 'rinstance-key) rinstance-key
          (slot-value mlexpression 'rinstance) rinstance
          (slot-value mlexpression 'regex-key) regex-key
          (slot-value mlexpression 'regex) regex)))
#+END_SRC

* Text Processing
Process human-readable source text and output the semantic data structure, as defined by the metalanguage expression in context.

#+NAME: mrosetta-process
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-process ((mlexpression mrosetta-mlexpression) &rest args)
  "Process human-readable text within the :text or :inner string within ARGS and return the semantic data structure as defined by the MLEXPRESSION instance."
  (let ((htext (or (plist-get args :text)
                   (plist-get args :inner)))
        (is-inner (plist-get args :inner))
        (exdata '())
        (case-fold-search nil))
    (or (when (and (mrosetta-mlexpression-is-contextual mlexpression) is-inner)
          ;; Return the full inner-text matched within the parent expression if not marked as ignorable
          (when (and (eq (mrosetta-mlexpression-extype mlexpression) :match)
                     (not (mrosetta-mlexpression-should-ignore mlexpression)))
            `(,(or (mrosetta-mlexpression-key mlexpression) :nokey) . ,htext)))
        (save-match-data
          (and htext
               (string-match (mrosetta-mlexpression-regex mlexpression) htext)
               ;; Found match for the entirety of the expression
               (let ((extext (match-string (mrosetta-mlexpression-regex-key mlexpression) htext))
                     (pos))
                 (save-match-data
                   ;; Iterate over all instance occurrences within the matching expression text
                   (while (string-match (mrosetta-mlexpression-rinstance mlexpression) extext pos)
                     (setq pos (match-end 0))
                     ;; Process the exact match as defined by the expression
                     (let ((instance-exdata))
                       ;; Cases where the expression is a :fractal
                       (when (eq (mrosetta-mlexpression-extype mlexpression) :fractal)
                         ;; Recursively process all fractals within
                         (let ((fractals (mrosetta-mlexpression-fractals mlexpression)))
                           (dolist (fractal fractals)
                             (let ((fractal-exdata (mrosetta-process fractal :inner (match-string (mrosetta-mlexpression-regex-key fractal) extext))))
                               (when fractal-exdata
                                 (setq instance-exdata `(,@instance-exdata ,fractal-exdata)))))))
                       ;; Cases where the expression is a :match
                       (when (and (eq (mrosetta-mlexpression-extype mlexpression) :match)
                                  (not (mrosetta-mlexpression-should-ignore mlexpression)))
                         ;; Just store the semantic end-match, modified if defined as such
                         (let ((match (match-string (mrosetta-mlexpression-rmatch-key mlexpression) extext))
                               (modifier (mrosetta-mlexpression-modifier mlexpression)))
                           (when modifier
                             (setq match (funcall modifier match)))
                           (setq instance-exdata match)))
                       (when instance-exdata
                         (setq exdata `(,@exdata ,instance-exdata)))))
                   (when exdata
                     ;; Splice instance data in case of a singular expression
                     (when (not (mrosetta-mlexpression-is-plural mlexpression))
                       (setq exdata (car exdata)))
                     ;; Return the structured semantic data object
                     `(,(or (mrosetta-mlexpression-key mlexpression) :nokey) . ,exdata)))))))))
#+END_SRC

* Text Updating
Process human-readable source text and output the original text semantically updated with the provided data structure.

#+NAME: mrosetta-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-update ((mlexpression mrosetta-mlexpression) &rest args)
  "Process human readable text within the :text or :inner string and return the semantically updated text with the provided :sdata structure within ARGS, as defined by the MLEXPRESSION instance."
  (let ((htext (or (plist-get args :text)
                   (plist-get args :inner)))
        (exkey (car (plist-get args :sdata)))
        (exdata (copy-tree (cdr (plist-get args :sdata))))
        (is-inner (plist-get args :inner))
        (newtext)
        (case-fold-search nil))
    (when (and exdata
               (not (eq exkey
                        (or (mrosetta-mlexpression-key mlexpression) :nokey))))
      (error "Data structure error: Key mismatch"))
    (or (when (and (mrosetta-mlexpression-is-contextual mlexpression) is-inner)
          ;; Return the full inner-text matched within the parent expression or the updated text passed in
          (or exdata htext))
        (save-match-data
          (and htext
               (string-match (mrosetta-mlexpression-regex mlexpression) htext)
               ;; Found metalanguage expression match
               (let ((extext (match-string (mrosetta-mlexpression-regex-key mlexpression) htext))
                     (pos))
                 (save-match-data
                   (while (string-match (mrosetta-mlexpression-rinstance mlexpression) extext pos)
                     (setq pos (match-end 0))
                     ;; Update each instance
                     (let ((instance-exdata (if (mrosetta-mlexpression-is-plural mlexpression) (pop exdata) exdata))
                           (instance-newtext))
                       (if (eq (mrosetta-mlexpression-extype mlexpression) :fractal)
                           ;; Recursively update all fractals within
                           (let ((fractals (mrosetta-mlexpression-fractals mlexpression)))
                             (dolist (fractal fractals)
                               (let* ((fractal-exdata (assq (mrosetta-mlexpression-key fractal) instance-exdata))
                                      (fractal-text (match-string (mrosetta-mlexpression-regex-key fractal) extext))
                                      (fractal-newtext (mrosetta-update fractal :inner fractal-text :sdata fractal-exdata)))
                                 (setq instance-newtext (concat instance-newtext fractal-newtext)))))
                         ;; Update end-elements
                         (let ((left-buffer (match-string (mrosetta-mlexpression-left-rbuffer-key mlexpression) extext))
                               (right-buffer (match-string (mrosetta-mlexpression-right-rbuffer-key mlexpression) extext)))
                           (when (eq (mrosetta-mlexpression-extype mlexpression) :match)
                             ;; Update match text, including ignorable matches
                             (let ((prefix (mrosetta-mlexpression-match-prefix mlexpression))
                                   (suffix (mrosetta-mlexpression-match-suffix mlexpression))
                                   (match (or instance-exdata
                                              (match-string (mrosetta-mlexpression-rmatch-key mlexpression) extext))))
                               (setq instance-newtext (concat left-buffer prefix match suffix right-buffer))))
                           (when (eq (mrosetta-mlexpression-extype mlexpression) :literal)
                             ;; Include the literal, with surrounding buffer
                             (let ((literal (mrosetta-mlexpression-match-literal mlexpression)))
                               (setq instance-newtext (concat left-buffer literal right-buffer))))))
                       (setq newtext (concat newtext instance-newtext))))
                   ;; Return the updated text
                   newtext)))))))
#+END_SRC

* Demos
This section covers various examples of metalanguage syntax.

#+NAME: demo-init
#+BEGIN_SRC emacs-lisp :noweb yes :session mrosetta-demo
<<dependencies>>

<<mrosetta-keychain>>
<<mrosetta-keychain-generate-key>>

<<mrosetta-mlexpression>>

<<mrosetta-mlsyntax>>
<<mrosetta-mlsyntax-modifiers>>

<<mrosetta-parse-literal>>
<<mrosetta-parse-literal-symbol>>
<<mrosetta-parse-word>>
<<mrosetta-parse-word-symbol>>
<<mrosetta-parse-word-uppercase>>
<<mrosetta-parse-word-uppercase-symbol>>
<<mrosetta-parse-word-capitalized>>
<<mrosetta-parse-word-capitalized-symbol>>
<<mrosetta-parse-word-plurality>>
<<mrosetta-parse-word-plurality-symbol>>
<<mrosetta-parse-paragraph>>
<<mrosetta-parse-paragraph-symbol>>
<<mrosetta-parse-paragraph-plurality>>
<<mrosetta-parse-paragraph-plurality-symbol>>
<<mrosetta-parse-substring>>
<<mrosetta-parse-substring-symbol>>
<<mrosetta-parse-prefix>>
<<mrosetta-parse-prefix-symbol>>
<<mrosetta-parse-suffix>>
<<mrosetta-parse-suffix-symbol>>
<<mrosetta-parse-contextual>>
<<mrosetta-parse-contextual-symbol>>
<<mrosetta-parse-modifier-uppercase-symbol>>
<<mrosetta-parse-modifier-lowercase-symbol>>
<<mrosetta-parse-modifier>>
<<mrosetta-parse-modifier-symbol>>
<<mrosetta-parse-optionality>>
<<mrosetta-parse-optionality-symbol>>
<<mrosetta-parse-key>>
<<mrosetta-parse-key-symbol>>
<<mrosetta-parse-ignorable>>
<<mrosetta-parse-ignorable-symbol>>
<<mrosetta-parse-list>>
<<mrosetta-parse-list-symbol>>
<<mrosetta-parse-element>>
<<mrosetta-parse-element-symbol>>
<<mrosetta-parse-of>>
<<mrosetta-parse-of-symbol>>

<<mrosetta-parse>>
<<mrosetta-compile>>
<<mrosetta-process>>
<<mrosetta-update>>

mrosetta-mlsyntax
#+END_SRC

#+RESULTS: demo-init
: ((of . mrosetta-parse-of) (element . mrosetta-parse-element) (list . mrosetta-parse-list) (ignorable . mrosetta-parse-ignorable) (as . mrosetta-parse-key) (optional . mrosetta-parse-optionality) (to . mrosetta-parse-modifier) (contextual . mrosetta-parse-contextual) (suffixed . mrosetta-parse-suffix) (prefixed . mrosetta-parse-prefix) (with . mrosetta-parse-substring) (paragraphs . mrosetta-parse-paragraph-plurality) (paragraph . mrosetta-parse-paragraph) (words . mrosetta-parse-word-plurality) (Word . mrosetta-parse-word-capitalized) (WORD . mrosetta-parse-word-uppercase) (word . mrosetta-parse-word) (literal . mrosetta-parse-literal))

Note that by metalanguage syntax, the outermost expression is auto-parenthesized, thus making it a legitimate list expression.

#+NAME: demo-mlexpression
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input="" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition)))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-process mlexpression :text input))
#+END_SRC

** Words
*** Uppercase Word
Match a single uppercase word.

#+NAME: demo-word-uppercase
#+BEGIN_EXAMPLE
WORD as status
#+END_EXAMPLE

We'll use a following example of input text.

#+NAME: demo-word-uppercase-text
#+BEGIN_EXAMPLE
The current status is OPERATIONAL.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-uppercase, input=demo-word-uppercase-text )

#+RESULTS:
: (status . "OPERATIONAL")

*** Capitalized Word
Match a single capitalized word.

#+NAME: demo-word-capitalized
#+BEGIN_EXAMPLE
Word as title
#+END_EXAMPLE

#+NAME: demo-word-capitalized-text
#+BEGIN_EXAMPLE
Report: All systems operational
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-capitalized, input=demo-word-capitalized-text )

#+RESULTS:
: (title . "Report")

*** A Prefixed Word
Match a single word defined by a specific prefix.

#+NAME: demo-word-prefixed
#+BEGIN_EXAMPLE
"#" prefixed word as tag
#+END_EXAMPLE

#+NAME: demo-word-prefixed-text
#+BEGIN_EXAMPLE
A new task has been created for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-prefixed, input=demo-word-prefixed-text )

#+RESULTS:
: (tag . "devops")

*** A Suffixed Word
Match a single word defined by a specific suffix.

#+NAME: demo-word-suffixed
#+BEGIN_EXAMPLE
"!" suffixed word as priority
#+END_EXAMPLE

#+NAME: demo-word-suffixed-text
#+BEGIN_EXAMPLE
A new critical! issue submitted.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-suffixed, input=demo-word-suffixed-text )

#+RESULTS:
: (priority . "critical")

*** Word with Specific Content
Match a word containing specific content, such as a single character or substring.

#+NAME: demo-word-content
#+BEGIN_EXAMPLE
word with "/" as project
#+END_EXAMPLE

#+NAME: demo-word-content-text
#+BEGIN_EXAMPLE
A new card added in backend/api.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-content, input=demo-word-content-text )

#+RESULTS:
: (project . "backend/api")

*** Word to Uppercase
Modify the matched word to uppercase.

#+NAME: demo-word-to-uppercase
#+BEGIN_EXAMPLE
"!" prefixed word as priority to uppercase
#+END_EXAMPLE

#+NAME: demo-word-to-uppercase-text
#+BEGIN_EXAMPLE
[!high] Received a new support ticket.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-uppercase, input=demo-word-to-uppercase-text )

#+RESULTS:
: (priority . "HIGH")

*** Word to Lowercase
Modify the matched word to lowercase.

#+NAME: demo-word-to-lowercase
#+BEGIN_EXAMPLE
"#" prefixed word as label to lowercase
#+END_EXAMPLE

#+NAME: demo-word-to-lowercase-text
#+BEGIN_EXAMPLE
New message received marked for #Support!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-lowercase, input=demo-word-to-lowercase-text )

#+RESULTS:
: (label . "support")

*** List of Words
Match a list of words matching defined criteria.

#+NAME: demo-word-list
#+BEGIN_EXAMPLE
":" prefixed words as tags
#+END_EXAMPLE

#+NAME: demo-word-list-text
#+BEGIN_EXAMPLE
Task completed successfully :devops :api!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-list, input=demo-word-list-text )

#+RESULTS:
: (tags "devops" "api")

** Paragraphs
*** Paragraph Based on Criteria
Match a paragraph of text conforming with specified criteria. Note that in order to successfully match a paragraph of text, both boundaries need to be either explicitly or contextually specified.

When explicitly setting boundaries, the left boundary is implicitly the first possibly matched character.

#+NAME: demo-paragraph
#+BEGIN_EXAMPLE
": " prefixed "." suffixed paragraph as status
#+END_EXAMPLE

#+NAME: demo-paragraph-text
#+BEGIN_EXAMPLE
Status update: API service started successfully.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph, input=demo-paragraph-text )

#+RESULTS:
: (status . "API service started successfully")

*** List of Paragraphs
Match a list of consecutive paragraphs defined by specified criteria.

#+NAME: demo-paragraph-list
#+BEGIN_EXAMPLE
"." suffixed paragraphs as statements to lowercase
#+END_EXAMPLE

#+NAME: demo-paragraph-list-text
#+BEGIN_EXAMPLE
One task completed. Three tasks updated. Two tasks created.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph-list, input=demo-paragraph-list-text )

#+RESULTS:
: (statements "one task completed" "three tasks updated" "two tasks created")

** Complex Expressions
*** All-inclusive Match
Match multiple elements alongside ignorable information within human readable text. Structure the semantic match within a root property.

#+NAME: demo-complex
#+BEGIN_EXAMPLE
element of ((WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)) as task
#+END_EXAMPLE

#+NAME: demo-complex-text
#+BEGIN_EXAMPLE
CRITICAL Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex, input=demo-complex-text )

#+RESULTS:
: (task (priority . "critical") (project . "backend/api") (type . "devops"))

*** Optional Matches
Match multiple elements, one or more of which are optional in presence and aren't required to trigger a semantic match.

#+NAME: demo-complex-optional
#+BEGIN_EXAMPLE
(optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)
#+END_EXAMPLE

The following text example doesn't contain an optional element. As expected, the structured data output is processed and matched, excluding the missing optional element.

#+NAME: demo-complex-optional-text
#+BEGIN_EXAMPLE
Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-optional-text )

#+RESULTS:
: (:nokey (project . "backend/api") (type . "devops"))

By passing the example from above, containing the optional priority element, the output structure includes and matches the element.

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-text )

#+RESULTS:
: (:nokey (priority . "critical") (project . "backend/api") (type . "devops"))

*** Complex Collections
Match multiple occurrences of expressions containing multiple elements.

#+NAME: demo-complex-collection
#+BEGIN_EXAMPLE
"!" suffixed list of ((optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types))
#+END_EXAMPLE

#+NAME: demo-complex-collection-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops! Task created in web/home for #frontend #design! BLOCKER task created in backend/api for #backend!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-collection, input=demo-complex-collection-text )

#+RESULTS:
: (:nokey ((priority . "critical") (project . "backend/api") (types "devops")) ((project . "web/home") (types "frontend" "design")) ((priority . "blocker") (project . "backend/api") (types "backend")))

** Text Regeneration
Update the original text with new semantic information from passed in structured data.

#+NAME: demo-mlexpression-update
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input-text="" input-data=""" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition))
       (sdata `(:nokey . ,(car (read-from-string (concat "(" input-data ")"))))))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-update mlexpression :text input-text :sdata sdata))
#+END_SRC

#+NAME: demo-regen
#+BEGIN_EXAMPLE
(WORD as priority) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types) (ignorable contextual paragraph)
#+END_EXAMPLE

#+NAME: demo-regen-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops #backend!
#+END_EXAMPLE

The structured data from input text will look like so:

#+CALL: demo-mlexpression( definition=demo-regen, input=demo-regen-text )

#+RESULTS:
: (:nokey (priority . "CRITICAL") (project . "backend/api") (types "devops" "backend"))

Now, we can pass in an updated property or two. The properties not included will remain intact.

#+NAME: demo-regen-data
#+BEGIN_EXAMPLE
(priority . "BLOCKER") (types "backend" "frontend")
#+END_EXAMPLE

#+CALL: demo-mlexpression-update( definition=demo-regen, input-text=demo-regen-text, input-data=demo-regen-data )

#+RESULTS:
: "BLOCKER task created in backend/api for #backend #frontend!"

* Connector
The connector layer enables processed semantic data to be sent out to a webhook-listening receiver, or, inversely, have incoming semantic data update the original text in context.

** Payload
*** Compile Payload
Compile the Lisp object to a compatible form for subsequent JSON serialization.

More specifically, the entire semantic data structure, by Metarosetta package convention, is composed of nested combinations of either alists, /plain/ lists or end values. Alists denote property-value pairs (where properties are always symbols themselves), while plain lists plural collections of values.

To be compatible with the JSON serializer, all plain lists must be converted to vectors, while alists left untouched.

#+NAME: mrosetta-connector-payload-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-connector-payload-compile (payload)
  "Compile the provided PAYLOAD Lisp object before serialization."
  (or (and (listp payload)
           ;; Alist Item, Alist or Collection
           (or (and (symbolp (car payload))
                    ;; Alist Item
                    `(,(car payload) . ,(mrosetta-connector-payload-compile (cdr payload))))
               (and (symbolp (caar payload))
                    ;; Alist
                    (mapcar (lambda (item)
                              (mrosetta-connector-payload-compile item))
                            payload))
               ;; Collection
               (vconcat (mapcar (lambda (item)
                                  (mrosetta-connector-payload-compile item))
                                payload))))
      ;; End Value
      payload))
#+END_SRC
*** Decompile Payload
Decompile the deserialized Lisp object.

After the JSON parser, all vectors must be converted to /plain/ lists.

#+NAME: mrosetta-connector-payload-decompile
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-connector-payload-decompile (payload)
  "Decompile the provided PAYLOAD Lisp object after deserialization."
  (or (and (listp payload)
           ;; Alist Item or Alist
           (or (and (symbolp (car payload))
                    ;; Alist Item
                    `(,(car payload) . ,(mrosetta-connector-payload-decompile (cdr payload))))
               (and (symbolp (caar payload))
                    ;; Alist
                    (mapcar (lambda (item)
                              (mrosetta-connector-payload-decompile item))
                            payload))
               ;; Unpredicted state
               (error "Payload decompilation error: Deserialized lists can only be property-value pairs, or alists")))
      (and (vectorp payload)
           ;; Collection
           (mapcar (lambda (item)
                     (mrosetta-connector-payload-decompile item))
                   payload))
      ;; End Value
      payload))
#+END_SRC
** HTTP
Handling the HTTP layer for both outgoing url requests as well as listening to incoming connections on specified paths.

*** Request
Create a request towards a specified url with the supplied parameters, headers and payload.

#+NAME: mrosetta-connector-http-request
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-connector-http-request (url &rest url-args)
  "Send the provided query paramaters set by :qparams within URL-ARGS in alist form, and :payload Lisp object as serialized JSON payload, if respectively provided, to the URL endpoint, specifying the :verb as :GET or :POST, as well as the connection :headers in alist form. Upon completion, call the :callback function with the :success status, :status-code and returned :payload object, if any, or :status-message in case of an error."
  (let ((full-url (concat url
                          ;; Apppend the query section if :qparams specified
                          (when (plist-get url-args :qparams)
                            (concat "?"
                                    ;; Map all the provided query parameters along with their corresponding values
                                    (mapconcat (lambda (parampair)
                                                 (let ((param (car parampair))
                                                       (value (cdr parampair)))
                                                   (concat param "=" value)))
                                               (plist-get url-args :qparams)
                                               "&")))))
        (url-request-method (substring (symbol-name (plist-get url-args :verb)) 1))
        (url-request-extra-headers (if (plist-get url-args :payload)
                                       ;; Payload exists, append appropriate header
                                       `(("Content-Type" . "application/json") ,@(plist-get url-args :headers))
                                     (plist-get url-args :headers)))
        (url-request-data (when (plist-get url-args :payload)
                            (json-serialize (mrosetta-connector-payload-compile (plist-get url-args :payload)))))
        (url-callback (plist-get url-args :callback)))
    ;; Retrieve asynchronously
    (url-retrieve full-url
                  (lambda (_status callback-cbarg)
                    (let (success
                          status-code
                          status-message
                          payload)
                      ;; Start at the beginning of the buffer
                      (goto-char (point-min))
                      ;; Set the status code
                      (setq status-code (url-http-symbol-value-in-buffer 'url-http-response-status (current-buffer)))
                      ;; Skip the headers section, delimited by an empty line
                      (re-search-forward "^$")
                      ;; Parse the payload section
                      (setq payload (mrosetta-connector-payload-decompile (json-parse-buffer :object-type 'alist)))
                      ;; Parse the status code
                      (if (eq (/ status-code 100) 2)
                          ;; If 2xx signal success
                          (setq success t)
                        ;; Else, set the status message from the payload
                        (setq status-message (cdr (assq 'message payload))))
                      ;; Call back the callback function with the response data
                      (funcall callback-cbarg
                               :success success
                               :status-code status-code
                               :status-message status-message
                               :payload payload))
                    ;; Kill the response buffer
                    (kill-buffer))
                  `(,url-callback))))
#+END_SRC
*** Listener
Create a listener server to listen on specified paths for incoming requests.

#+NAME: mrosetta-connector-http-listener
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-connector-http-listener ()
  ((hostname
    :initarg :hostname
    :type string
    :documentation "The host name of the server."
    :reader mrosetta-connector-http-listener-hostname)
   (port
    :initarg :port
    :type number
    :documentation "The port at which the web-server should accept requests."
    :reader mrosetta-connector-http-listener-port)
   (procotocl
    :initarg :protocol
    :initform "https"
    :type string
    :documentation "The protocol accepted for incoming requests. Note that this is only of informational nature, as TLS termination is done outside of Emacs."
    :reader mrosetta-connector-http-listener-protocol)
   (server
    :initform 'nil
    :type (or null ws-server)
    :documentation "A ws-server instance containing all instance-registered listeners.")
   (keychain
    :initform (mrosetta-keychain)
    :type mrosetta-keychain
    :documentation "A keychain to manage assigned endpoint ids.")
   (endpoints
    :initform '()
    :type list
    :documentation "A list of all instance-registered listeners.")
   (is-alive
    :initform 'nil
    :documentation "The state of the server in context, t if running, nil otherwise."
    :reader mrosetta-connector-http-listener-is-alive))
  "An object defining a specific web-server with corresponding handlers at specific paths.")
#+END_SRC

**** Start
Start the listening server containing all registered listeners.

#+NAME: mrosetta-connector-http-listener-start
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-http-listener-start ((listener mrosetta-connector-http-listener))
  "Start the LISTENER."
  (when (not (slot-value listener 'is-alive))
    (let ((port (slot-value listener 'port))
          (endpoints (slot-value listener 'endpoints)))
      ;; Start the server if one or more endpoints registered
      (when endpoints
        (setf (slot-value listener 'server)
              (ws-start (mapcar (lambda (endpointpair)
                                  (cdr endpointpair))
                                endpoints)
                        port))
        ;; Set and return t as is-alive status
        (setf (slot-value listener 'is-alive) t)))))
#+END_SRC
**** Stop
Stop the listening server.

#+NAME: mrosetta-connector-http-listener-stop
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-http-listener-stop ((listener mrosetta-connector-http-listener))
  "Stop the LISTENER."
  (when (slot-value listener 'is-alive)
    ;; Stop the server
    (ws-stop (slot-value listener 'server))
    (setf (slot-value listener 'server) nil)
    ;; Set the is-alive status and return success of stopping
    (not (setf (slot-value listener 'is-alive) nil))))
#+END_SRC
**** Set Endpoint
Set an endpoint to listen on a specified path for incoming requests, and react accordingly.

#+NAME: mrosetta-connector-http-listener-endpoint-set
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-http-listener-endpoint-set ((listener mrosetta-connector-http-listener) path &rest endpoint-args)
  "Set an endpoint to the LISTENER on the provided PATH, for the provided :verb within the ENDPOINT-ARGS. If :id provided, update an existing entpoint. Upon a received request, call back the :callback function with the request query parameters set by :qparams in alist form, and the :payload Lisp object parsed from the incoming JSON payload. Headers are passed in alist form and set by :headers. The callback function should return a response-defining property list containing a :status-code, :headers if any, and :payload if needed or :status-message if an error occurred. Return the created endpoint's id."
  (let ((keychain (slot-value listener 'keychain))
        (endpoint-id (plist-get endpoint-args :id))
        (verb (plist-get endpoint-args :verb))
        (listener-callback (plist-get endpoint-args :callback)))
    (if endpoint-id
        ;; Clear the existing endpoint
        (setf (slot-value listener 'endpoints)
              (assq-delete-all endpoint-id (slot-value listener 'endpoints)))
      ;; Generate a new endpoint id
      (setq endpoint-id (mrosetta-keychain-generate-key keychain)))
    ;; Create and save the endpoint
    (push `(,endpoint-id . ((,verb . ,path) . ,(lambda (request)
                                                 (let ((rprocess (ws-process request))
                                                       (rheaders (mapcar (lambda (html-headerpair)
                                                                           (let ((headerkey (car html-headerpair))
                                                                                 (headervalue (cdr html-headerpair)))
                                                                             `(,(capitalize (substring (symbol-name headerkey) 1)) . ,headervalue)))
                                                                         (cl-remove-if-not (lambda (headerpair)
                                                                                             (symbolp (car headerpair)))
                                                                                           (ws-headers request))))
                                                       (rparams (cl-remove-if-not (lambda (headerpair)
                                                                                    (stringp (car headerpair)))
                                                                                  (ws-headers request)))
                                                       (rbody (mrosetta-connector-payload-decompile (json-parse-string (ws-body request)
                                                                                                                       :object-type 'alist)))
                                                       (response '()))
                                                   ;; Call back the callback function with set arguments
                                                   (setq response (funcall listener-callback
                                                                           :headers rheaders
                                                                           :qparams rparams
                                                                           :payload rbody))
                                                   ;; Compile and write response
                                                   (let ((res-status-code (plist-get response :status-code))
                                                         (res-status-message (plist-get response :status-message))
                                                         (res-headers (plist-get response :headers))
                                                         (res-payload (plist-get response :payload)))
                                                     ;; If status message exists, compile it into a payload
                                                     (when res-status-message
                                                       (setq res-payload `(message . ,res-status-message)))
                                                     ;; If payload exists, append appropriate header
                                                     (when res-payload
                                                       (setq res-headers `(("Content-Type" . "application/json") . ,@res-headers)))
                                                     ;; Set response status code and headers
                                                     (apply #'ws-response-header rprocess res-status-code res-headers)
                                                     ;; Send the response
                                                     (process-send-string rprocess
                                                                          (json-serialize (mrosetta-connector-payload-compile res-payload))))))))
          (slot-value listener 'endpoints))
    ;; Return the set endpoint id
    endpoint-id))
#+END_SRC
** Webhooks
Encapsulating all the package-standard webhook operations.

*** Biting Webhook
An outgoing webhook defined by a remote url on which to call and send the extracted semantic data of a given match.

#+NAME: mrosetta-connector-webhook-biting
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-connector-webhook-biting ()
  ((url
    :initarg :url
    :type string
    :documentation "The endpoint url of the encompassing webhook instance."
    :reader mrosetta-connector-webhook-biting-url
    :writer mrosetta-connector-webhook-biting-url-set))
  "An outgoing, callable, webhook object to handle sending extracted semantic data of a given match.")
#+END_SRC

**** Bite
Call on the webhook object with the provided semantic data.

#+NAME: mrosetta-connector-webhook-bite
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-webhook-bite ((webhook mrosetta-connector-webhook-biting) sdata bite-callback)
  "Call on the WEBHOOK with the provided SDATA of a given Metalanguage expression match. Upon completion call back the BITE-CALLBACK with a success status of either t or nil, and an optional :message if unsuccessful."
  (let ((bite-url (slot-value webhook 'url)))
    ;; Create the HTTP request and register callback
    (mrosetta-connector-http-request bite-url
                                     :verb :POST
                                     :payload sdata
                                     :callback (lambda (&rest cbargs)
                                                 (let ((success (plist-get cbargs :success))
                                                       (msg (plist-get cbargs :status-message)))
                                                   (funcall bite-callback success :message msg))))))
#+END_SRC
*** Biting /Am Alive/ Webhook
A specialized type of biting webhook to notify /biters/ of this server's catching webhooks of its status.

#+NAME: mrosetta-connector-webhook-biting-am-alive
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-connector-webhook-biting-am-alive (mrosetta-connector-webhook-biting)
  ()
  "A subclasss of the biting webhook specialized for notifying remote biters of this server's alive status.")
#+END_SRC

**** Bite
Call on the webhook with the alive status.

#+NAME: mrosetta-connector-webhook-bite-am-alive
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-webhook-bite ((webhook mrosetta-connector-webhook-biting-am-alive) status bite-callback)
  "Call on the WEBHOOK to notify of the alive STATUS of t or nil. Upon completion, call back the BITE-CALLBACK with a success status of either t or nil, and an optional :message if unsuccessful."
  (cl-call-next-method webhook
                       `(am-alive . ,(if status "yes" "no"))
                       bite-callback))
#+END_SRC
*** Catching Webhook
An incoming webhook defined by a relative path which to listen on for semantic data updates.

#+NAME: mrosetta-connector-webhook-catching
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-connector-webhook-catching ()
  ((path
    :initarg :path
    :type string
    :documentation "The relative path which to listen on for the encompassing webhook catches."
    :reader mrosetta-connector-webhook-catching-path
    :writer mrosetta-connector-webhook-catching-path-set)
   (id
    :initform 'nil
    :type (or null number)
    :documentation "The listener endpoint id assigned to the webhook in context."))
  "An incoming webhook object to handle receiving semantic data updates for a given match.")
#+END_SRC

**** Get Full Endpoint URL
Return the webhook's full endpoint url.

#+NAME: mrosetta-connector-webhook-cathing-url
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-webhook-catching-url ((webhook mrosetta-connector-webhook-catching) listener)
  "Return the full endpoint URL of the WEBHOOK in context, within the provided LISTENER."
  (concat (mrosetta-connector-http-listener-protocol listener) "://"
          (mrosetta-connector-http-listener-hostname listener)
          "/" (slot-value webhook 'path)))
#+END_SRC
**** Catch
Register a catcher callback for when the encompassing hook is bitten on the other end.

#+NAME: mrosetta-connector-webhook-catch
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-webhook-catch ((webhook mrosetta-connector-webhook-catching) listener catch-callback)
  "Register a CATCH-CALLBACK for the WEBHOOK in context with the provided LISTENER. When hook caught, call back the callback function with a list of updated semantic data objects corresponding to tracked Metalanguage expression match instances. The callback should return :success of t if semantic data valid and update successful, or nil if not followed by an optional :message to the sender."
  (let ((catch-path (slot-value webhook 'path)))
    ;; Set the corresponding endpoint on the listener
    (setf (slot-value webhook 'id)
          (mrosetta-connector-http-listener-endpoint-set listener catch-path
                                                         :verb :POST
                                                         :id (slot-value webhook 'id)
                                                         :callback (lambda (&rest cbargs)
                                                                     (let* ((sdata (plist-get cbargs :payload))
                                                                            (res-args (funcall catch-callback sdata))
                                                                            (res-success (plist-get res-args :success))
                                                                            (res-message (plist-get res-args :message)))
                                                                       `(:status-code ,(if res-success 200 400)
                                                                         :status-message ,res-message)))))))
#+END_SRC
* Contexts
Compatible environments in which metalanguage expressions can be defined and input text natively processed.

** Org
Define context-specific metalanguage expressions which automatically process matching org-mode headers.

*** Org Helper Functions
Helper functions to get and set targeted org headers.

**** Get Heading
Get the full text of the heading, excluding the leading asterisks.

#+NAME: mrosetta-context-org-heading-get
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-context-org-heading-get ()
  "Get the full org heading at point as plain string, excluding the leading asterisks."
  (let ((curr-pos (line-beginning-position)))
    ;; Skip the leading asterisks and spaces
    (while (or (char-equal (char-after curr-pos) ?*)
               (char-equal (char-after curr-pos) ?\s))
      (setq curr-pos (1+ curr-pos)))
    ;; Get rest of heading content as string
    (buffer-substring-no-properties curr-pos (line-end-position))))
#+END_SRC
**** Set Heading
Set the full text of the heading, preserving the leading asterisks.

#+NAME: mrosetta-context-org-heading-set
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-context-org-heading-set (heading-text)
  "Set the full text of the org heading at point to HEADING-TEXT, while preserving the leading asterisks."
  ;; Start at the beginning of set line
  (goto-char (line-beginning-position))
  ;; Skip the leading asterisks and spaces
  (while (or (char-equal (following-char) ?*)
             (char-equal (following-char) ?\s))
    (forward-char))
  ;; Delete the rest of heading content
  (delete-region (point) (line-end-position))
  ;; Insert the new content at point
  (insert heading-text))
#+END_SRC
**** Find Heading
Find a specific org heading, given its identifying property.

#+NAME: mrosetta-context-org-heading-find
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-context-org-heading-find (org-file property-name property-value heading-callback)
  "Find a specific org heading within ORG-FILE, matched by PROPERTY-VALUE of PROPERTY-NAME. If found, call back the HEADING-CALLBACK with point at the beginning of the heading line."
  (org-map-entries heading-callback
                   (concat "+" property-name "=" "\"" property-value "\"")
                   `(,org-file)))
#+END_SRC
*** Match Index
In order to keep track of all the matched headings across all defined metalanguage expressions agnostic of the org file where the definitions (or matches) are written, an index structure serves as a singular source of truth.

In terms of implementation and data persistence, the index is structured as a persistent composition, with all the elements classified by their matching expression.

**** Collection Manager
A per-collection object used to manage items contained within along with their collection-dependent properties such as unique id.

#+NAME: mrosetta-context-org-collection
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-collection ()
  ((keychain
    :initarg :keychain
    :initform (mrosetta-keychain)
    :type mrosetta-keychain
    :documentation "The keychain instance used to generate item keys within the scope of the encompassing collection instance.")
   (item-class
    :initarg :item-class
    :type symbol
    :documentation "The containing items' class symbol.")
   (items
    :initform '()
    :type list
    :documentation "An alist of items, mapped by id, contained within the encompassing collection instance."
    :reader mrosetta-context-org-collection-items))
  "A collection manager of tracked org entry items within a specific scope. Must be subclassed with items of specific type.")
#+END_SRC

***** Setting Items
Add or update items within the collection instance.

#+NAME: mrosetta-context-org-collection-set
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-collection-set ((collection mrosetta-context-org-collection) item)
  "Add or reset the ITEM within the managed org COLLECTION."
  (when (not (eq (slot-value collection 'item-class)
                 (eieio-object-class item)))
    (error "Collection class mismatch error: The provided item is incompatible with the encompassing collection"))
  (let ((item-id (or (mrosetta-context-org-entry-id item)
                     (mrosetta-keychain-generate-key (slot-value collection 'keychain)))))
    (mrosetta-context-org-entry-id-set item item-id)
    ;; Add the new item to collection, potentially replacing an existing one
    (setf (slot-value collection 'items) (assq-delete-all item-id (slot-value collection 'items)))
    (push `(,item-id . ,item) (slot-value collection 'items))
    item))
#+END_SRC
***** Getting Items
Get an item from the collection instance.

#+NAME: mrosetta-context-org-collection-get
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-collection-get ((collection mrosetta-context-org-collection) item-id)
  "Get an item from the COLLECTION defined by the provided ITEM-ID. Return the item or nil if none present."
  (cdr (assq item-id (slot-value collection 'items))))
#+END_SRC
**** Org Entries
An index element referring to an org entry. These can be either metalanguage expressions or matches themselves. Both contain general as well as specific properties.

#+NAME: mrosetta-context-org-entry
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-entry ()
  ((id
    :initarg :id
    :initform 'nil
    :type (or null number)
    :documentation "The entry identifier within the scope of its encompassing collection."
    :reader mrosetta-context-org-entry-id
    :writer mrosetta-context-org-entry-id-set)
   (org-file
    :initarg :org-file
    :type string
    :documentation "The org file within which the encompassing entry is set."
    :reader mrosetta-context-org-entry-file))
  "An org entry reference matched within the Metarosetta framework."
  :abstract t)
#+END_SRC

***** ML Expression Org Entry
An index element referring to an org entry which defines a metalanguage expression. These definitions can be defined *anywhere* within *any* org file, as long as they're a proper org heading.

Naturally, updating this org entry within its original context automatically updates the expression itself.

#+NAME: mrosetta-context-org-mlexpression
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-mlexpression (mrosetta-context-org-entry)
  ((mldefinition
    :initarg :mldefinition
    :type list
    :documentation "The metalanguage definition referring to the org entry in context."
    :reader mrosetta-context-org-mlexpression-mldefinition
    :writer mrosetta-context-org-mlexpression-mldefinition-set)
   (biting-hook
    :initform 'nil
    :type (or null mrosetta-connector-webhook-biting)
    :documentation "The outgoing webhook to bite when sending out extracted structured semantic data."
    :reader mrosetta-context-org-mlexpression-biting-hook
    :writer mrosetta-context-org-mlexpression-biting-hook-set)
   (biting-hook-compilation
    :initarg :biting-hook-compilation
    :initform 'nil
    :type (or null string)
    :documentation "The compiled value to persist which defines the biting webhook object in context.")
   (am-alive-hook
    :initform 'nil
    :type (or null mrosetta-connector-webhook-biting-am-alive)
    :documentation "A dedicated outgoing webhook to notify the biting end of the incoming hook of this server's alive status. No need to bite on hooks when the catcher is down."
    :reader mrosetta-context-org-mlexpression-am-alive-hook
    :writer mrosetta-context-org-mlexpression-am-alive-hook-set)
   (am-alive-hook-compilation
    :initarg :am-alive-hook-compilation
    :initform 'nil
    :type (or null string)
    :documentation "The compiled value to persist which defines the am alive webhook object in context.")
   (catching-hook
    :initform 'nil
    :type (or null mrosetta-connector-webhook-catching)
    :documentation "The incoming webhook to catch when receiving semantic data to update tracked matches with."
    :reader mrosetta-context-org-mlexpression-catching-hook
    :writer mrosetta-context-org-mlexpression-catching-hook-set)
   (catching-hook-compilation
    :initarg :catching-hook-compilation
    :initform 'nil
    :type (or null string)
    :documentation "The compiled value to persist which defines the catching webhook object in context.")
   (match-collection
    :initarg :match-collection
    :initform (mrosetta-context-org-collection :item-class 'mrosetta-context-org-match)
    :type mrosetta-context-org-collection
    :documentation "The managed collection of all current matches corresponding to the metalanguage expression in context."
    :reader mrosetta-context-org-mlexpression-match-collection)
   (match-compilation
    :initarg :match-compilation
    :initform '()
    :type (list-of mrosetta-context-org-match)
    :documentation "The compiled list corresponding to the collection of matches. Used only for (de)serialization."))
  "An org entry referencing a particular metalanguage definition.")
#+END_SRC
***** ML Expression Match Org Entry
An index element referring to a matching org entry in context of a particular metalanguage expression.

#+NAME: mrosetta-context-org-match
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-match (mrosetta-context-org-entry)
  ((sync-id
    :initarg :sync-id
    :initform '0
    :type number
    :documentation "A synchronization id specifying the exact version of the match. Each update, from any side, increments the sync id."
    :reader mrosetta-context-org-match-sync-id
    :writer mrosetta-context-org-match-sync-id-set))
  "An org entry referencing a specific match in context of a particular metalanguage definition.")
#+END_SRC

****** Methods
******* Confirm Sync
Confirm successful synchronization by updating the sync id of the match.

#+NAME: mrosetta-context-org-match-sync-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-match-sync-update ((match mrosetta-context-org-match))
  "Update the sync id of the MATCH."
  (setf (slot-value match 'sync-id) (1+ (slot-value match 'sync-id))))
#+END_SRC
**** Index Persistence
A datastore object used as an entry point for the indexed data, as well as a point of serialization to and deserialization from the disk.

#+NAME: mrosetta-context-org-db
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-db (eieio-persistent)
  ((file :initarg :file)
   (mlexpression-collection
    :initarg :mlexpression-collection
    :initform (mrosetta-context-org-collection :item-class 'mrosetta-context-org-mlexpression)
    :type mrosetta-context-org-collection
    :documentation "A managed collection of all defined and tracked metalanguage expressions in scope of the Metarosetta package."
    :reader mrosetta-context-org-db-mlexpression-collection)
   (mlexpression-compilation
    :initarg :mlexpression-compilation
    :initform '()
    :type (list-of mrosetta-context-org-mlexpression)
    :documentation "The compiled list corresponding to the collection of mlexpressions. Used only for (de)serialization."))
  "The root index object for all metalanguage definitions and matches within the org context.")
#+END_SRC
**** Index Compilation
In order to persist the org index using ~eieio-persistent~ methods, all collection objects must be compiled into strictly-typed linear lists.

#+NAME: mrosetta-context-org-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defgeneric mrosetta-context-org-compile (context-org-object)
  "Compile the CONTEXT-ORG-OBJECT into a compatible format for serialization to disk.")
#+END_SRC

***** Collection
Compile the collection for serialization to disk. Also compile all nested collections, if any.

#+NAME:  mrosetta-context-org-compile-collection
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((collection mrosetta-context-org-collection))
  "Recursively compile the items contained within the COLLECTION. Return the compiled list."
  (mapcar (lambda (item-pair)
            (let ((item (cdr item-pair)))
              (mrosetta-context-org-compile item)))
          (slot-value collection 'items)))
#+END_SRC
***** Entries
Compile the index entries themselves.

****** Base Entry
The default compilation method matching any org entry.

#+NAME: mrosetta-context-org-compile-entry
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((entry mrosetta-context-org-entry))
  "Compile the ENTRY for serialization to disk."
  ;; Nothing to compile, all slots are directly compatible
  entry)
#+END_SRC
****** ML Expression
Compile the metalanguage expression org context index entry.

#+NAME: mrosetta-context-org-compile-mlexpression
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((mlexpression-entry mrosetta-context-org-mlexpression))
  "Compile the MLEXPRESSION-ENTRY for serialization to disk."
  ;; Compile registered webhooks
  (setf (slot-value mlexpression-entry 'biting-hook-compilation)
        (let ((hook (slot-value mlexpression-entry 'biting-hook)))
          (when hook
            (mrosetta-connector-webhook-biting-url hook))))
  (setf (slot-value mlexpression-entry 'am-alive-hook-compilation)
        (let ((hook (slot-value mlexpression-entry 'am-alive-hook)))
          (when hook
            (mrosetta-connector-webhook-biting-url hook))))
  (setf (slot-value mlexpression-entry 'catching-hook-compilation)
        (let ((hook (slot-value mlexpression-entry 'catching-hook)))
          (when hook
            (mrosetta-connector-webhook-catching-path hook))))
  ;; Compile the contained match collection
  (setf (slot-value mlexpression-entry 'match-compilation)
        (mrosetta-context-org-compile (slot-value mlexpression-entry 'match-collection)))
  (cl-call-next-method mlexpression-entry))
#+END_SRC
****** Root
Compile the root ~db~ object.

#+NAME: mrosetta-context-org-compile-db
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((db mrosetta-context-org-db))
  "Compile the root DB entry object for serialization to disk."
  (setf (slot-value db 'mlexpression-compilation)
        (mrosetta-context-org-compile (slot-value db 'mlexpression-collection)))
  db)
#+END_SRC
**** Index Decompilation
Upon loading a previously saved instance of the org index, all collection objects must be decompiled for proper use.

#+NAME: mrosetta-context-org-decompile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defgeneric mrosetta-context-org-decompile (context-org-object &optional compilation)
  "Decompile the contents of the CONTEXT-ORG-OBJECT from the provided COMPILATION, or an inner slot if structured as such.")
#+END_SRC

***** Collection
Decompile the collection from a provided serialized list of compatible items.

#+NAME: mrosetta-context-org-decompile-collection
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((collection mrosetta-context-org-collection) &optional compilation)
  "Recursively decompile the COMPILATION of items into the COLLECTION."
  (setf (slot-value collection 'items)
        (mapcar (lambda (item)
                  `(,(mrosetta-context-org-entry-id item) . ,(mrosetta-context-org-decompile item)))
                compilation))
  collection)
#+END_SRC
***** Entries
Decompile the index entries.

****** Base Entry
The default decompilation method matching any org entry.

#+NAME: mrosetta-context-org-decompile-entry
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((entry mrosetta-context-org-entry) &optional _compilation)
  "Decompile the contents of the ENTRY from a compilation slot within, not the provided COMPILATION argument."
  ;; Nothing to decompile, all slots are directly usable
  entry)
#+END_SRC
****** ML Expression
Decompile the metalanguage expression org context index entry.

#+NAME: mrosetta-context-org-decompile-mlexpression
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((mlexpression-entry mrosetta-context-org-mlexpression) &optional _compilation)
  "Decompile the contents of the MLEXPRESSION-ENTRY from a compilation slot within, not the provided COMPILATION argument."
  ;; Decompile registered webhooks, if any
  (setf (slot-value mlexpression-entry 'biting-hook)
        (let ((hook-compilation (slot-value mlexpression-entry 'biting-hook-compilation)))
          (when hook-compilation
            (mrosetta-connector-webhook-biting :url hook-compilation))))
  (setf (slot-value mlexpression-entry 'am-alive-hook)
        (let ((hook-compilation (slot-value mlexpression-entry 'am-alive-hook-compilation)))
          (when hook-compilation
            (mrosetta-connector-webhook-biting-am-alive :url hook-compilation))))
  (setf (slot-value mlexpression-entry 'catching-hook)
        (let ((hook-compilation (slot-value mlexpression-entry 'catching-hook-compilation)))
          (when hook-compilation
            (mrosetta-connector-webhook-catching :path hook-compilation))))
  ;; Decompile the contained match collection
  (mrosetta-context-org-decompile (slot-value mlexpression-entry 'match-collection)
                                  (slot-value mlexpression-entry 'match-compilation))
  ;; Clear the compiled elements after decompilation
  (setf (slot-value mlexpression-entry 'biting-hook-compilation) nil)
  (setf (slot-value mlexpression-entry 'am-alive-hook-compilation) nil)
  (setf (slot-value mlexpression-entry 'catching-hook-compilation) '())
  (setf (slot-value mlexpression-entry 'match-compilation) '())
  (cl-call-next-method mlexpression-entry))
#+END_SRC
****** Root
Decompile the root ~db~ object.

#+NAME: mrosetta-context-org-decompile-db
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((db mrosetta-context-org-db) &optional _compilation)
  "Decompile the contents of DB from a compilation slot within, not the provided COMPILATION argument."
  (mrosetta-context-org-decompile (slot-value db 'mlexpression-collection)
                                  (slot-value db 'mlexpression-compilation))
  ;; Clear the compiled list after decompilation
  (setf (slot-value db 'mlexpression-compilation) '())
  db)
#+END_SRC
*** Context Object
The object handling all Metarosetta-related operations within the org context.

#+NAME: mrosetta-context-org
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org ()
  ((index
    :initform 'nil
    :type (or null mrosetta-context-org-db)
    :documentation "The active datastore of the current Metarosetta context, containing all defined metalagnuage definitions with their respectively tracked matches."
    :reader mrosetta-context-org-index)
   (mlexpressions
    :initform '()
    :type list
    :documentation "The current session's cache containing all compiled metalanguage expressions active in current context."
    :reader mrosetta-context-org-mlexpressions)
   (listener
    :initform 'nil
    :type (or null mrosetta-connector-http-listener)
    :documentation "The encompassing context's web-server instance listening on tracked metalanguage expressions' incoming semantic data webhooks."
    :reader mrosetta-context-org-listener))
  "The Metarosetta org context object. Handles all Metarosetta-related operations within the org context.")
#+END_SRC

**** Context Persistence
Persist the context index between Emacs sessions.

***** Load Context
Load the context index from previous Emacs sessions.

#+NAME: mrosetta-context-org-load
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-load ((context mrosetta-context-org) index-file)
  "Load the index datastore from INDEX-FILE, or create a new one if none exists, and compile all indexed Metalanguage expressions within the CONTEXT."
  ;; Load the index datastore
  (let ((index (setf (slot-value context 'index) (or (when (file-exists-p index-file)
                                                       (eieio-persistent-read index-file 'mrosetta-context-org-db))
                                                     (mrosetta-context-org-db :file index-file)))))
    ;; Decompile index entries
    (mrosetta-context-org-decompile index)
    ;; Initialize the registered Metalanguage expression instances
    (setf (slot-value context 'mlexpressions)
          (mapcar (lambda (org-mlexpression-pair)
                    (let* ((org-mlexpression-id (car org-mlexpression-pair))
                           (org-mlexpression-entry (cdr org-mlexpression-pair))
                           (mlexpression (mrosetta-mlexpression :mldefinition (mrosetta-context-org-mlexpression-mldefinition org-mlexpression-entry))))
                      ;; Parse and compile the metalanguage expression
                      (mrosetta-parse mlexpression)
                      (mrosetta-compile mlexpression)
                      ;; Return the metalanguage expression pair
                      `(,org-mlexpression-id . ,mlexpression)))
                  (mrosetta-context-org-collection-items (mrosetta-context-org-db-mlexpression-collection index)))))
  ;; Just return the loaded context
  context)
#+END_SRC
***** Save Context
Persist context index after quitting Emacs.

#+NAME: mrosetta-context-org-save
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-save ((context mrosetta-context-org))
  "Save CONTEXT index to the file defined within."
  (let ((index (slot-value context 'index)))
    ;; Compile index entries into serializable form
    (mrosetta-context-org-compile index)
    ;; Save the index datastore
    (eieio-persistent-save index)))
#+END_SRC
**** Context Listener
***** Start Context Listener
Start listening for incoming semantic data within current context.

#+NAME: mrosetta-context-org-start-listening
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-start-listening ((context mrosetta-context-org) hostname port)
  "Start listening for incoming semantic data at HOSTNAME on PORT within CONTEXT. Note that the host name is for notational purposes only."
  (let ((mlexpression-index (mrosetta-context-org-db-mlexpression-collection (slot-value context 'index)))
        (listener (setf (slot-value context 'listener)
                        (mrosetta-connector-http-listener :hostname hostname :port port))))
    ;; Set all endpoints within the index
    (dolist (mlexpression-index-entry-pair (mrosetta-context-org-collection-items mlexpression-index))
      (let* ((mlexpression-id (car mlexpression-index-entry-pair))
             (mlexpression-index-entry (cdr mlexpression-index-entry-pair))
             (catching-hook (mrosetta-context-org-mlexpression-catching-hook mlexpression-index-entry)))
        ;; Catch webhook in context
        (mrosetta-connector-webhook-catch catching-hook
                                          listener
                                          (lambda (sdata)
                                            ;; Update headings within the context of the Metalanguage expression
                                            (mrosetta-context-org-update-headings context mlexpression-id sdata)
                                            ;; Confirm successful reception of data
                                            `(:success t)))))
    ;; Start listener
    (mrosetta-connector-http-listener-start listener)))
#+END_SRC
***** Stop Context Listener
Stop listening for incoming semantic data.

#+NAME: mrosetta-context-org-stop-listening
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-stop-listening ((context mrosetta-context-org))
  "Stop listening for incoming semantic data within CONTEXT."
  (let ((listener (slot-value context 'listener)))
    ;; Stop listener
    (mrosetta-connector-http-listener-stop listener)))
#+END_SRC
**** Handler Functions
This section covers the operational functionality of the org context.

***** Process Org Heading
Process the org heading at point.

#+NAME: mrosetta-context-org-process
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-process-heading ((context mrosetta-context-org))
  "Process the heading at point by the provided Metarosetta CONTEXT."
  (let ((heading-text (mrosetta-context-org-heading-get)))
    (and heading-text
         (or (and (string-match "#mrosetta[[:blank:]]+\\(.+\\)" heading-text)
                  ;; Process the Metarosetta Metalanguage expression definition
                  (let* ((input-text (match-string 1 heading-text))
                         (mldefinition (car (read-from-string (concat "(" input-text ")"))))
                         (mlexpression-id (let ((id-property (org-entry-get (point) "mrosetta-mlexpression-id")))
                                            (when (and id-property
                                                       (not (string-empty-p id-property)))
                                              (string-to-number id-property))))
                         (biting-hook-url (let ((hook-url (org-entry-get (point) "mrosetta-mlexpression-bite-url")))
                                            (when (and hook-url
                                                       (not (string-empty-p hook-url)))
                                              hook-url)))
                         (am-alive-hook-url (let ((hook-url (org-entry-get (point) "mrosetta-mlexpression-am-alive-url")))
                                              (when (and hook-url
                                                         (not (string-empty-p hook-url)))
                                                hook-url)))
                         (catching-hook-url (let ((hook-url (org-entry-get (point) "mrosetta-mlexpression-catch-url")))
                                              (when (and hook-url
                                                         (not (string-empty-p hook-url)))
                                                hook-url)))
                         (mlexpression-index (mrosetta-context-org-db-mlexpression-collection (mrosetta-context-org-index context)))
                         (mlexpression-index-entry (or (let ((entry (mrosetta-context-org-collection-get mlexpression-index mlexpression-id)))
                                                         (when entry
                                                           (mrosetta-context-org-mlexpression-mldefinition-set entry mldefinition)
                                                           entry))
                                                       (mrosetta-context-org-mlexpression :org-file (buffer-file-name)
                                                                                          :mldefinition mldefinition)))
                         (mlexpression (mrosetta-mlexpression :mldefinition mldefinition))
                         (listener (mrosetta-context-org-listener context)))
                    (prog1 t ;; Regardless of the processing result, the match itself is valid and should return as such
                      ;; Index the entry
                      (setq mlexpression-index-entry (mrosetta-context-org-collection-set mlexpression-index mlexpression-index-entry))
                      (setq mlexpression-id (mrosetta-context-org-entry-id mlexpression-index-entry))
                      ;; Set weebhooks within the index entry, if any
                      ;; Set remote biting hook URL
                      (when biting-hook-url
                        (let ((hook (mrosetta-context-org-mlexpression-biting-hook mlexpression-index-entry)))
                          (if hook
                              (mrosetta-connector-webhook-biting-url-set hook biting-hook-url)
                            (mrosetta-context-org-mlexpression-biting-hook-set mlexpression-index-entry
                                                                               (mrosetta-connector-webhook-biting :url biting-hook-url)))))
                      ;; Set remote am-alive hook URL
                      (when am-alive-hook-url
                        (let ((hook (mrosetta-context-org-mlexpression-am-alive-hook mlexpression-index-entry)))
                          (if hook
                              (mrosetta-connector-webhook-biting-url-set hook biting-hook-url)
                            (mrosetta-context-org-mlexpression-am-alive-hook-set mlexpression-index-entry
                                                                                 (mrosetta-connector-webhook-biting-am-alive :url am-alive-hook-url)))))
                      ;; Parse the local catching hook path or generate a new one, and setup the webhook accordingly
                      (let ((catching-hook-path (or (and catching-hook-url
                                                         (save-match-data
                                                           (and (string-match "http\\(?:s\\)?://.+/\\(.+\\)" catching-hook-url)
                                                                (match-string 1 catching-hook-url))))
                                                    (mapconcat (lambda (char)
                                                                 (char-to-string (+ char
                                                                                    (random (1+ (- ?z char))))))
                                                               (make-list 17 ?a)
                                                               "")))
                            (hook (mrosetta-context-org-mlexpression-catching-hook mlexpression-index-entry)))
                        (if hook
                            (mrosetta-connector-webhook-catching-path-set hook catching-hook-path)
                          (setq hook (mrosetta-connector-webhook-catching :path catching-hook-path))
                          (mrosetta-context-org-mlexpression-catching-hook-set mlexpression-index-entry hook))
                        ;; Stop the listener
                        (mrosetta-connector-http-listener-stop listener)
                        ;; Register the webhook
                        (mrosetta-connector-webhook-catch hook
                                                          listener
                                                          (lambda (sdata)
                                                            ;; Update headings within the context of the Metalanguage expression
                                                            (mrosetta-context-org-update-headings context mlexpression-id sdata)
                                                            ;; Confirm successful reception of data
                                                            ;; (Parse info not included within the response for simplicity's sake)
                                                            `(:success t)))
                        ;; Start the listener
                        (mrosetta-connector-http-listener-start listener)
                        ;; Update the webhook url
                        (setq catching-hook-url (mrosetta-connector-webhook-catching-url hook listener)))
                      ;; Parse and compile the Metalanguage expression
                      (mrosetta-parse mlexpression)
                      (mrosetta-compile mlexpression)
                      ;; Cache the Metalanguage expression, replacing the previous entry if needed
                      (setf (slot-value context 'mlexpressions) (assq-delete-all mlexpression-id (slot-value context 'mlexpressions)))
                      (push `(,mlexpression-id . ,mlexpression) (slot-value context 'mlexpressions))
                      ;; Populate the org entry istelf with Metarosetta properties
                      ;; Expression ID
                      (org-entry-put (point) "mrosetta-mlexpression-id" (number-to-string mlexpression-id))
                      ;; Webhooks
                      (org-entry-put (point) "mrosetta-mlexpression-bite-url" biting-hook-url)
                      (org-entry-put (point) "mrosetta-mlexpression-am-alive-url" am-alive-hook-url)
                      (org-entry-put (point) "mrosetta-mlexpression-catch-url" catching-hook-url)
                      ;; Notify the user
                      (message "Mrosetta Metalanguage expression processed successfully!"))))
             (let* (did-match
                    (mlexpression-cache (mrosetta-context-org-mlexpressions context))
                    (mlexpression-ids (mapcar (lambda (mlexpression-pair) (car mlexpression-pair))
                                              mlexpression-cache)))
               ;; Check if provided heading matches any of the active Metalanguage expressions
               (while (let ((mlexpression-id (pop mlexpression-ids)))
                        (and mlexpression-id
                             (let* ((mlexpression (cdr (assq mlexpression-id mlexpression-cache)))
                                    (sdata (mrosetta-process mlexpression :text heading-text)))
                               ;; If matched, bite webhook in context and stop iterating
                               ;; If not, continue to the next possible Metalanguage expression match
                               (not (and sdata
                                         (let* ((mlexpression-index-entry (mrosetta-context-org-collection-get (mrosetta-context-org-db-mlexpression-collection (mrosetta-context-org-index context))
                                                                                                               mlexpression-id))
                                                (biting-hook (mrosetta-context-org-mlexpression-biting-hook mlexpression-index-entry))
                                                (mlexpression-match-index (mrosetta-context-org-mlexpression-match-collection mlexpression-index-entry))
                                                (match-id (let ((id-property (org-entry-get (point) "mrosetta-match-id")))
                                                            (when (and id-property
                                                                       (not (string-empty-p id-property)))
                                                              (string-to-number id-property))))
                                                (match-index-entry (or (mrosetta-context-org-collection-get mlexpression-match-index match-id)
                                                                       (mrosetta-context-org-match :org-file (buffer-file-name))))
                                                (match-sync-id (mrosetta-context-org-match-sync-update match-index-entry)))
                                           (prog1 t ;; Regardless if the bite actually succeeded, the match itself is valid and should return as such
                                             ;; Add index entry, if new
                                             (setq match-index-entry (mrosetta-context-org-collection-set mlexpression-match-index match-index-entry))
                                             (setq match-id (mrosetta-context-org-entry-id match-index-entry))
                                             ;; Add sync metadata
                                             (setq sdata `((org-id . ,match-id)
                                                           (org-sync-id . ,match-sync-id)
                                                           ,@sdata))
                                             ;; Bite the webhook and send the processed semantic data
                                             (mrosetta-connector-webhook-bite biting-hook
                                                                              sdata
                                                                              (lambda (did-succeed &rest cbargs)
                                                                                (if did-succeed
                                                                                    (message "Mrosetta Metalanguage match synced successfully!")
                                                                                  (let ((msg (plist-get cbargs :message)))
                                                                                    (message "Mrosetta webhook bite error: %s" msg)))))
                                             ;; Update the org entry itself
                                             (org-entry-put (point) "mrosetta-match-id" (number-to-string match-id))
                                             (org-entry-put (point) "mrosetta-match-sync-id" (number-to-string match-sync-id))))
                                         (setq did-match t)))))))
               ;; Since while always returns nil, surface out the processing result
               did-match)))))
#+END_SRC
***** Update Org Heading
Sync all tracked matches with the specified connector endpoint.

#+NAME: mrosetta-context-org-update-headings
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-update-headings ((context mrosetta-context-org) mlexpression-id sdata)
  "Update all tracked org heading entries of a given MLEXPRESSION-ID within CONTEXT with semantic data contained within SDATA. SDATA is a list of one or more match structures."
  (let* ((mlexpression-index (mrosetta-context-org-db-mlexpression-collection (mrosetta-context-org-index context)))
         (mlexpression-index-entry (mrosetta-context-org-collection-get mlexpression-index mlexpression-id))
         (mlexpression-match-index (mrosetta-context-org-mlexpression-match-collection mlexpression-index-entry))
         (mlexpression-cache (mrosetta-context-org-mlexpressions context))
         (mlexpression (cdr (assq mlexpression-id mlexpression-cache))))
    ;; Iterate over all instances within sdata and update corresponding entries
    (dolist (instance-sdata sdata)
      (let* ((match-id (cdr (assq 'org-id instance-sdata)))
             (match-sync-id (cdr (assq 'org-sync-id instance-sdata)))
             (match-index-entry (mrosetta-context-org-collection-get mlexpression-match-index match-id))
             (match-org-file (mrosetta-context-org-entry-file match-index-entry)))
        ;; Find and update the corresponding org heading
        (mrosetta-context-org-heading-find match-org-file
                                           "mrosetta-match-id"
                                           (number-to-string match-id)
                                           (lambda ()
                                             (let* ((original-text (mrosetta-context-org-heading-get))
                                                    (updated-text (mrosetta-update mlexpression
                                                                                   :text original-text
                                                                                   :sdata instance-sdata)))
                                               ;; Update the heading text
                                               (mrosetta-context-org-heading-set updated-text)
                                               ;; Update the heading properties
                                               (org-entry-put (point) "mrosetta-match-sync-id" (number-to-string match-sync-id))
                                               ;; Update the match index entry
                                               (mrosetta-context-org-match-sync-id-set match-index-entry match-sync-id)
                                               ;; Notify the user
                                               (message "Mrosetta Metalanguage match with id %s updated in file %s!"
                                                        (number-to-string match-id)
                                                        match-org-file))))))))
#+END_SRC
* Configuration Example
An example configuration of Metarosetta within an Emacs configuration file.

#+NAME: config-setup
#+BEGIN_SRC emacs-lisp :noweb yes :session mrosetta-config
<<demo-init>>

<<mrosetta-connector-payload-compile>>
<<mrosetta-connector-payload-decompile>>

<<mrosetta-connector-http-request>>

<<mrosetta-connector-http-listener>>
<<mrosetta-connector-http-listener-start>>
<<mrosetta-connector-http-listener-stop>>
<<mrosetta-connector-http-listener-endpoint-set>>

<<mrosetta-connector-webhook-biting>>
<<mrosetta-connector-webhook-bite>>
<<mrosetta-connector-webhook-biting-am-alive>>
<<mrosetta-connector-webhook-bite-am-alive>>

<<mrosetta-connector-webhook-catching>>
<<mrosetta-connector-webhook-cathing-url>>
<<mrosetta-connector-webhook-catch>>

<<mrosetta-context-org-heading-get>>
<<mrosetta-context-org-heading-set>>
<<mrosetta-context-org-heading-find>>

<<mrosetta-context-org-collection>>
<<mrosetta-context-org-collection-set>>
<<mrosetta-context-org-collection-get>>

<<mrosetta-context-org-entry>>
<<mrosetta-context-org-mlexpression>>
<<mrosetta-context-org-match>>
<<mrosetta-context-org-match-sync-update>>

<<mrosetta-context-org-db>>

<<mrosetta-context-org-compile>>
<<mrosetta-context-org-compile-collection>>
<<mrosetta-context-org-compile-entry>>
<<mrosetta-context-org-compile-mlexpression>>
<<mrosetta-context-org-compile-db>>

<<mrosetta-context-org-decompile>>
<<mrosetta-context-org-decompile-collection>>
<<mrosetta-context-org-decompile-entry>>
<<mrosetta-context-org-decompile-mlexpression>>
<<mrosetta-context-org-decompile-db>>

<<mrosetta-context-org>>
<<mrosetta-context-org-load>>
<<mrosetta-context-org-save>>
<<mrosetta-context-org-start-listening>>
<<mrosetta-context-org-stop-listening>>
<<mrosetta-context-org-process>>
<<mrosetta-context-org-update-headings>>

"Mrosetta components loaded successfully!"
#+END_SRC

#+RESULTS: config-setup
: Mrosetta components loaded successfully!

** Init
Initialize a Metarosetta org context instance with the corresponding connector.

#+NAME: config-init
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(defvar mrosetta-context-org-default (mrosetta-context-org))
#+END_SRC
** Load
Load the context before using it.

#+NAME: config-load
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(mrosetta-context-org-load mrosetta-context-org-default "~/org/mrosetta-index.db")
"Context loaded!"
#+END_SRC
** Save on Exit
Save the current context index before quitting Emacs.

#+NAME: config-save
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(add-hook 'kill-emacs-hook
          (lambda () (mrosetta-context-org-save mrosetta-context-org-default)))
"Hook added!"
#+END_SRC

*** Remove Set Hook
If needed, remove the hook set above

#+NAME: config-save-remove
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(remove-hook 'kill-emacs-hook
             (lambda () (mrosetta-context-org-save mrosetta-context-org-default)))
"Hook removed!"
#+END_SRC
** Start Listening
Start the context listener for incoming webhooks.

#+NAME: config-listener-start
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(mrosetta-context-org-start-listening mrosetta-context-org-default
                                      "lappy.btedeschi.com"
                                      8080)
#+END_SRC
** Stop Listening
Stop the context listener before quitting Emacs.

#+NAME: config-listener-stop
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(add-hook 'kill-emacs-hook
          (lambda () (mrosetta-context-org-stop-listening mrosetta-context-org-default)))
#+END_SRC

*** Remove Set Hook
If needed, remove the hook set above

#+NAME: config-listener-stop-remove
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(remove-hook 'kill-emacs-hook
             (lambda () (mrosetta-context-org-stop-listening mrosetta-context-org-default)))
#+END_SRC
** Process Heading
A simple keymap definition to trigger Metarosetta on a specific org heading.

#+NAME: config-process-heading
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(map! :map org-mode-map
      :localleader
      :desc "Metarosetta Heading"
      :n "m" (cmd! (mrosetta-context-org-process-heading mrosetta-context-org-default)))
"Keymap added!"
#+END_SRC
* Registration
#+NAME: registration
#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'metarosetta)
#+END_SRC
* Footer
#+NAME: footer
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el ends here
#+END_SRC
