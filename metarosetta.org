#+TITLE: Project Metarosetta Emacs Package

* Header
** Name and Definition
#+NAME: title
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el --- A semantically-driven interconnectivity framework -*- lexical-binding: t -*-
#+END_SRC
** Signature
#+NAME: signature
#+BEGIN_SRC emacs-lisp :tangle yes
;; Author: Bruno Tedeschi <me@btedeschi.com>
#+END_SRC
** Summary
#+NAME: summary
#+BEGIN_SRC text
This package adds Metarosetta expression language support to Org-mode.

It enables in-context definition of semantic protocols, within Org-mode, which automatically translate human-input text into a machine-digestible API-compatible structure particular to a given context.

For details and language specification, please refer to the original package documentation and source org file.
#+END_SRC

#+NAME: commentary
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
;;; Commentary:

;; <<summary>>
#+END_SRC
** Code Marker
#+NAME: code-marker
#+BEGIN_SRC emacs-lisp :tangle yes
;;; Code:
#+END_SRC
* Dependencies
#+NAME: dependencies
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'eieio)
#+END_SRC
* The Metalanguage
The metalanguage specification and parser.

** The Expression
An entity defining a particular expression. Using the metalanguage syntax as input, it constructs all underlying logic to parse textual input and structures to map semantic information to machine-readable output.

Designed as an inherently recursive fractal object.

*** Properties
All the properties contained within the expression object. These are of course defined as slots.

**** Definition
The metalanguage-specified definition of the expression in context.

This is stored as a quoted lisp list.

#+NAME: mldefinition
#+BEGIN_SRC emacs-lisp
(mldefinition
 :initarg :mldefinition
 :initform (error "Cannot create an expression without a definition!")
 :type list
 :documentation "The metalanguage-specified definition of the expression in context."
 :reader mrosetta-mldefinition)
#+END_SRC
**** Expression Type
Specifies the exact type of the expression in context.

The property itself is a ~symbol~ indicating the type of the expression.

#+NAME: extype
#+BEGIN_SRC emacs-lisp
(extype
 :type symbol
 :documentation "A symbol specifying the type of the encompassing expression instance. Can be either a :literal, :context, :word or :fractal."
 :reader mrosetta-extype)
#+END_SRC

The following are the possible expression types:

***** Literal Quote
Denotes the simplest expression defining statically quoted text which matches itself within any passed input.

The quote expression type is specified as a ~:literal~.
***** Variable Context
Defines variable context consisting of semantically insignificant text. While this text is unimportant for structured semantics, it remains an intrinsic part of the human-readable form.

These expressions are key in the ability to regenerate the human-readable text with updated semantic information from a machine-generated source. This enables true two-way trans-operability between the human and machine forms.

This type of expression is specified as ~:context~.
***** Matching Word
An expression matching semantically significant information.

A word expression is specified as a ~:word~.
***** Fractal
These are complex expressions consisting of one or more expressions within. Unless the entirety of the input text can be described with a single word expression, the /root/ expression is always a fractal.

In addition, fractals *never* have end values, but can have keys assigned to them matching the fractal-subtree structure contained within.

Such an expression is specified as a ~:fractal~.
**** Fractals
All the fractal elements existing within the encompassing expression instance. Only fractal expression types can contain fractals themselves.

The property itself is a list of ~mrosetta-expression~ instances.

#+NAME: fractals
#+BEGIN_SRC emacs-lisp
(fractals
 :initform '()
 :type list
 :documentation "A list of mrosetta-expression instances contained within the encompassing expression instance."
 :reader mrosetta-fractals)
#+END_SRC
**** Regular Expression Properties
This section contains all the properties pertaining to the encompassing expression's regex, its group keys and resulting matches of the current input, if processed.

***** Regex Keychain
In order to properly parse and distribute regex matches across the fractal expression tree, each expression object needs to have a number identifier unique to the encompassing tree.

To manage this, each tree has a single /keychain/ instance shared across all expression objects within a single fractal tree.

#+NAME: rkeychain
#+BEGIN_SRC emacs-lisp
(rkeychain
 :initarg :rkeychain
 :initform (mrosetta-keychain)
 :type mrosetta-keychain
 :documentation "The regex keychain instance managing keys for the encompassing expression tree."
 :reader mrosetta-rkeychain)
#+END_SRC

****** The Keychain
Key management is encapsulated within a simple keychain class which holds all generated keys, their respective assignments and is of course capable of generating keys unique within a single instance of the keychain object.

******* Class Definition
The class itself is designed as a no-argument constructor as the key generator is automatically initialized upon creation.

#+NAME: mrosetta-keychain
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-keychain ()
  ((lastkey
    :initform '0
    :type number
    :documentation "The last key generated and assigned to a group within the context of a single instance."
    :reader mrosetta-lastkey)
   (keys
    :initform '()
    :type list
    :documentation "A property list containing all the generated keys and corresponding references of respectively assigned objects."
    :reader mrosetta-keys))
  "A regex group key generator and manager.")
#+END_SRC
******* Behavior
This section covers all defined behavior for the keychain class.

******** Generate Key
Register for a new key with a particular expression instance.

#+NAME: mrosetta-generate-rkey
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-generate-rkey ((keychain mrosetta-keychain) mlexpression)
  "Register for a new key with a particular MLEXPRESSION instance within a provided KEYCHAIN."
  (let ((key (+ 1 (slot-value keychain 'lastkey))))
    (setf (slot-value keychain 'keys) (plist-put (slot-value keychain 'keys) key mlexpression))
    (setf (slot-value keychain 'lastkey) key)))
#+END_SRC
***** Regex Key
The regex group key awarded to the encompassing expression instance.

#+NAME: rkey
#+BEGIN_SRC emacs-lisp
(rkey
 :type number
 :documentation "The regex matching group key for the encompassing expression instance."
 :reader mrosetta-rkey)
#+END_SRC
***** Regular Expression
The compiled regular expression of the expression in context.

This is the regex used under the hood when parsing through human-readable input.

#+NAME: regex
#+BEGIN_SRC emacs-lisp
(regex
 :type string
 :documentation "The compiled regular expression of the expression in context."
 :reader mrosetta-regex)
#+END_SRC
***** Regex Match
If input is processed, this property contains the regular expression match for the encompassing expression instance.

The match is in raw text form.

#+NAME: rmatch
#+BEGIN_SRC emacs-lisp
(rmatch
 :type string
 :documentation "The textual match of the encompassing expression within the currently set input."
 :reader mrosetta-rmatch)
#+END_SRC
**** Key
The property key to which the expression output value is assigned, if the expression itself is denoted as such.

#+NAME: key
#+BEGIN_SRC emacs-lisp
(key
 :initform 'nil
 :type (or null string)
 :documentation "The property key to which the expression output value is assigned, if any. Either a string or nil."
 :reader mrosetta-key)
#+END_SRC
**** Value
If the encompassing expression instance outputs an end value, this property contains the value within the currently set input text.

The property itself is either a string representation of the singular value, or a list of matched values, if the expression is marked as plural.

#+NAME: value
#+BEGIN_SRC emacs-lisp
(value
 :type (or string list)
 :documentation "The output value matching the encompassing expression instance within the currently set input."
 :reader mrosetta-value)
#+END_SRC
**** Specifier Properties
All specifier parameters defined for the encompassing expression instance.

***** Uppercase
Match only uppercase words.

#+NAME: is-uppercase
#+BEGIN_SRC emacs-lisp
(is-upparcase
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only uppercase words. Either non-nil or nil."
 :reader mrosetta-is-uppercase)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: is-capitalized
#+BEGIN_SRC emacs-lisp
(is-capitalized
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only capitalized words. Either non-nil or nil."
 :reader mrosetta-is-capitalized)
#+END_SRC
***** Content
Match only words containing specific characters or substrings.

#+NAME: match-substring
#+BEGIN_SRC emacs-lisp
(match-substring
 :initform 'nil
 :type (or null string)
 :documentation "Specifies a specific substring all possible expression matches should contain, if any. Either a string or nil."
 :reader mrosetta-match-substring)
#+END_SRC
***** Boundary Properties
Specifies whether the match of the encompassing expression has static left or right boundaries.

****** Left Boundary
Specifies a statically set match prefix, if the expression defines one.

#+NAME: match-prefix
#+BEGIN_SRC emacs-lisp
(match-prefix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the prefix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-prefix)
#+END_SRC
****** Right Boundary
Specifies a statically set match suffix, if the expression defines one.

#+NAME: match-suffix
#+BEGIN_SRC emacs-lisp
(match-suffix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the suffix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-suffix)
#+END_SRC
***** Literal
Match only and exactly the literal text specified here.

This slot is only used in ~:literal~ expressions.

#+NAME: match-literal
#+BEGIN_SRC emacs-lisp
(match-literal
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the literal string that the expression maches exclusively. Either a string or nill."
 :reader mrosetta-match-literal)
#+END_SRC
**** Modifier Properties
Modifier properties defined for the encompassing expression instance.

Modifiers are useful when matched text needs to be formatted and /normalized/ before being structured within the machine-digestible output.

***** Uppercase
Indicates whether matched text needs to be uppercased.

#+NAME: should-uppercase
#+BEGIN_SRC emacs-lisp
(should-uppercase
 :initform 'nil
 :documentation "Specifies whether the original encompassing expression match should get uppercased."
 :reader mrosetta-should-uppercase)
#+END_SRC
***** Lowercase
Indicates whether matched text needs to be lowercased.

#+NAME: should-lowercase
#+BEGIN_SRC emacs-lisp
(should-lowercase
 :initform 'nil
 :documentation "Specifies whether the original encompassing expression match should get lowercased."
 :reader mrosetta-should-lowercase)
#+END_SRC
**** Plurality
If the expression defines a plural match, then the ~value~ property is in list form and this property is non-nil.

#+NAME: has-plural-value
#+BEGIN_SRC emacs-lisp
(has-plural-value
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches plural values or just a single one. Either nil or non-nil."
 :reader mrosetta-has-plural-value)
#+END_SRC
**** Optionality
Specifies whether the entire expression and its fractals within (if any) are optional in presence.

#+NAME: is-optional
#+BEGIN_SRC emacs-lisp
(is-optional
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is optional to match within input text. Either non-nil or nil."
 :reader mrosetta-is-optional)
#+END_SRC
*** Class Definition
The /expression/ class is defined below, containing all the properties listed above.

#+NAME: mrosetta-mlexpression
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defclass mrosetta-mlexpression ()
  (
   <<mldefinition>>
   <<extype>>
   <<fractals>>
   <<rkeychain>>
   <<rkey>>
   <<regex>>
   <<rmatch>>
   <<key>>
   <<value>>
   <<is-uppercase>>
   <<is-capitalized>>
   <<match-substring>>
   <<match-prefix>>
   <<match-suffix>>
   <<match-literal>>
   <<should-uppercase>>
   <<should-lowercase>>
   <<has-plural-value>>
   <<is-optional>>
  )
  "The Metarosetta Expression object used to define a contextual translational expression for semantic processing.")
#+END_SRC
** The Specification
The purpose of the language is to facilitate expressions which unambiguously define a translation protocol between human-readable text and machine-digestible data structures, with the semantics completely preserved, based on an arbitrarily defined pattern of human input within a specific context.

All keywords within the specification are stored as symbols which map to their respective parse functions.

#+NAME: mrosetta-mlsyntax
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax '())
#+END_SRC

*** Literal Quote
The simplest expression defining statically quoted text which should appear literally within input text.

#+NAME: mrosetta-parse-literal
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-literal ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the :right arg content within ARGS as a literal quote into the MLEXPRESSION instance in context."
  (let ((literal-quote (plist-get args :right)))
    (when (eq literal-quote nil)
      (error "Metalanguage syntax error: Literal expression without quoted content"))
    (setf (slot-value mlexpression 'extype) :literal)
    (setf (slot-value mlexpression 'match-literal) literal-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage itself defines this expression through the ~literally~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-literal-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(literally . mrosetta-parse-literal) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-literal-example
#+BEGIN_SRC text
(literally "Status Update:")
#+END_SRC
*** Word
An expression used to capture a variable word from within input text.

#+NAME: mrosetta-parse-word
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :word)
  args)
#+END_SRC

The metalanguage defines this expression through the ~word~ keyword.

#+NAME: mrosetta-parse-word-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(word . mrosetta-parse-word) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-example
#+BEGIN_SRC text
(word)
#+END_SRC

**** Word Specifiers
In addition to the ability to match any kind of word, the metalanguage specification also supports matching only specific words based on different criteria.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-parse-word-uppercase
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-uppercase ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse an uppercase word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-uppercase) t)
  (mrosetta-parse-word mlexpression args))
#+END_SRC

The metalanguage defines this expression through the ~WORD~ keyword. Note that the metalanguage syntax is case-sensitive, where case is also part of the syntax itself.

#+NAME: mrosetta-parse-word-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(WORD . mrosetta-parse-word-uppercase) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-uppercase-example
#+BEGIN_SRC text
(WORD)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-parse-word-capitalized
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-capitalized ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a capitalized word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-capitalized) t)
  (mrosetta-parse-word mlexpression args))
#+END_SRC

The metalanguage defines this expression through the ~Word~ keyword.

#+NAME: mrosetta-parse-word-capitalized-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(Word . mrosetta-parse-word-capitalized) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-capitalized-example
#+BEGIN_SRC text
(Word)
#+END_SRC
***** Specific Content
Match only the words containing specific characters or content.

#+NAME: mrosetta-parse-word-content
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-content ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :right arg within ARGS as matching word content into the MLEXPRESSION instance in context."
  (let ((substring-quote (plist-get args :right)))
    (when (eq substring-quote nil)
      (error "Metalanguage syntax error: Substring match expression without quoted content"))
    (setf (slot-value mlexpression 'match-substring) substring-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines this expression through the ~with~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-word-content-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(with . mrosetta-parse-word-content) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-content-example
#+BEGIN_SRC text
(word with "-")
#+END_SRC
**** Word Boundaries
Match only words with the specified prefix or suffix. Note that the prefix or suffix itself isn't part of the match.

***** Prefix
Match only words prefixed with the supplied quoted content.

#+NAME: mrosetta-parse-word-prefix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-prefix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching word prefix into the MLEXPRESSION instance in context."
  (let ((prefix-quote (plist-get args :left)))
    (when (eq prefix-quote nil)
      (error "Metalanguage syntax error: Prefix match expression without quoted content"))
    (setf (slot-value mlexpression 'match-prefix) prefix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~prefixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-word-prefix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(prefixed . mrosetta-parse-word-prefix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-prefix-example
#+BEGIN_SRC text
("#" prefixed word)
#+END_SRC
***** Suffix
Match only words suffixed with the supplied quoted content.

#+NAME: mrosetta-parse-word-suffix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-suffix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching word suffix into the MLEXPRESSION instance in context."
  (let ((suffix-quote (plist-get args :left)))
    (when (eq suffix-quote nil)
      (error "Metalanguage syntax error: Suffix match expression without quoted content"))
    (setf (slot-value mlexpression 'match-suffix) suffix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~suffixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-word-suffix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(suffixed . mrosetta-parse-word-suffix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-suffix-example
#+BEGIN_SRC text
(";" suffixed word)
#+END_SRC
**** Word Modifiers
Modify captured words before structured output.

Modifiers are defined as contextual arguments succeeding the general modifier keyword.

#+NAME: mrosetta-mlsyntax-modifiers
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax-modifiers '())
#+END_SRC

***** Uppercase
Transform captured words to uppercase format.

To do so, use the ~uppercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-word-modifier-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(uppercase . should-uppercase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-modifier-uppercase-example
#+BEGIN_SRC text
(word to uppercase)
#+END_SRC
***** Lowercase
Transform captured words to lowercase format.

To do so, use the ~lowercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-word-modifier-lowercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(lowercase . should-lowercase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-modifier-lowercase-example
#+BEGIN_SRC text
(word to lowercase)
#+END_SRC
***** Modifier Argument Parser
All modifier contextual arguments are handled by a central modifier parser.

#+NAME: mrosetta-parse-word-modifier
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-modifier ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the modifier symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((modifier-symbol (plist-get args :right)))
    (when (eq modifier-symbol nil)
      (error "Metalanguage syntax error: Modifier expression without contextual argument symbol"))
    (setf (slot-value mlexpression (cdr (assq modifier-symbol mrosetta-mlsyntax-modifiers))) t))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the modifier context through the ~to~ keyword followed by the contextual arguments listed above.

#+NAME: mrosetta-parse-word-modifier-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(to . mrosetta-parse-word-modifier) mrosetta-mlsyntax)
#+END_SRC
**** Word Plurality
Instead of a single value, capture all values matching defined criteria within the encompassing expression context.

#+NAME: mrosetta-parse-word-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural words expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'has-plural-value) t)
  (mrosetta-parse-word mlexpression args))
#+END_SRC

The metalanguage defines this expression through the ~words~ keyword.

#+NAME: mrosetta-parse-word-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(words . mrosetta-parse-word-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-word-plurality-example
#+BEGIN_SRC text
(words)
#+END_SRC
*** Optionality
Specify whether the encompassing expression should be considered as an optional, or required match.

Input text without an optional expression match still gets processed, structured and output. Any input not matching all mandatory expressions is disregarded.

All defined expressions are considered as mandatory by default.

#+NAME: mrosetta-parse-optionality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-optionality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse expression optionality into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-optional) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~optional~ keyword.

#+NAME: mrosetta-parse-optionality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(optional . mrosetta-parse-optionality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-optionality-example
#+BEGIN_SRC text
(optional word)
#+END_SRC
*** Assignment
Assign a key to the resulting value of the encompassing expression.

#+NAME: mrosetta-parse-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-key ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the key symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((key-symbol (plist-get args :right)))
    (when (eq key-symbol nil)
      (error "Metalanguage syntax error: Key assignment without contextual key symbol"))
    (setf (slot-value mlexpression 'key) key-symbol))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the assignment expression through the ~as~ keyword followed by the key symbol.

#+NAME: mrosetta-parse-key-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(as . mrosetta-parse-key) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-key-example
#+BEGIN_SRC text
(word as a_property)
#+END_SRC
* Contexts
** Org
* Connectors
** Coda
* Registration
#+NAME: registration
#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'metarosetta)
#+END_SRC
* Footer
#+NAME: footer
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el ends here
#+END_SRC
