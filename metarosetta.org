#+TITLE: Project Metarosetta Emacs Package

* Header
** Name and Definition
#+NAME: title
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el --- A semantically-driven interconnectivity framework -*- lexical-binding: t -*-
#+END_SRC
** Signature
#+NAME: signature
#+BEGIN_SRC emacs-lisp :tangle yes
;; Author: Bruno Tedeschi <me@btedeschi.com>
#+END_SRC
** Summary
#+NAME: summary
#+BEGIN_SRC text
This package adds Metarosetta expression language support to Org-mode.

It enables in-context definition of semantic protocols, within Org-mode, which automatically translate human-input text into a machine-digestible API-compatible structure particular to a given context.

For details and language specification, please refer to the original package documentation and source org file.
#+END_SRC

#+NAME: commentary
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
;;; Commentary:

;; <<summary>>
#+END_SRC
** Code Marker
#+NAME: code-marker
#+BEGIN_SRC emacs-lisp :tangle yes
;;; Code:
#+END_SRC
* Dependencies
#+NAME: dependencies
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'eieio)
#+END_SRC

* The Metalanguage
The metalanguage specification and parser.

** The Expression Object
An entity defining a particular expression. Using the metalanguage syntax as input, it constructs all underlying logic to parse textual input and structures to map semantic information to machine-readable output.

Designed as an inherently recursive fractal object.

*** Properties
All the properties contained within the expression object. These are of course defined as slots.

**** Definition
The metalanguage-specified definition of the expression in context.

This is stored as a quoted lisp list.

#+NAME: mldefinition
#+BEGIN_SRC emacs-lisp
(mldefinition
 :initarg :mldefinition
 :type list
 :documentation "The metalanguage-specified definition of the expression in context."
 :reader mrosetta-mldefinition)
#+END_SRC
**** Expression Type
Specifies the exact type of the expression in context.

The property itself is a ~symbol~ indicating the type of the expression.

#+NAME: extype
#+BEGIN_SRC emacs-lisp
(extype
 :type symbol
 :documentation "A symbol specifying the type of the encompassing expression instance. Can be either a :literal, :match or :fractal."
 :reader mrosetta-extype)
#+END_SRC

The following are the possible expression types:

***** Literal Quote
Denotes the simplest expression defining statically quoted text which matches itself within any passed input.

The quote expression type is specified as a ~:literal~.
***** Match
An expression matching semantically significant information. These are either words or paragraphs of captured text.

A match expression is specified as a ~:match~.
***** Fractal
An expression matching a sequence of its nested child expressions.

A fractal expression is specified as a ~:fractal~.
**** Fractals
All the fractal elements existing within the encompassing expression instance. Only ~:fractal~ instances can contain sub-expressions themselves.

The property itself is a list of ~mrosetta-expression~ instances.

#+NAME: fractals
#+BEGIN_SRC emacs-lisp
(fractals
 :initform '()
 :type list
 :documentation "A list of mrosetta-expression instances contained within the encompassing expression instance."
 :reader mrosetta-fractals)
#+END_SRC
**** Regular Expression Properties
This section contains all the properties pertaining to the encompassing expression's regex, its group keys and resulting matches of the current input, if processed.

***** Regex Keychain
In order to properly parse and distribute regex matches across the fractal expression tree, each expression object needs to have a number identifier unique to the encompassing tree.

To manage this, each tree has a single /keychain/ instance shared across all expression objects within a single fractal tree.

#+NAME: rkeychain
#+BEGIN_SRC emacs-lisp
(rkeychain
 :initarg :rkeychain
 :initform (mrosetta-keychain)
 :type mrosetta-keychain
 :documentation "The regex keychain instance managing keys for the encompassing expression tree."
 :reader mrosetta-rkeychain)
#+END_SRC

****** The Keychain
Key management is encapsulated within a simple keychain class which holds all generated keys, their respective assignments and is of course capable of generating keys unique within a single instance of the keychain object.

******* Class Definition
The class itself is designed as a no-argument constructor as the key generator is automatically initialized upon creation.

#+NAME: mrosetta-keychain
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-keychain ()
  ((lastkey
    :initform '0
    :type number
    :documentation "The last key generated and assigned to a group within the context of a single keychain instance."
    :reader mrosetta-lastkey))
  "A regex group key generator.")
#+END_SRC

******* Behavior
This section covers all defined behavior for the keychain class.

******** Generate Key
Register for a new key with a particular expression instance.

#+NAME: mrosetta-generate-regex-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-generate-regex-key ((keychain mrosetta-keychain))
  "Generate a new key within a provided KEYCHAIN."
  (let ((key (+ 1 (slot-value keychain 'lastkey))))
    (setf (slot-value keychain 'lastkey) key)))
#+END_SRC

***** Regular Expression
The compiled regular expression of the metalanguage expression in context.

This is the regex used under the hood when parsing through human-readable input.

#+NAME: regex
#+BEGIN_SRC emacs-lisp
(regex
 :type string
 :documentation "The compiled regular expression of the expression in context."
 :reader mrosetta-regex)
#+END_SRC

In addition, each match-extracting regular expression has a corresponding group key by which the respective match is extracted.

#+NAME: regex-key
#+BEGIN_SRC emacs-lisp
(regex-key
 :type number
 :documentation "The regex matching group key for the encompassing expression instance."
 :reader mrosetta-regex-key)
#+END_SRC

Since the metalanguage supports plural matches of enumerable text clauses, an additional regular expression is required in order to capture a single instance of such clauses. In cases of single-matching expressions, ~regex~ is equivalent to ~rinstance~.

#+NAME: rinstance
#+BEGIN_SRC emacs-lisp
(rinstance
 :type string
 :documentation "The compiled regular expression matching a single instance of a possibly plural-matching expression."
 :reader mrosetta-rinstance)
#+END_SRC

#+NAME: rinstance-key
#+BEGIN_SRC emacs-lisp
(rinstance-key
 :type number
 :documentation "The regex group key for matching a single instance of a possibly plural-matching metalanguage expression in context."
 :reader mrosetta-rinstance-key)
#+END_SRC

****** Base
The foundational element from which the matching regular expression is constructed.

#+NAME: rbase
#+BEGIN_SRC emacs-lisp
(rbase
 :type string
 :documentation "The regular expression used as a foundational base in compilation of the match-extracting regular expression."
 :reader mrosetta-rbase)
#+END_SRC
****** Match
The regular expression of the match itself.

#+NAME: rmatch
#+BEGIN_SRC emacs-lisp
(rmatch
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression of the encompassing expression's semantic match."
 :reader mrosetta-rmatch)
#+END_SRC

The regex is paired with its group key used for match extraction.

#+NAME: rmatch-key
#+BEGIN_SRC emacs-lisp
(rmatch-key
 :initform 'nil
 :type (or null number)
 :documentation "The regex group key for the encompassing expression's output value match."
 :reader mrosetta-rmatch-key)
#+END_SRC
****** Prefix
The regular expression used for matching a specified prefix of the expression in context, if any.

#+NAME: rprefix
#+BEGIN_SRC emacs-lisp
(rprefix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified prefix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-rprefix)
#+END_SRC
****** Suffix
The regular expression used for matching a specified suffix of the expression in context, if any.

#+NAME: rsuffix
#+BEGIN_SRC emacs-lisp
(rsuffix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified suffix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-rsuffix)
#+END_SRC
****** Regex Boundaries
Regular expressions used for regex-specific boundaries around the match.

******* Left Boundary
The regular expression used for defining the left boundary of the match.

#+NAME: left-rboundary
#+BEGIN_SRC emacs-lisp
(left-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The left regex-specific boundary defining the beginning of the match."
 :reader mrosetta-left-rboundary)
#+END_SRC
******* Right Boundary
The regular expression used for defining the right boundary of the match.

#+NAME: right-rboundary
#+BEGIN_SRC emacs-lisp
(right-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The right regex-specific boundary defining the end of the match."
 :reader mrosetta-right-rboundary)
#+END_SRC
****** Surrounding Buffers
Regular expressions used for matching buffer characters surrounding the match.

By default, these are /whitespace/ characters between words and used purely for original text reconstruction with updated semantics.

#+NAME: rbuffer
#+BEGIN_SRC emacs-lisp
(rbuffer
 :initform "[[:blank:]]*"
 :type string
 :documentation "The regular expression matching buffer characters surrounding the encompassing expression."
 :reader mrosetta-rbuffer)
#+END_SRC

******* Left Buffer
The regular expression group key for the left buffer.

#+NAME: left-rbuffer-key
#+BEGIN_SRC emacs-lisp
(left-rbuffer-key
 :type number
 :documentation "The regex group key for the encompassing expression's left buffer match."
 :reader mrosetta-left-rbuffer-key)
#+END_SRC
******* Right Buffer
The regular expression group key for the right buffer.

#+NAME: right-rbuffer-key
#+BEGIN_SRC emacs-lisp
(right-rbuffer-key
 :type number
 :documentation "The regex group key for the encompassing expression's right buffer match."
 :reader mrosetta-right-rbuffer-key)
#+END_SRC
**** Key
The property key to which the expression output value is assigned, if the expression itself is denoted as such.

#+NAME: key
#+BEGIN_SRC emacs-lisp
(key
 :initform 'nil
 :type (or null symbol)
 :documentation "The property key to which the expression output value is assigned, if any. Either a string or nil."
 :reader mrosetta-key)
#+END_SRC
**** Specifier Properties
All specifier parameters defined for the encompassing expression instance.

***** Uppercase
Match only uppercase words.

#+NAME: is-uppercase
#+BEGIN_SRC emacs-lisp
(is-uppercase
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only uppercase words. Either non-nil or nil."
 :reader mrosetta-is-uppercase)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: is-capitalized
#+BEGIN_SRC emacs-lisp
(is-capitalized
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only capitalized words. Either non-nil or nil."
 :reader mrosetta-is-capitalized)
#+END_SRC
***** Boundary Properties
Specifies whether the match of the encompassing expression has static left or right boundaries.

****** Left Boundary
Specifies a statically set match prefix, if the expression defines one.

#+NAME: match-prefix
#+BEGIN_SRC emacs-lisp
(match-prefix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the prefix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-prefix)
#+END_SRC
****** Right Boundary
Specifies a statically set match suffix, if the expression defines one.

#+NAME: match-suffix
#+BEGIN_SRC emacs-lisp
(match-suffix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the suffix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-suffix)
#+END_SRC
***** Content
Match only words containing specific characters or substrings.

#+NAME: match-substring
#+BEGIN_SRC emacs-lisp
(match-substring
 :initform 'nil
 :type (or null string)
 :documentation "Specifies a specific substring all possible expression matches should contain, if any. Either a string or nil."
 :reader mrosetta-match-substring)
#+END_SRC
***** Literal
Match only and exactly the literal text specified here.

This slot is only used in ~:literal~ expressions.

#+NAME: match-literal
#+BEGIN_SRC emacs-lisp
(match-literal
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the literal string that the expression maches exclusively. Either a string or nill."
 :reader mrosetta-match-literal)
#+END_SRC
***** Contextual
Elastically match a region of text depending on neighboring elements.

This slot is only used in ~paragraph~ ~:match~ expressions since paragraphs match any and all text, either based on specific criteria, such as explicit boundaries, or on neighboring matches which act as contextual criteria.

#+NAME: is-contextual
#+BEGIN_SRC emacs-lisp
(is-contextual
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is matched elastically depending on neighboring elements. Either non-nil or nil."
 :reader mrosetta-is-contextual)
#+END_SRC
**** Modifier
Modifiers are useful when matched text needs to be formatted and /normalized/ before being structured within the machine-digestible output.

A modifier property is defined as a symbol referencing a stored function capable of a particular modification, like ~upcase~ for uppercasing the entirety of the output, or ~downcase~ for lowercasing.

#+NAME: modifier
#+BEGIN_SRC emacs-lisp
(modifier
 :initform 'nil
 :type (or null symbol)
 :documentation "Specifies a symbol referencing a stored modifier function, if any. Either a symbol or nil."
 :reader mrosetta-modifier)
#+END_SRC
**** Optionality
Specifies whether the entire expression and its fractals within (if any) are optional in presence.

#+NAME: is-optional
#+BEGIN_SRC emacs-lisp
(is-optional
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is optional to match within input text. Either non-nil or nil."
 :reader mrosetta-is-optional)
#+END_SRC
**** Ignorables
Specifies whether the encompassing expression should be disregarded in structured output. Ignorable expressions are matched but never included in structured semantic output.

#+NAME: should-ignore
#+BEGIN_SRC emacs-lisp
(should-ignore
 :initform 'nil
 :documentation "Specifies whether the encompassing expression should be matched but disregarded in output. Either non-nil or nil."
 :reader mrosetta-should-ignore)
#+END_SRC
**** Plurality
If the expression defines a plural match, then the output value is in list form and this property is non-nil.

#+NAME: is-plural
#+BEGIN_SRC emacs-lisp
(is-plural
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches plural values or just a single one. Either nil or non-nil."
 :reader mrosetta-is-plural)
#+END_SRC
*** Class Definition
The /expression/ class is defined below, containing all the properties listed above.

#+NAME: mrosetta-mlexpression
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defclass mrosetta-mlexpression ()
  (
   <<mldefinition>>
   <<extype>>
   <<fractals>>
   <<rkeychain>>
   <<regex>>
   <<regex-key>>
   <<rinstance>>
   <<rinstance-key>>
   <<rbase>>
   <<rmatch>>
   <<rmatch-key>>
   <<rprefix>>
   <<rsuffix>>
   <<left-rboundary>>
   <<right-rboundary>>
   <<rbuffer>>
   <<left-rbuffer-key>>
   <<right-rbuffer-key>>
   <<key>>
   <<is-uppercase>>
   <<is-capitalized>>
   <<match-prefix>>
   <<match-suffix>>
   <<match-substring>>
   <<match-literal>>
   <<is-contextual>>
   <<modifier>>
   <<is-optional>>
   <<should-ignore>>
   <<is-plural>>
  )
  "The Metarosetta Expression object used to define a contextual translational expression for semantic processing.")
#+END_SRC

** Language Specification
The purpose of the language is to facilitate expressions which unambiguously define a translation protocol between human-readable text and machine-digestible data structures, with the semantics completely preserved, based on an arbitrarily defined pattern of human input within a specific context.

All keywords within the specification are stored as symbols which map to their respective parse functions.

#+NAME: mrosetta-mlsyntax
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax '())
#+END_SRC

*** Literal Quote
The simplest expression defining statically quoted text which should appear literally within input text.

#+NAME: mrosetta-parse-literal
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-literal ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the :right arg content within ARGS as a literal quote into the MLEXPRESSION instance in context."
  (let ((literal-quote (plist-get args :right)))
    (when (eq literal-quote nil)
      (error "Metalanguage syntax error: Literal expression without quoted content"))
    (setf (slot-value mlexpression 'extype) :literal)
    (setf (slot-value mlexpression 'rbase) (regexp-quote literal-quote))
    (setf (slot-value mlexpression 'match-literal) literal-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage itself defines this expression through the ~literal~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-literal-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(literal . mrosetta-parse-literal) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-literal-example
#+BEGIN_SRC text
(literal "Status Update:")
#+END_SRC
*** Word
An expression used to capture a variable word from within input text.

#+NAME: mrosetta-parse-word
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'left-rboundary) "\\<")
  (setf (slot-value mlexpression 'rbase) "[[:word:]]+")
  (setf (slot-value mlexpression 'right-rboundary) "\\>")
  args)
#+END_SRC

The metalanguage defines this expression through the ~word~ keyword.

#+NAME: mrosetta-parse-word-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(word . mrosetta-parse-word) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-example
#+BEGIN_SRC text
(word)
#+END_SRC

**** Word Specifiers
In addition to the ability to match any kind of word, the metalanguage specification also supports matching only specific words based on different criteria.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-parse-word-uppercase
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-uppercase ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse an uppercase word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9]+")
  (setf (slot-value mlexpression 'is-uppercase) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~WORD~ keyword. Note that the metalanguage syntax is case-sensitive, where case is also part of the syntax itself.

#+NAME: mrosetta-parse-word-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(WORD . mrosetta-parse-word-uppercase) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-uppercase-example
#+BEGIN_SRC text
(WORD)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-parse-word-capitalized
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-capitalized ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a capitalized word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9][a-z0-9]+")
  (setf (slot-value mlexpression 'is-capitalized) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~Word~ keyword.

#+NAME: mrosetta-parse-word-capitalized-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(Word . mrosetta-parse-word-capitalized) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-capitalized-example
#+BEGIN_SRC text
(Word)
#+END_SRC
**** Word Plurality
Instead of a single value, capture all value occurrences matching defined criteria within the encompassing expression context.

#+NAME: mrosetta-parse-word-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural words expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~words~ keyword.

#+NAME: mrosetta-parse-word-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(words . mrosetta-parse-word-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-word-plurality-example
#+BEGIN_SRC text
(words)
#+END_SRC
*** Paragraph
An expression used to capture a variable paragraph from within input text.

A paragraph is considered all text within specified boundaries. If no boundaries are set, the entire input is matched.

#+NAME: mrosetta-parse-paragraph
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a paragraph epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) (concat ".+?"))
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraph~ keyword.

#+NAME: mrosetta-parse-paragraph-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraph . mrosetta-parse-paragraph) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-paragraph-example
#+BEGIN_SRC text
(paragraph)
#+END_SRC

**** Paragraph Plurality
Like words, it's possible to capture multiple paragraph occurrences matching the expression-defined criteria.

Note that this construct only makes sense if paragraphs are clearly bounded.

#+NAME: mrosetta-parse-paragraph-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural paragraph expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-paragraph mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraphs~ keyword.

#+NAME: mrosetta-parse-paragraph-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraphs . mrosetta-parse-paragraph-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-paragraph-plurality-example
#+BEGIN_SRC text
(";" suffixed paragraphs)
#+END_SRC
*** Specifiers
**** Content Specifier
Match only elements containing specific characters or content.

#+NAME: mrosetta-parse-substring
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-substring ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :right arg within ARGS as matching element substring into the MLEXPRESSION instance in context."
  (let* ((substring-quote (plist-get args :right))
         (rsubstring-quote (regexp-quote substring-quote))
         (rbase (slot-value mlexpression 'rbase)))
    (when (eq substring-quote nil)
      (error "Metalanguage syntax error: Substring match expression without quoted content"))
    (setf (slot-value mlexpression 'rmatch)
          (concat "\\(?:"
                  "\\(?:" rsubstring-quote "\\)?" rbase "\\(?:" rsubstring-quote "\\(?:" rbase "\\)?" "\\)+"
                  "\\|"
                  "\\(?:" "\\(?:" rbase "\\)?" rsubstring-quote "\\)+" rbase "\\(?:" rsubstring-quote "\\)?"
                  "\\)"))
    (setf (slot-value mlexpression 'match-substring) substring-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines this expression through the ~with~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-substring-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(with . mrosetta-parse-substring) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-substring-example
#+BEGIN_SRC text
(word with "-")
#+END_SRC
**** Boundaries
Match only elements with the specified prefix or suffix. Note that the prefix or suffix itself isn't part of the match.

***** Prefix
Match only elements prefixed with the supplied quoted content.

#+NAME: mrosetta-parse-prefix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-prefix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element prefix into the MLEXPRESSION instance in context."
  (let ((prefix-quote (plist-get args :left)))
    (when (eq prefix-quote nil)
      (error "Metalanguage syntax error: Prefix match expression without quoted content"))
    (setf (slot-value mlexpression 'rprefix) (regexp-quote prefix-quote))
    (setf (slot-value mlexpression 'match-prefix) prefix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~prefixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-prefix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(prefixed . mrosetta-parse-prefix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-prefix-example
#+BEGIN_SRC text
("#" prefixed word)
#+END_SRC
***** Suffix
Match only elements suffixed with the supplied quoted content.

#+NAME: mrosetta-parse-suffix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-suffix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element suffix into the MLEXPRESSION instance in context."
  (let ((suffix-quote (plist-get args :left)))
    (when (eq suffix-quote nil)
      (error "Metalanguage syntax error: Suffix match expression without quoted content"))
    (setf (slot-value mlexpression 'rsuffix) (regexp-quote suffix-quote))
    (setf (slot-value mlexpression 'match-suffix) suffix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~suffixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-suffix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(suffixed . mrosetta-parse-suffix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-suffix-example
#+BEGIN_SRC text
(";" suffixed word)
#+END_SRC
**** Contextual
Match elements based on contextual criteria of neighboring matches. Note that a contextual specifier is only applicable to ~paragraph~ expressions.

#+NAME: mrosetta-parse-contextual
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-contextual ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the contextual specifier into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-contextual) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~contextual~ keyword.

#+NAME: mrosetta-parse-contextual-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(contextual . mrosetta-parse-contextual) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-contextual-example
#+BEGIN_SRC text
(contextual paragraph)
#+END_SRC
*** Modifiers
Modify captured elements before structured output.

Modifiers are defined as contextual arguments succeeding the general modifier keyword.

#+NAME: mrosetta-mlsyntax-modifiers
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax-modifiers '())
#+END_SRC

**** Uppercase
Transform captured elements to uppercase format.

To do so, use the ~uppercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(uppercase . upcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-uppercase-example
#+BEGIN_SRC text
(word to uppercase)
#+END_SRC
**** Lowercase
Transform captured elements to lowercase format.

To do so, use the ~lowercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-lowercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(lowercase . downcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-lowercase-example
#+BEGIN_SRC text
(word to lowercase)
#+END_SRC
**** Modifier Argument Parser
All modifier contextual arguments are handled by a central modifier parser.

#+NAME: mrosetta-parse-modifier
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-modifier ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the modifier symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((modifier-symbol (plist-get args :right)))
    (when (eq modifier-symbol nil)
      (error "Metalanguage syntax error: Modifier expression without contextual argument symbol"))
    (setf (slot-value mlexpression 'modifier)
          (cdr (assq modifier-symbol mrosetta-mlsyntax-modifiers))))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the modifier context through the ~to~ keyword followed by the contextual arguments listed above.

#+NAME: mrosetta-parse-modifier-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(to . mrosetta-parse-modifier) mrosetta-mlsyntax)
#+END_SRC

*** Optionality
Specify whether the encompassing expression should be considered as an optional, or required match.

Input text without an optional expression match still gets processed, structured and output. Any input not matching all mandatory expressions is disregarded.

All defined expressions are considered as mandatory by default.

#+NAME: mrosetta-parse-optionality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-optionality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse expression optionality into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-optional) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~optional~ keyword.

#+NAME: mrosetta-parse-optionality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(optional . mrosetta-parse-optionality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-optionality-example
#+BEGIN_SRC text
(optional word)
#+END_SRC
*** Assignment
Assign a key to the resulting value of the encompassing expression.

#+NAME: mrosetta-parse-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-key ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the key symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((key-symbol (plist-get args :right)))
    (when (eq key-symbol nil)
      (error "Metalanguage syntax error: Key assignment without contextual key symbol"))
    (setf (slot-value mlexpression 'key) key-symbol))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the assignment expression through the ~as~ keyword followed by the key symbol.

#+NAME: mrosetta-parse-key-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(as . mrosetta-parse-key) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-key-example
#+BEGIN_SRC text
(word as a_property)
#+END_SRC
*** Ignorables
Specify whether the encompassing expression should be ignored from structured output. As noted above, ignorable expressions are matched but never included in structured semantic output.

Ignorables are considered as semantically insignificant text occurring before and after the semantic match itself.

While this text is unimportant for structured semantics, it remains an intrinsic part of the human-readable form. This provides an ability to regenerate the human-readable text with updated semantic information from a machine-generated source. I.e., it enables true two-way trans-operability between the human and machine forms.

#+NAME: mrosetta-parse-ignorable
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-ignorable ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the ignorable property into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'should-ignore) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~ignorable~ keyword.

#+NAME: mrosetta-parse-ignorable-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(ignorable . mrosetta-parse-ignorable) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-ignorable-example
#+BEGIN_SRC text
(ignorable ":" suffixed paragraph)
#+END_SRC
*** Collections
Instead of matching a single occurrence of a complex expression, repetitively capture the corresponding expression within input text containing the recurring pattern, while structuring the resulting match as a list.

Collections are essential in matching of targeted semantics from within enumerated clauses of text.

The metalanguage defines collection expressions through two keywords: ~list~ and ~of~.

The ~list~ specifies the type of the encompassing /parent/ expression, while the ~of~ designates its fractal content.

#+NAME: mrosetta-parse-list
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-list ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the list epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

#+NAME: mrosetta-parse-list-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(list . mrosetta-parse-list) mrosetta-mlsyntax)
#+END_SRC

#+NAME: mrosetta-parse-of
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-of ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the sub-expression from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((sub-expression (plist-get args :right)))
    (when (or (eq sub-expression nil) (nlistp sub-expression))
      (error "Metalanguage syntax error: Sub-expression assignment without contextual expression"))
    (mrosetta-parse mlexpression :sub sub-expression))
  (plist-put args :right nil))
#+END_SRC

#+NAME: mrosetta-parse-of-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(of . mrosetta-parse-of) mrosetta-mlsyntax)
#+END_SRC

** Expression Parsing
Parse the metalanguage-specified definition within an expression instance.

#+NAME: mrosetta-parse
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the metalanguage-specified definition within the MLEXPRESSION instance. Optionally, parse the explicitly-set :sub definition in ARGS instead."
  (let* ((sub-definition (plist-get args :sub))
         (mldefinition (if (eq sub-definition nil)
                           (copy-tree (slot-value mlexpression 'mldefinition))
                         (copy-tree sub-definition)))
         (larg)
         (element)
         (rarg))
    (while (> (length mldefinition) 0)
      (setq element (pop mldefinition)
            rarg (car mldefinition))
      (when (symbolp element)
        ;; The element is a metalanguage keyword, so lookup the corresponding function and parse accordingly
        (let ((leftout-args (funcall (cdr (assq element mrosetta-mlsyntax)) mlexpression :left larg :right rarg)))
          (setq larg nil)
          (when (eq (plist-get leftout-args :right) nil)
            (pop mldefinition))))
      (when (and (listp element) (> (length element) 0))
        ;; The element is a nested fractal expression
        (setf (slot-value mlexpression 'extype) :fractal)
        (let ((fractal-mlexpression (mrosetta-mlexpression :mldefinition element :rkeychain (slot-value mlexpression 'rkeychain))))
          (setf (slot-value mlexpression 'fractals) `(,@(slot-value mlexpression 'fractals) ,fractal-mlexpression))
          (mrosetta-parse fractal-mlexpression))
        (setq larg nil))
      (when (stringp element)
        ;; The element is a quoted string, so just pass it along
        (setq larg element)))))
#+END_SRC

** Expression Compilation
Compile the entire fractal tree within the root expression instance into a regular expression structure.

#+NAME: mrosetta-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-compile ((mlexpression mrosetta-mlexpression))
  "Compile the MLEXPRESSION instance into a regular expression structure."
  (let* ((rkeychain (slot-value mlexpression 'rkeychain))
         (regex)
         (regex-key (mrosetta-generate-regex-key rkeychain))
         (rinstance)
         (rinstance-key (mrosetta-generate-regex-key rkeychain))
         (rmatch (slot-value mlexpression 'rmatch))
         (rmatch-key (mrosetta-generate-regex-key rkeychain))
         (rprefix (slot-value mlexpression 'rprefix))
         (rsuffix (slot-value mlexpression 'rsuffix))
         (left-rboundary (slot-value mlexpression 'left-rboundary))
         (right-rboundary (slot-value mlexpression 'right-rboundary))
         (rbuffer (slot-value mlexpression 'rbuffer))
         (left-rbuffer-key (mrosetta-generate-regex-key rkeychain))
         (right-rbuffer-key (mrosetta-generate-regex-key rkeychain))
         (is-contextual (slot-value mlexpression 'is-contextual))
         (is-optional (slot-value mlexpression 'is-optional))
         (is-plural (slot-value mlexpression 'is-plural)))
    (if (eq (slot-value mlexpression 'extype) :fractal)
        ;; Recursively compile all nested fractal expression instances
        (let ((fractals (slot-value mlexpression 'fractals)))
          ;; Fractal Expressions cannot have end-matches
          (when rmatch
            (error "Metalanguage syntax error: End-matching expressions, like words or paragraphs, must be defined with parentheses"))
          (dolist (fractal fractals)
            (setq rmatch (concat rmatch (mrosetta-compile fractal)))))
      ;; Literal or end Match
      (when (eq rmatch nil)
        (setq rmatch (slot-value mlexpression 'rbase))))
    ;; Compile the total match, instance and expression-encompassing regular expressions
    (setq rmatch (concat "\\(?" (number-to-string rmatch-key) ":" rmatch "\\)"))
    (setq rinstance (concat "\\(?" (number-to-string rinstance-key) ":"
                            (when (not is-contextual)
                              (concat "\\(?" (number-to-string left-rbuffer-key) ":" rbuffer "\\)"
                                      (or rprefix left-rboundary)))
                            rmatch
                            (when (not is-contextual)
                              (concat (or rsuffix right-rboundary)
                                      "\\(?" (number-to-string right-rbuffer-key) ":" rbuffer "\\)"))
                            "\\)"))
    (setq regex (concat "\\(?" (number-to-string regex-key) ":"
                        rinstance
                        (when is-plural "+")
                        "\\)"
                        (when is-optional "?")))
    (setf (slot-value mlexpression 'rmatch-key) rmatch-key
          (slot-value mlexpression 'rmatch) rmatch
          (slot-value mlexpression 'left-rbuffer-key) left-rbuffer-key
          (slot-value mlexpression 'right-rbuffer-key) right-rbuffer-key
          (slot-value mlexpression 'rinstance-key) rinstance-key
          (slot-value mlexpression 'rinstance) rinstance
          (slot-value mlexpression 'regex-key) regex-key
          (slot-value mlexpression 'regex) regex)))
#+END_SRC

* Text Processing
Process human-readable source text and output the semantic data structure, as defined by the metalanguage expression in context.

#+NAME: mrosetta-process
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-process ((mlexpression mrosetta-mlexpression) &rest args)
  "Process human-readable text within the :text or :inner string within ARGS and return the semantic data structure as defined by the MLEXPRESSION instance."
  (let ((htext (or (plist-get args :text)
                   (plist-get args :inner)))
        (is-inner (plist-get args :inner))
        (exdata '())
        (case-fold-search nil))
    (or (when (and (mrosetta-is-contextual mlexpression) is-inner)
          ;; Return the full inner-text matched within the parent expression if not marked as ignorable
          (when (and (eq (mrosetta-extype mlexpression) :match)
                     (not (mrosetta-should-ignore mlexpression)))
            `(,(or (mrosetta-key mlexpression) :nokey) . ,htext)))
        (save-match-data
          (and htext
               (string-match (mrosetta-regex mlexpression) htext)
               ;; Found match for the entirety of the expression
               (let ((extext (match-string (mrosetta-regex-key mlexpression) htext))
                     (pos))
                 (save-match-data
                   ;; Iterate over all instance occurrences within the matching expression text
                   (while (string-match (mrosetta-rinstance mlexpression) extext pos)
                     (setq pos (match-end 0))
                     ;; Process the exact match as defined by the expression
                     (let ((instance-exdata))
                       ;; Cases where the expression is a :fractal
                       (when (eq (mrosetta-extype mlexpression) :fractal)
                         ;; Recursively process all fractals within
                         (let ((fractals (mrosetta-fractals mlexpression)))
                           (dolist (fractal fractals)
                             (let ((fractal-exdata (mrosetta-process fractal :inner (match-string (mrosetta-regex-key fractal) extext))))
                               (when fractal-exdata
                                 (setq instance-exdata `(,@instance-exdata ,fractal-exdata)))))))
                       ;; Cases where the expression is a :match
                       (when (and (eq (mrosetta-extype mlexpression) :match)
                                  (not (mrosetta-should-ignore mlexpression)))
                         ;; Just store the semantic end-match, modified if defined as such
                         (let ((match (match-string (mrosetta-rmatch-key mlexpression) extext))
                               (modifier (mrosetta-modifier mlexpression)))
                           (when modifier
                             (setq match (funcall modifier match)))
                           (setq instance-exdata match)))
                       (when instance-exdata
                         (setq exdata `(,@exdata ,instance-exdata)))))
                   (when exdata
                     ;; Splice instance data in case of a singular expression
                     (when (not (mrosetta-is-plural mlexpression))
                       (setq exdata (car exdata)))
                     ;; Return the structured semantic data object
                     `(,(or (mrosetta-key mlexpression) :nokey) . ,exdata)))))))))
#+END_SRC

* Text Updating
Process human-readable source text and output the original text semantically updated with the provided data structure.

#+NAME: mrosetta-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-update ((mlexpression mrosetta-mlexpression) &rest args)
  "Process human readable text within the :text or :inner string and return the semantically updated text with the provided :sdata structure within ARGS, as defined by the MLEXPRESSION instance."
  (let ((htext (or (plist-get args :text)
                   (plist-get args :inner)))
        (exkey (car (plist-get args :sdata)))
        (exdata (copy-tree (cdr (plist-get args :sdata))))
        (is-inner (plist-get args :inner))
        (newtext)
        (case-fold-search nil))
    (when (and exdata
               (not (eq exkey
                        (or (mrosetta-key mlexpression) :nokey))))
      (error "Data structure error: Key mismatch"))
    (or (when (and (mrosetta-is-contextual mlexpression) is-inner)
          ;; Return the full inner-text matched within the parent expression or the updated text passed in
          (or exdata htext))
        (save-match-data
          (and htext
               (string-match (mrosetta-regex mlexpression) htext)
               ;; Found metalanguage expression match
               (let ((extext (match-string (mrosetta-regex-key mlexpression) htext))
                     (pos))
                 (save-match-data
                   (while (string-match (mrosetta-rinstance mlexpression) extext pos)
                     (setq pos (match-end 0))
                     ;; Update each instance
                     (let ((instance-exdata (if (mrosetta-is-plural mlexpression) (pop exdata) exdata))
                           (instance-newtext))
                       (if (eq (mrosetta-extype mlexpression) :fractal)
                           ;; Recursively update all fractals within
                           (let ((fractals (mrosetta-fractals mlexpression)))
                             (dolist (fractal fractals)
                               (let* ((fractal-exdata (assq (mrosetta-key fractal) instance-exdata))
                                      (fractal-text (match-string (mrosetta-regex-key fractal) extext))
                                      (fractal-newtext (mrosetta-update fractal :inner fractal-text :sdata fractal-exdata)))
                                 (setq instance-newtext (concat instance-newtext fractal-newtext)))))
                         ;; Update end-elements
                         (let ((left-buffer (match-string (mrosetta-left-rbuffer-key mlexpression) extext))
                               (right-buffer (match-string (mrosetta-right-rbuffer-key mlexpression) extext)))
                           (when (eq (mrosetta-extype mlexpression) :match)
                             ;; Update match text, including ignorable matches
                             (let ((prefix (mrosetta-match-prefix mlexpression))
                                   (suffix (mrosetta-match-suffix mlexpression))
                                   (match (or instance-exdata
                                              (match-string (mrosetta-rmatch-key mlexpression) extext))))
                               (setq instance-newtext (concat left-buffer prefix match suffix right-buffer))))
                           (when (eq (mrosetta-extype mlexpression) :literal)
                             ;; Include the literal, with surrounding buffer
                             (let ((literal (mrosetta-match-literal mlexpression)))
                               (setq instance-newtext (concat left-buffer literal right-buffer))))))
                       (setq newtext (concat newtext instance-newtext))))
                   ;; Return the updated text
                   newtext)))))))
#+END_SRC

* Demos
This section covers various examples of metalanguage syntax.

#+NAME: demo-init
#+BEGIN_SRC emacs-lisp :noweb yes :session mrosetta-demo
<<dependencies>>

<<mrosetta-keychain>>
<<mrosetta-generate-regex-key>>

<<mrosetta-mlexpression>>

<<mrosetta-mlsyntax>>
<<mrosetta-mlsyntax-modifiers>>

<<mrosetta-parse-literal>>
<<mrosetta-parse-literal-symbol>>
<<mrosetta-parse-word>>
<<mrosetta-parse-word-symbol>>
<<mrosetta-parse-word-uppercase>>
<<mrosetta-parse-word-uppercase-symbol>>
<<mrosetta-parse-word-capitalized>>
<<mrosetta-parse-word-capitalized-symbol>>
<<mrosetta-parse-word-plurality>>
<<mrosetta-parse-word-plurality-symbol>>
<<mrosetta-parse-paragraph>>
<<mrosetta-parse-paragraph-symbol>>
<<mrosetta-parse-paragraph-plurality>>
<<mrosetta-parse-paragraph-plurality-symbol>>
<<mrosetta-parse-substring>>
<<mrosetta-parse-substring-symbol>>
<<mrosetta-parse-prefix>>
<<mrosetta-parse-prefix-symbol>>
<<mrosetta-parse-suffix>>
<<mrosetta-parse-suffix-symbol>>
<<mrosetta-parse-contextual>>
<<mrosetta-parse-contextual-symbol>>
<<mrosetta-parse-modifier-uppercase-symbol>>
<<mrosetta-parse-modifier-lowercase-symbol>>
<<mrosetta-parse-modifier>>
<<mrosetta-parse-modifier-symbol>>
<<mrosetta-parse-optionality>>
<<mrosetta-parse-optionality-symbol>>
<<mrosetta-parse-key>>
<<mrosetta-parse-key-symbol>>
<<mrosetta-parse-ignorable>>
<<mrosetta-parse-ignorable-symbol>>
<<mrosetta-parse-list>>
<<mrosetta-parse-list-symbol>>
<<mrosetta-parse-of>>
<<mrosetta-parse-of-symbol>>

<<mrosetta-parse>>
<<mrosetta-compile>>
<<mrosetta-process>>
<<mrosetta-update>>

mrosetta-mlsyntax
#+END_SRC

#+RESULTS: demo-init
: ((of . mrosetta-parse-of) (list . mrosetta-parse-list) (ignorable . mrosetta-parse-ignorable) (as . mrosetta-parse-key) (optional . mrosetta-parse-optionality) (to . mrosetta-parse-modifier) (contextual . mrosetta-parse-contextual) (suffixed . mrosetta-parse-suffix) (prefixed . mrosetta-parse-prefix) (with . mrosetta-parse-substring) (paragraphs . mrosetta-parse-paragraph-plurality) (paragraph . mrosetta-parse-paragraph) (words . mrosetta-parse-word-plurality) (Word . mrosetta-parse-word-capitalized) (WORD . mrosetta-parse-word-uppercase) (word . mrosetta-parse-word) (literal . mrosetta-parse-literal))

Note that by metalanguage syntax, the outermost expression is auto-parenthesized, thus making it a legitimate list expression.

#+NAME: demo-mlexpression
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input="" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition)))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-process mlexpression :text input))
#+END_SRC

** Words
*** Uppercase Word
Match a single uppercase word.

#+NAME: demo-word-uppercase
#+BEGIN_EXAMPLE
WORD as status
#+END_EXAMPLE

We'll use a following example of input text.

#+NAME: demo-word-uppercase-text
#+BEGIN_EXAMPLE
The current status is OPERATIONAL.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-uppercase, input=demo-word-uppercase-text )

#+RESULTS:
: (status . "OPERATIONAL")

*** Capitalized Word
Match a single capitalized word.

#+NAME: demo-word-capitalized
#+BEGIN_EXAMPLE
Word as title
#+END_EXAMPLE

#+NAME: demo-word-capitalized-text
#+BEGIN_EXAMPLE
Report: All systems operational
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-capitalized, input=demo-word-capitalized-text )

#+RESULTS:
: (title . "Report")

*** A Prefixed Word
Match a single word defined by a specific prefix.

#+NAME: demo-word-prefixed
#+BEGIN_EXAMPLE
"#" prefixed word as tag
#+END_EXAMPLE

#+NAME: demo-word-prefixed-text
#+BEGIN_EXAMPLE
A new task has been created for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-prefixed, input=demo-word-prefixed-text )

#+RESULTS:
: (tag . "devops")

*** A Suffixed Word
Match a single word defined by a specific suffix.

#+NAME: demo-word-suffixed
#+BEGIN_EXAMPLE
"!" suffixed word as priority
#+END_EXAMPLE

#+NAME: demo-word-suffixed-text
#+BEGIN_EXAMPLE
A new critical! issue submitted.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-suffixed, input=demo-word-suffixed-text )

#+RESULTS:
: (priority . "critical")

*** Word with Specific Content
Match a word containing specific content, such as a single character or substring.

#+NAME: demo-word-content
#+BEGIN_EXAMPLE
word with "/" as project
#+END_EXAMPLE

#+NAME: demo-word-content-text
#+BEGIN_EXAMPLE
A new card added in backend/api.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-content, input=demo-word-content-text )

#+RESULTS:
: (project . "backend/api")

*** Word to Uppercase
Modify the matched word to uppercase.

#+NAME: demo-word-to-uppercase
#+BEGIN_EXAMPLE
"!" prefixed word as priority to uppercase
#+END_EXAMPLE

#+NAME: demo-word-to-uppercase-text
#+BEGIN_EXAMPLE
[!high] Received a new support ticket.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-uppercase, input=demo-word-to-uppercase-text )

#+RESULTS:
: (priority . "HIGH")

*** Word to Lowercase
Modify the matched word to lowercase.

#+NAME: demo-word-to-lowercase
#+BEGIN_EXAMPLE
"#" prefixed word as label to lowercase
#+END_EXAMPLE

#+NAME: demo-word-to-lowercase-text
#+BEGIN_EXAMPLE
New message received marked for #Support!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-lowercase, input=demo-word-to-lowercase-text )

#+RESULTS:
: (label . "support")

*** List of Words
Match a list of words matching defined criteria.

#+NAME: demo-word-list
#+BEGIN_EXAMPLE
":" prefixed words as tags
#+END_EXAMPLE

#+NAME: demo-word-list-text
#+BEGIN_EXAMPLE
Task completed successfully :devops :api!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-list, input=demo-word-list-text )

#+RESULTS:
: (tags "devops" "api")

** Paragraphs
*** Paragraph Based on Criteria
Match a paragraph of text conforming with specified criteria. Note that in order to successfully match a paragraph of text, both boundaries need to be either explicitly or contextually specified.

When explicitly setting boundaries, the left boundary is implicitly the first possibly matched character.

#+NAME: demo-paragraph
#+BEGIN_EXAMPLE
": " prefixed "." suffixed paragraph as status
#+END_EXAMPLE

#+NAME: demo-paragraph-text
#+BEGIN_EXAMPLE
Status update: API service started successfully.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph, input=demo-paragraph-text )

#+RESULTS:
: (status . "API service started successfully")

*** List of Paragraphs
Match a list of consecutive paragraphs defined by specified criteria.

#+NAME: demo-paragraph-list
#+BEGIN_EXAMPLE
"." suffixed paragraphs as statements to lowercase
#+END_EXAMPLE

#+NAME: demo-paragraph-list-text
#+BEGIN_EXAMPLE
One task completed. Three tasks updated. Two tasks created.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph-list, input=demo-paragraph-list-text )

#+RESULTS:
: (statements "one task completed" "three tasks updated" "two tasks created")

** Complex Expressions
*** All-inclusive Match
Match multiple elements inbetween ignorable information within human readable text.

#+NAME: demo-complex
#+BEGIN_EXAMPLE
(WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)
#+END_EXAMPLE

#+NAME: demo-complex-text
#+BEGIN_EXAMPLE
CRITICAL Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex, input=demo-complex-text )

#+RESULTS:
: (:nokey (priority . "critical") (project . "backend/api") (type . "devops"))

*** Optional Matches
Match multiple elements, one or more of which are optional in presence and aren't required to trigger a semantic match.

#+NAME: demo-complex-optional
#+BEGIN_EXAMPLE
(optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)
#+END_EXAMPLE

The following text example doesn't contain an optional element. As expected, the structured data output is processed and matched, excluding the missing optional element.

#+NAME: demo-complex-optional-text
#+BEGIN_EXAMPLE
Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-optional-text )

#+RESULTS:
: (:nokey (project . "backend/api") (type . "devops"))

By passing the example from above, containing the optional priority element, the output structure includes and matches the element.

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-text )

#+RESULTS:
: (:nokey (priority . "critical") (project . "backend/api") (type . "devops"))

*** Complex Collections
Match multiple occurrences of expressions containing multiple elements.

#+NAME: demo-complex-collection
#+BEGIN_EXAMPLE
"!" suffixed list of ((optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types))
#+END_EXAMPLE

#+NAME: demo-complex-collection-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops! Task created in web/home for #frontend #design! BLOCKER task created in backend/api for #backend!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-collection, input=demo-complex-collection-text )

#+RESULTS:
: (:nokey ((priority . "critical") (project . "backend/api") (types "devops")) ((project . "web/home") (types "frontend" "design")) ((priority . "blocker") (project . "backend/api") (types "backend")))

** Text Regeneration
Update the original text with new semantic information from passed in structured data.

#+NAME: demo-mlexpression-update
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input-text="" input-data=""" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition))
       (sdata `(:nokey . ,(car (read-from-string (concat "(" input-data ")"))))))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-update mlexpression :text input-text :sdata sdata))
#+END_SRC

#+NAME: demo-regen
#+BEGIN_EXAMPLE
(WORD as priority) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types)
#+END_EXAMPLE

#+NAME: demo-regen-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops #backend!
#+END_EXAMPLE

The structured data from input text will look like so:

#+CALL: demo-mlexpression( definition=demo-regen, input=demo-regen-text )

#+RESULTS:
: (:nokey (priority . "CRITICAL") (project . "backend/api") (types "devops" "backend"))

Now, we can pass in an updated property or two. The properties not included will remain intact.

#+NAME: demo-regen-data
#+BEGIN_EXAMPLE
(priority . "BLOCKER") (types "backend" "frontend")
#+END_EXAMPLE

#+CALL: demo-mlexpression-update( definition=demo-regen, input-text=demo-regen-text, input-data=demo-regen-data )

#+RESULTS:
: "BLOCKER task created in backend/api for #backend #frontend"

* Contexts
** Org
* Connectors
** REST
* Registration
#+NAME: registration
#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'metarosetta)
#+END_SRC
* Footer
#+NAME: footer
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el ends here
#+END_SRC
