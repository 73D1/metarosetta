#+TITLE: Project Metarosetta Emacs Package

* Header
** Name and Definition
#+NAME: title
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el --- A semantically-driven interconnectivity framework -*- lexical-binding: t -*-
#+END_SRC
** Signature
#+NAME: signature
#+BEGIN_SRC emacs-lisp :tangle yes
;; Author: Bruno Tedeschi <me@btedeschi.com>
#+END_SRC
** Summary
#+NAME: summary
#+BEGIN_SRC text
This package adds Metarosetta expression language support to Org-mode.

It enables in-context definition of semantic protocols, within Org-mode, which automatically translate human-input text into a machine-digestible API-compatible structure particular to a given context.

For details and language specification, please refer to the original package documentation and source org file.
#+END_SRC

#+NAME: commentary
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
;;; Commentary:

;; <<summary>>
#+END_SRC
** Code Marker
#+NAME: code-marker
#+BEGIN_SRC emacs-lisp :tangle yes
;;; Code:
#+END_SRC
* Dependencies
#+NAME: dependencies
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'eieio)
(require 'eieio-base)
(require 'url)
(require 'url-http)
(require 'org)
#+END_SRC
* Helpers
Helper objects and functions.

** The Keychain
Key management is encapsulated within a simple keychain class which holds all generated keys and is of course capable of generating keys unique to a single instance of the keychain.

*** Class Definition
The class itself is designed as a no-argument constructor as the key generator is automatically initialized upon creation.

#+NAME: mrosetta-keychain
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-keychain ()
  ((lastkey
    :initarg :lastkey
    :initform '0
    :type number
    :documentation "The last key generated and assigned within the context of a single keychain instance."
    :reader mrosetta-keychain-lastkey))
  "A key generator helper class.")
#+END_SRC
*** Behavior
This section covers all defined behavior for the keychain class.

**** Generate Key
Register for a new key with a particular keychain instance.

#+NAME: mrosetta-keychain-generate-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-keychain-generate-key ((keychain mrosetta-keychain))
  "Generate a new key within a provided KEYCHAIN."
  (let ((key (+ 1 (slot-value keychain 'lastkey))))
    (setf (slot-value keychain 'lastkey) key)))
#+END_SRC
* The Metalanguage
The metalanguage specification and parser.

** The Expression Object
An entity defining a particular expression. Using the metalanguage syntax as input, it constructs all underlying logic to parse textual input and structures to map semantic information to machine-readable output.

Designed as an inherently recursive fractal object.

*** Properties
All the properties contained within the expression object. These are of course defined as slots.

**** Definition
The metalanguage-specified definition of the expression in context.

This is stored as a quoted lisp list.

#+NAME: mrosetta-mlexpression-mldefinition
#+BEGIN_SRC emacs-lisp
(mldefinition
 :initarg :mldefinition
 :type list
 :documentation "The metalanguage-specified definition of the expression in context."
 :reader mrosetta-mlexpression-mldefinition)
#+END_SRC
**** Expression Type
Specifies the exact type of the expression in context.

The property itself is a ~symbol~ indicating the type of the expression.

#+NAME: mrosetta-mlexpression-extype
#+BEGIN_SRC emacs-lisp
(extype
 :type symbol
 :documentation "A symbol specifying the type of the encompassing expression instance. Can be either a :literal, :match or :fractal."
 :reader mrosetta-mlexpression-extype)
#+END_SRC

The following are the possible expression types:

***** Literal Quote
Denotes the simplest expression defining statically quoted text which matches itself within any passed input.

The quote expression type is specified as a ~:literal~.
***** Match
An expression matching semantically significant information. These are either words or paragraphs of captured text.

A match expression is specified as a ~:match~.
***** Fractal
An expression matching a sequence of its nested child expressions.

A fractal expression is specified as a ~:fractal~.
**** Fractals
All the fractal elements existing within the encompassing expression instance. Only ~:fractal~ instances can contain sub-expressions themselves.

The property itself is a list of ~mrosetta-expression~ instances.

#+NAME: mrosetta-mlexpression-fractals
#+BEGIN_SRC emacs-lisp
(fractals
 :initform '()
 :type list
 :documentation "A list of mrosetta-expression instances contained within the encompassing expression instance."
 :reader mrosetta-mlexpression-fractals)
#+END_SRC
**** Regular Expression Properties
This section contains all the properties pertaining to the encompassing expression's regex, its group keys and resulting matches of the current input, if processed.

***** Regex Keychain
In order to properly parse and distribute regex matches across the fractal expression tree, each expression object needs to have a number identifier unique to the encompassing tree.

To manage this, each tree has a single /keychain/ instance shared across all expression objects within a single fractal tree.

#+NAME: mrosetta-mlexpression-rkeychain
#+BEGIN_SRC emacs-lisp
(rkeychain
 :initarg :rkeychain
 :initform (mrosetta-keychain)
 :type mrosetta-keychain
 :documentation "The regex keychain instance managing keys for the encompassing expression tree."
 :reader mrosetta-mlexpression-rkeychain)
#+END_SRC

***** Regular Expression
The compiled regular expression of the metalanguage expression in context.

This is the regex used under the hood when parsing through human-readable input.

#+NAME: mrosetta-mlexpression-regex
#+BEGIN_SRC emacs-lisp
(regex
 :type string
 :documentation "The compiled regular expression of the expression in context."
 :reader mrosetta-mlexpression-regex)
#+END_SRC

In addition, each match-extracting regular expression has a corresponding group key by which the respective match is extracted.

#+NAME: mrosetta-mlexpression-regex-key
#+BEGIN_SRC emacs-lisp
(regex-key
 :type number
 :documentation "The regex matching group key for the encompassing expression instance."
 :reader mrosetta-mlexpression-regex-key)
#+END_SRC

Since the metalanguage supports plural matches of enumerable text clauses, an additional regular expression is required in order to capture a single instance of such clauses. In cases of single-matching expressions, ~regex~ is equivalent to ~rinstance~.

#+NAME: mrosetta-mlexpression-rinstance
#+BEGIN_SRC emacs-lisp
(rinstance
 :type string
 :documentation "The compiled regular expression matching a single instance of a possibly plural-matching expression."
 :reader mrosetta-mlexpression-rinstance)
#+END_SRC

#+NAME: mrosetta-mlexpression-rinstance-key
#+BEGIN_SRC emacs-lisp
(rinstance-key
 :type number
 :documentation "The regex group key for matching a single instance of a possibly plural-matching metalanguage expression in context."
 :reader mrosetta-mlexpression-rinstance-key)
#+END_SRC

****** Base
The foundational element from which the matching regular expression is constructed.

#+NAME: mrosetta-mlexpression-rbase
#+BEGIN_SRC emacs-lisp
(rbase
 :type string
 :documentation "The regular expression used as a foundational base in compilation of the match-extracting regular expression."
 :reader mrosetta-mlexpression-rbase)
#+END_SRC
****** Match
The regular expression of the match itself.

#+NAME: mrosetta-mlexpression-rmatch
#+BEGIN_SRC emacs-lisp
(rmatch
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression of the encompassing expression's semantic match."
 :reader mrosetta-mlexpression-rmatch)
#+END_SRC

The regex is paired with its group key used for match extraction.

#+NAME: mrosetta-mlexpression-rmatch-key
#+BEGIN_SRC emacs-lisp
(rmatch-key
 :initform 'nil
 :type (or null number)
 :documentation "The regex group key for the encompassing expression's output value match."
 :reader mrosetta-mlexpression-rmatch-key)
#+END_SRC
****** Prefix
The regular expression used for matching a specified prefix of the expression in context, if any.

#+NAME: mrosetta-mlexpression-rprefix
#+BEGIN_SRC emacs-lisp
(rprefix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified prefix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-mlexpression-rprefix)
#+END_SRC
****** Suffix
The regular expression used for matching a specified suffix of the expression in context, if any.

#+NAME: mrosetta-mlexpression-rsuffix
#+BEGIN_SRC emacs-lisp
(rsuffix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified suffix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-mlexpression-rsuffix)
#+END_SRC
****** Regex Boundaries
Regular expressions used for regex-specific boundaries around the match.

******* Left Boundary
The regular expression used for defining the left boundary of the match.

#+NAME: mrosetta-mlexpression-left-rboundary
#+BEGIN_SRC emacs-lisp
(left-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The left regex-specific boundary defining the beginning of the match."
 :reader mrosetta-mlexpression-left-rboundary)
#+END_SRC
******* Right Boundary
The regular expression used for defining the right boundary of the match.

#+NAME: mrosetta-mlexpression-right-rboundary
#+BEGIN_SRC emacs-lisp
(right-rboundary
 :initform 'nil
 :type (or null string)
 :documentation "The right regex-specific boundary defining the end of the match."
 :reader mrosetta-mlexpression-right-rboundary)
#+END_SRC
****** Surrounding Buffers
Regular expressions used for matching buffer characters surrounding the match.

By default, these are /whitespace/ characters between words and used purely for original text reconstruction with updated semantics.

#+NAME: mrosetta-mlexpression-rbuffer
#+BEGIN_SRC emacs-lisp
(rbuffer
 :initform "[[:blank:]]*"
 :type string
 :documentation "The regular expression matching buffer characters surrounding the encompassing expression."
 :reader mrosetta-mlexpression-rbuffer)
#+END_SRC

******* Left Buffer
The regular expression group key for the left buffer.

#+NAME: mrosetta-mlexpression-left-rbuffer-key
#+BEGIN_SRC emacs-lisp
(left-rbuffer-key
 :type number
 :documentation "The regex group key for the encompassing expression's left buffer match."
 :reader mrosetta-mlexpression-left-rbuffer-key)
#+END_SRC
******* Right Buffer
The regular expression group key for the right buffer.

#+NAME: mrosetta-mlexpression-right-rbuffer-key
#+BEGIN_SRC emacs-lisp
(right-rbuffer-key
 :type number
 :documentation "The regex group key for the encompassing expression's right buffer match."
 :reader mrosetta-mlexpression-right-rbuffer-key)
#+END_SRC
**** Key
The property key to which the expression output value is assigned, if the expression itself is denoted as such.

#+NAME: mrosetta-mlexpression-key
#+BEGIN_SRC emacs-lisp
(key
 :initform 'nil
 :type (or null symbol)
 :documentation "The property key to which the expression output value is assigned, if any. Either a string or nil."
 :reader mrosetta-mlexpression-key)
#+END_SRC
**** Specifier Properties
All specifier parameters defined for the encompassing expression instance.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-mlexpression-is-uppercase
#+BEGIN_SRC emacs-lisp
(is-uppercase
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only uppercase words. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-uppercase)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-mlexpression-is-capitalized
#+BEGIN_SRC emacs-lisp
(is-capitalized
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only capitalized words. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-capitalized)
#+END_SRC
***** Boundary Properties
Specifies whether the match of the encompassing expression has static left or right boundaries.

****** Left Boundary
Specifies a statically set match prefix, if the expression defines one.

#+NAME: mrosetta-mlexpression-match-prefix
#+BEGIN_SRC emacs-lisp
(match-prefix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the prefix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-prefix)
#+END_SRC
****** Right Boundary
Specifies a statically set match suffix, if the expression defines one.

#+NAME: mrosetta-mlexpression-match-suffix
#+BEGIN_SRC emacs-lisp
(match-suffix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the suffix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-suffix)
#+END_SRC
***** Content
Match only words containing specific characters or substrings.

#+NAME: mrosetta-mlexpression-match-substring
#+BEGIN_SRC emacs-lisp
(match-substring
 :initform 'nil
 :type (or null string)
 :documentation "Specifies a specific substring all possible expression matches should contain, if any. Either a string or nil."
 :reader mrosetta-mlexpression-match-substring)
#+END_SRC
***** Literal
Match only and exactly the literal text specified here.

This slot is only used in ~:literal~ expressions.

#+NAME: mrosetta-mlexpression-match-literal
#+BEGIN_SRC emacs-lisp
(match-literal
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the literal string that the expression maches exclusively. Either a string or nill."
 :reader mrosetta-mlexpression-match-literal)
#+END_SRC
***** Contextual
Elastically match a region of text depending on neighboring elements.

This slot is only used in ~paragraph~ ~:match~ expressions since paragraphs match any and all text, either based on specific criteria, such as explicit boundaries, or on neighboring matches which act as contextual criteria.

#+NAME: mrosetta-mlexpression-is-contextual
#+BEGIN_SRC emacs-lisp
(is-contextual
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is matched elastically depending on neighboring elements. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-contextual)
#+END_SRC
**** Modifier
Modifiers are useful when matched text needs to be formatted and /normalized/ before being structured within the machine-digestible output.

A modifier property is defined as a symbol referencing a stored function capable of a particular modification, like ~upcase~ for uppercasing the entirety of the output, or ~downcase~ for lowercasing.

#+NAME: mrosetta-mlexpression-modifier
#+BEGIN_SRC emacs-lisp
(modifier
 :initform 'nil
 :type (or null symbol)
 :documentation "Specifies a symbol referencing a stored modifier function, if any. Either a symbol or nil."
 :reader mrosetta-mlexpression-modifier)
#+END_SRC
**** Optionality
Specifies whether the entire expression and its fractals within (if any) are optional in presence.

#+NAME: mrosetta-mlexpression-is-optional
#+BEGIN_SRC emacs-lisp
(is-optional
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is optional to match within input text. Either non-nil or nil."
 :reader mrosetta-mlexpression-is-optional)
#+END_SRC
**** Ignorables
Specifies whether the encompassing expression should be disregarded in structured output. Ignorable expressions are matched but never included in structured semantic output.

#+NAME: mrosetta-mlexpression-should-ignore
#+BEGIN_SRC emacs-lisp
(should-ignore
 :initform 'nil
 :documentation "Specifies whether the encompassing expression should be matched but disregarded in output. Either non-nil or nil."
 :reader mrosetta-mlexpression-should-ignore)
#+END_SRC
**** Plurality
If the expression defines a plural match, then the output value is in list form and this property is non-nil.

#+NAME: mrosetta-mlexpression-is-plural
#+BEGIN_SRC emacs-lisp
(is-plural
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches plural values or just a single one. Either nil or non-nil."
 :reader mrosetta-mlexpression-is-plural)
#+END_SRC
*** Class Definition
The /expression/ class is defined below, containing all the properties listed above.

#+NAME: mrosetta-mlexpression
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defclass mrosetta-mlexpression ()
  (
   <<mrosetta-mlexpression-mldefinition>>
   <<mrosetta-mlexpression-extype>>
   <<mrosetta-mlexpression-fractals>>
   <<mrosetta-mlexpression-rkeychain>>
   <<mrosetta-mlexpression-regex>>
   <<mrosetta-mlexpression-regex-key>>
   <<mrosetta-mlexpression-rinstance>>
   <<mrosetta-mlexpression-rinstance-key>>
   <<mrosetta-mlexpression-rbase>>
   <<mrosetta-mlexpression-rmatch>>
   <<mrosetta-mlexpression-rmatch-key>>
   <<mrosetta-mlexpression-rprefix>>
   <<mrosetta-mlexpression-rsuffix>>
   <<mrosetta-mlexpression-left-rboundary>>
   <<mrosetta-mlexpression-right-rboundary>>
   <<mrosetta-mlexpression-rbuffer>>
   <<mrosetta-mlexpression-left-rbuffer-key>>
   <<mrosetta-mlexpression-right-rbuffer-key>>
   <<mrosetta-mlexpression-key>>
   <<mrosetta-mlexpression-is-uppercase>>
   <<mrosetta-mlexpression-is-capitalized>>
   <<mrosetta-mlexpression-match-prefix>>
   <<mrosetta-mlexpression-match-suffix>>
   <<mrosetta-mlexpression-match-substring>>
   <<mrosetta-mlexpression-match-literal>>
   <<mrosetta-mlexpression-is-contextual>>
   <<mrosetta-mlexpression-modifier>>
   <<mrosetta-mlexpression-is-optional>>
   <<mrosetta-mlexpression-should-ignore>>
   <<mrosetta-mlexpression-is-plural>>
  )
  "The Metarosetta Expression object used to define a contextual translational expression for semantic processing.")
#+END_SRC

** Language Specification
The purpose of the language is to facilitate expressions which unambiguously define a translation protocol between human-readable text and machine-digestible data structures, with the semantics completely preserved, based on an arbitrarily defined pattern of human input within a specific context.

All keywords within the specification are stored as symbols which map to their respective parse functions.

#+NAME: mrosetta-mlsyntax
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax '())
#+END_SRC

*** Literal Quote
The simplest expression defining statically quoted text which should appear literally within input text.

#+NAME: mrosetta-parse-literal
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-literal ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the :right arg content within ARGS as a literal quote into the MLEXPRESSION instance in context."
  (let ((literal-quote (plist-get args :right)))
    (when (eq literal-quote nil)
      (error "Metalanguage syntax error: Literal expression without quoted content"))
    (setf (slot-value mlexpression 'extype) :literal)
    (setf (slot-value mlexpression 'rbase) (regexp-quote literal-quote))
    (setf (slot-value mlexpression 'match-literal) literal-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage itself defines this expression through the ~literal~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-literal-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(literal . mrosetta-parse-literal) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-literal-example
#+BEGIN_SRC text
(literal "Status Update:")
#+END_SRC
*** Word
An expression used to capture a variable word from within input text.

#+NAME: mrosetta-parse-word
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'left-rboundary) "\\<")
  (setf (slot-value mlexpression 'rbase) "[[:word:]]+")
  (setf (slot-value mlexpression 'right-rboundary) "\\>")
  args)
#+END_SRC

The metalanguage defines this expression through the ~word~ keyword.

#+NAME: mrosetta-parse-word-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(word . mrosetta-parse-word) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-example
#+BEGIN_SRC text
(word)
#+END_SRC

**** Word Specifiers
In addition to the ability to match any kind of word, the metalanguage specification also supports matching only specific words based on different criteria.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-parse-word-uppercase
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-uppercase ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse an uppercase word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9]+")
  (setf (slot-value mlexpression 'is-uppercase) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~WORD~ keyword. Note that the metalanguage syntax is case-sensitive, where case is also part of the syntax itself.

#+NAME: mrosetta-parse-word-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(WORD . mrosetta-parse-word-uppercase) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-uppercase-example
#+BEGIN_SRC text
(WORD)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-parse-word-capitalized
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-capitalized ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a capitalized word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9][a-z0-9]+")
  (setf (slot-value mlexpression 'is-capitalized) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~Word~ keyword.

#+NAME: mrosetta-parse-word-capitalized-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(Word . mrosetta-parse-word-capitalized) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-capitalized-example
#+BEGIN_SRC text
(Word)
#+END_SRC
**** Word Plurality
Instead of a single value, capture all value occurrences matching defined criteria within the encompassing expression context.

#+NAME: mrosetta-parse-word-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural words expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-word mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~words~ keyword.

#+NAME: mrosetta-parse-word-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(words . mrosetta-parse-word-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-word-plurality-example
#+BEGIN_SRC text
(words)
#+END_SRC
*** Paragraph
An expression used to capture a variable paragraph from within input text.

A paragraph is considered all text within specified boundaries. If no boundaries are set, the entire input is matched.

#+NAME: mrosetta-parse-paragraph
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a paragraph epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) (concat ".+?"))
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraph~ keyword.

#+NAME: mrosetta-parse-paragraph-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraph . mrosetta-parse-paragraph) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-paragraph-example
#+BEGIN_SRC text
(paragraph)
#+END_SRC

**** Paragraph Plurality
Like words, it's possible to capture multiple paragraph occurrences matching the expression-defined criteria.

Note that this construct only makes sense if paragraphs are clearly bounded.

#+NAME: mrosetta-parse-paragraph-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural paragraph expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setq args (apply 'mrosetta-parse-paragraph mlexpression args))
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraphs~ keyword.

#+NAME: mrosetta-parse-paragraph-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraphs . mrosetta-parse-paragraph-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-paragraph-plurality-example
#+BEGIN_SRC text
(";" suffixed paragraphs)
#+END_SRC
*** Specifiers
**** Content Specifier
Match only elements containing specific characters or content.

#+NAME: mrosetta-parse-substring
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-substring ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :right arg within ARGS as matching element substring into the MLEXPRESSION instance in context."
  (let* ((substring-quote (plist-get args :right))
         (rsubstring-quote (regexp-quote substring-quote))
         (rbase (slot-value mlexpression 'rbase)))
    (when (eq substring-quote nil)
      (error "Metalanguage syntax error: Substring match expression without quoted content"))
    (setf (slot-value mlexpression 'rmatch)
          (concat "\\(?:"
                  "\\(?:" rsubstring-quote "\\)?" rbase "\\(?:" rsubstring-quote "\\(?:" rbase "\\)?" "\\)+"
                  "\\|"
                  "\\(?:" "\\(?:" rbase "\\)?" rsubstring-quote "\\)+" rbase "\\(?:" rsubstring-quote "\\)?"
                  "\\)"))
    (setf (slot-value mlexpression 'match-substring) substring-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines this expression through the ~with~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-substring-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(with . mrosetta-parse-substring) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-substring-example
#+BEGIN_SRC text
(word with "-")
#+END_SRC
**** Boundaries
Match only elements with the specified prefix or suffix. Note that the prefix or suffix itself isn't part of the match.

***** Prefix
Match only elements prefixed with the supplied quoted content.

#+NAME: mrosetta-parse-prefix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-prefix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element prefix into the MLEXPRESSION instance in context."
  (let ((prefix-quote (plist-get args :left)))
    (when (eq prefix-quote nil)
      (error "Metalanguage syntax error: Prefix match expression without quoted content"))
    (setf (slot-value mlexpression 'rprefix) (regexp-quote prefix-quote))
    (setf (slot-value mlexpression 'match-prefix) prefix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~prefixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-prefix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(prefixed . mrosetta-parse-prefix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-prefix-example
#+BEGIN_SRC text
("#" prefixed word)
#+END_SRC
***** Suffix
Match only elements suffixed with the supplied quoted content.

#+NAME: mrosetta-parse-suffix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-suffix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element suffix into the MLEXPRESSION instance in context."
  (let ((suffix-quote (plist-get args :left)))
    (when (eq suffix-quote nil)
      (error "Metalanguage syntax error: Suffix match expression without quoted content"))
    (setf (slot-value mlexpression 'rsuffix) (regexp-quote suffix-quote))
    (setf (slot-value mlexpression 'match-suffix) suffix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~suffixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-suffix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(suffixed . mrosetta-parse-suffix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-suffix-example
#+BEGIN_SRC text
(";" suffixed word)
#+END_SRC
**** Contextual
Match elements based on contextual criteria of neighboring matches. Note that a contextual specifier is only applicable to ~paragraph~ expressions.

#+NAME: mrosetta-parse-contextual
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-contextual ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the contextual specifier into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-contextual) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~contextual~ keyword.

#+NAME: mrosetta-parse-contextual-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(contextual . mrosetta-parse-contextual) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-contextual-example
#+BEGIN_SRC text
(contextual paragraph)
#+END_SRC
*** Modifiers
Modify captured elements before structured output.

Modifiers are defined as contextual arguments succeeding the general modifier keyword.

#+NAME: mrosetta-mlsyntax-modifiers
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax-modifiers '())
#+END_SRC

**** Uppercase
Transform captured elements to uppercase format.

To do so, use the ~uppercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(uppercase . upcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-uppercase-example
#+BEGIN_SRC text
(word to uppercase)
#+END_SRC
**** Lowercase
Transform captured elements to lowercase format.

To do so, use the ~lowercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-lowercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(lowercase . downcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-lowercase-example
#+BEGIN_SRC text
(word to lowercase)
#+END_SRC
**** Modifier Argument Parser
All modifier contextual arguments are handled by a central modifier parser.

#+NAME: mrosetta-parse-modifier
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-modifier ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the modifier symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((modifier-symbol (plist-get args :right)))
    (when (eq modifier-symbol nil)
      (error "Metalanguage syntax error: Modifier expression without contextual argument symbol"))
    (setf (slot-value mlexpression 'modifier)
          (cdr (assq modifier-symbol mrosetta-mlsyntax-modifiers))))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the modifier context through the ~to~ keyword followed by the contextual arguments listed above.

#+NAME: mrosetta-parse-modifier-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(to . mrosetta-parse-modifier) mrosetta-mlsyntax)
#+END_SRC

*** Optionality
Specify whether the encompassing expression should be considered as an optional, or required match.

Input text without an optional expression match still gets processed, structured and output. Any input not matching all mandatory expressions is disregarded.

All defined expressions are considered as mandatory by default.

#+NAME: mrosetta-parse-optionality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-optionality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse expression optionality into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-optional) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~optional~ keyword.

#+NAME: mrosetta-parse-optionality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(optional . mrosetta-parse-optionality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-optionality-example
#+BEGIN_SRC text
(optional word)
#+END_SRC
*** Assignment
Assign a key to the resulting value of the encompassing expression.

#+NAME: mrosetta-parse-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-key ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the key symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((key-symbol (plist-get args :right)))
    (when (eq key-symbol nil)
      (error "Metalanguage syntax error: Key assignment without contextual key symbol"))
    (setf (slot-value mlexpression 'key) key-symbol))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the assignment expression through the ~as~ keyword followed by the key symbol.

#+NAME: mrosetta-parse-key-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(as . mrosetta-parse-key) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-key-example
#+BEGIN_SRC text
(word as a_property)
#+END_SRC
*** Ignorables
Specify whether the encompassing expression should be ignored from structured output. As noted above, ignorable expressions are matched but never included in structured semantic output.

Ignorables are considered as semantically insignificant text occurring before and after the semantic match itself.

While this text is unimportant for structured semantics, it remains an intrinsic part of the human-readable form. This provides an ability to regenerate the human-readable text with updated semantic information from a machine-generated source. I.e., it enables true two-way trans-operability between the human and machine forms.

#+NAME: mrosetta-parse-ignorable
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-ignorable ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the ignorable property into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'should-ignore) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~ignorable~ keyword.

#+NAME: mrosetta-parse-ignorable-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(ignorable . mrosetta-parse-ignorable) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-ignorable-example
#+BEGIN_SRC text
(ignorable ":" suffixed paragraph)
#+END_SRC
*** Collections
Instead of matching a single occurrence of a complex expression, repetitively capture the corresponding expression within input text containing the recurring pattern, while structuring the resulting match as a list.

Collections are essential in matching of targeted semantics from within enumerated clauses of text.

The metalanguage defines collection expressions through two keywords: ~list~ and ~of~.

The ~list~ specifies the type of the encompassing /parent/ expression, while the ~of~ designates its fractal content.

#+NAME: mrosetta-parse-list
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-list ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the list epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

#+NAME: mrosetta-parse-list-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(list . mrosetta-parse-list) mrosetta-mlsyntax)
#+END_SRC

In addition to the ~list~ specifier denoting a plural collection, there are cases where it's convenient to denote a /singular collection/ for the ability to define properties directly upon the complex expression, such as setting a property name to a subset of an expression, or to structure and group big linear expressions.

Singular collections are defined through the ~element~ keyword, of course followed by the ~of~ keyword designating the fractal content of the element in context.

#+NAME: mrosetta-parse-element
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-element ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the element expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) nil)
  args)
#+END_SRC

#+NAME: mrosetta-parse-element-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(element . mrosetta-parse-element) mrosetta-mlsyntax)
#+END_SRC

#+NAME: mrosetta-parse-of
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-of ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the sub-expression from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((sub-expression (plist-get args :right)))
    (when (or (eq sub-expression nil) (nlistp sub-expression))
      (error "Metalanguage syntax error: Sub-expression assignment without contextual expression"))
    (mrosetta-parse mlexpression :sub sub-expression))
  (plist-put args :right nil))
#+END_SRC

#+NAME: mrosetta-parse-of-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(of . mrosetta-parse-of) mrosetta-mlsyntax)
#+END_SRC

** Expression Parsing
Parse the metalanguage-specified definition within an expression instance.

#+NAME: mrosetta-parse
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the metalanguage-specified definition within the MLEXPRESSION instance. Optionally, parse the explicitly-set :sub definition in ARGS instead."
  (let* ((sub-definition (plist-get args :sub))
         (mldefinition (if (eq sub-definition nil)
                           (copy-tree (slot-value mlexpression 'mldefinition))
                         (copy-tree sub-definition)))
         (larg)
         (element)
         (rarg))
    (while (> (length mldefinition) 0)
      (setq element (pop mldefinition)
            rarg (car mldefinition))
      (when (symbolp element)
        ;; The element is a metalanguage keyword, so lookup the corresponding function and parse accordingly
        (let ((leftout-args (funcall (cdr (assq element mrosetta-mlsyntax)) mlexpression :left larg :right rarg)))
          (setq larg nil)
          (when (eq (plist-get leftout-args :right) nil)
            (pop mldefinition))))
      (when (and (listp element) (> (length element) 0))
        ;; The element is a nested fractal expression
        (setf (slot-value mlexpression 'extype) :fractal)
        (let ((fractal-mlexpression (mrosetta-mlexpression :mldefinition element :rkeychain (slot-value mlexpression 'rkeychain))))
          (setf (slot-value mlexpression 'fractals) `(,@(slot-value mlexpression 'fractals) ,fractal-mlexpression))
          (mrosetta-parse fractal-mlexpression))
        (setq larg nil))
      (when (stringp element)
        ;; The element is a quoted string, so just pass it along
        (setq larg element)))))
#+END_SRC

** Expression Compilation
Compile the entire fractal tree within the root expression instance into a regular expression structure.

#+NAME: mrosetta-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-compile ((mlexpression mrosetta-mlexpression))
  "Compile the MLEXPRESSION instance into a regular expression structure."
  (let* ((rkeychain (slot-value mlexpression 'rkeychain))
         (regex)
         (regex-key (mrosetta-keychain-generate-key rkeychain))
         (rinstance)
         (rinstance-key (mrosetta-keychain-generate-key rkeychain))
         (rmatch (slot-value mlexpression 'rmatch))
         (rmatch-key (mrosetta-keychain-generate-key rkeychain))
         (rprefix (slot-value mlexpression 'rprefix))
         (rsuffix (slot-value mlexpression 'rsuffix))
         (left-rboundary (slot-value mlexpression 'left-rboundary))
         (right-rboundary (slot-value mlexpression 'right-rboundary))
         (rbuffer (slot-value mlexpression 'rbuffer))
         (left-rbuffer-key (mrosetta-keychain-generate-key rkeychain))
         (right-rbuffer-key (mrosetta-keychain-generate-key rkeychain))
         (is-contextual (slot-value mlexpression 'is-contextual))
         (is-optional (slot-value mlexpression 'is-optional))
         (is-plural (slot-value mlexpression 'is-plural)))
    (if (eq (slot-value mlexpression 'extype) :fractal)
        ;; Recursively compile all nested fractal expression instances
        (let ((fractals (slot-value mlexpression 'fractals)))
          ;; Fractal Expressions cannot have end-matches
          (when rmatch
            (error "Metalanguage syntax error: End-matching expressions, like words or paragraphs, must be defined with parentheses"))
          (dolist (fractal fractals)
            (setq rmatch (concat rmatch (mrosetta-compile fractal)))))
      ;; Literal or end Match
      (when (eq rmatch nil)
        (setq rmatch (slot-value mlexpression 'rbase))))
    ;; Compile the total match, instance and expression-encompassing regular expressions
    (setq rmatch (concat "\\(?" (number-to-string rmatch-key) ":" rmatch "\\)"))
    (setq rinstance (concat "\\(?" (number-to-string rinstance-key) ":"
                            (when (not is-contextual)
                              (concat "\\(?" (number-to-string left-rbuffer-key) ":" rbuffer "\\)"
                                      (or rprefix left-rboundary)))
                            rmatch
                            (when (not is-contextual)
                              (concat (or rsuffix right-rboundary)
                                      "\\(?" (number-to-string right-rbuffer-key) ":" rbuffer "\\)"))
                            "\\)"))
    (setq regex (concat "\\(?" (number-to-string regex-key) ":"
                        rinstance
                        (when is-plural "+")
                        "\\)"
                        (when is-optional "?")))
    (setf (slot-value mlexpression 'rmatch-key) rmatch-key
          (slot-value mlexpression 'rmatch) rmatch
          (slot-value mlexpression 'left-rbuffer-key) left-rbuffer-key
          (slot-value mlexpression 'right-rbuffer-key) right-rbuffer-key
          (slot-value mlexpression 'rinstance-key) rinstance-key
          (slot-value mlexpression 'rinstance) rinstance
          (slot-value mlexpression 'regex-key) regex-key
          (slot-value mlexpression 'regex) regex)))
#+END_SRC

* Text Processing
Process human-readable source text and output the semantic data structure, as defined by the metalanguage expression in context.

#+NAME: mrosetta-process
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-process ((mlexpression mrosetta-mlexpression) &rest args)
  "Process human-readable text within the :text or :inner string within ARGS and return the semantic data structure as defined by the MLEXPRESSION instance."
  (let ((htext (or (plist-get args :text)
                   (plist-get args :inner)))
        (is-inner (plist-get args :inner))
        (exdata '())
        (case-fold-search nil))
    (or (when (and (mrosetta-mlexpression-is-contextual mlexpression) is-inner)
          ;; Return the full inner-text matched within the parent expression if not marked as ignorable
          (when (and (eq (mrosetta-mlexpression-extype mlexpression) :match)
                     (not (mrosetta-mlexpression-should-ignore mlexpression)))
            `(,(or (mrosetta-mlexpression-key mlexpression) :nokey) . ,htext)))
        (save-match-data
          (and htext
               (string-match (mrosetta-mlexpression-regex mlexpression) htext)
               ;; Found match for the entirety of the expression
               (let ((extext (match-string (mrosetta-mlexpression-regex-key mlexpression) htext))
                     (pos))
                 (save-match-data
                   ;; Iterate over all instance occurrences within the matching expression text
                   (while (string-match (mrosetta-mlexpression-rinstance mlexpression) extext pos)
                     (setq pos (match-end 0))
                     ;; Process the exact match as defined by the expression
                     (let ((instance-exdata))
                       ;; Cases where the expression is a :fractal
                       (when (eq (mrosetta-mlexpression-extype mlexpression) :fractal)
                         ;; Recursively process all fractals within
                         (let ((fractals (mrosetta-mlexpression-fractals mlexpression)))
                           (dolist (fractal fractals)
                             (let ((fractal-exdata (mrosetta-process fractal :inner (match-string (mrosetta-mlexpression-regex-key fractal) extext))))
                               (when fractal-exdata
                                 (setq instance-exdata `(,@instance-exdata ,fractal-exdata)))))))
                       ;; Cases where the expression is a :match
                       (when (and (eq (mrosetta-mlexpression-extype mlexpression) :match)
                                  (not (mrosetta-mlexpression-should-ignore mlexpression)))
                         ;; Just store the semantic end-match, modified if defined as such
                         (let ((match (match-string (mrosetta-mlexpression-rmatch-key mlexpression) extext))
                               (modifier (mrosetta-mlexpression-modifier mlexpression)))
                           (when modifier
                             (setq match (funcall modifier match)))
                           (setq instance-exdata match)))
                       (when instance-exdata
                         (setq exdata `(,@exdata ,instance-exdata)))))
                   (when exdata
                     ;; Splice instance data in case of a singular expression
                     (when (not (mrosetta-mlexpression-is-plural mlexpression))
                       (setq exdata (car exdata)))
                     ;; Return the structured semantic data object
                     `(,(or (mrosetta-mlexpression-key mlexpression) :nokey) . ,exdata)))))))))
#+END_SRC

* Text Updating
Process human-readable source text and output the original text semantically updated with the provided data structure.

#+NAME: mrosetta-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-update ((mlexpression mrosetta-mlexpression) &rest args)
  "Process human readable text within the :text or :inner string and return the semantically updated text with the provided :sdata structure within ARGS, as defined by the MLEXPRESSION instance."
  (let ((htext (or (plist-get args :text)
                   (plist-get args :inner)))
        (exkey (car (plist-get args :sdata)))
        (exdata (copy-tree (cdr (plist-get args :sdata))))
        (is-inner (plist-get args :inner))
        (newtext)
        (case-fold-search nil))
    (when (and exdata
               (not (eq exkey
                        (or (mrosetta-mlexpression-key mlexpression) :nokey))))
      (error "Data structure error: Key mismatch"))
    (or (when (and (mrosetta-mlexpression-is-contextual mlexpression) is-inner)
          ;; Return the full inner-text matched within the parent expression or the updated text passed in
          (or exdata htext))
        (save-match-data
          (and htext
               (string-match (mrosetta-mlexpression-regex mlexpression) htext)
               ;; Found metalanguage expression match
               (let ((extext (match-string (mrosetta-mlexpression-regex-key mlexpression) htext))
                     (pos))
                 (save-match-data
                   (while (string-match (mrosetta-mlexpression-rinstance mlexpression) extext pos)
                     (setq pos (match-end 0))
                     ;; Update each instance
                     (let ((instance-exdata (if (mrosetta-mlexpression-is-plural mlexpression) (pop exdata) exdata))
                           (instance-newtext))
                       (if (eq (mrosetta-mlexpression-extype mlexpression) :fractal)
                           ;; Recursively update all fractals within
                           (let ((fractals (mrosetta-mlexpression-fractals mlexpression)))
                             (dolist (fractal fractals)
                               (let* ((fractal-exdata (assq (mrosetta-mlexpression-key fractal) instance-exdata))
                                      (fractal-text (match-string (mrosetta-mlexpression-regex-key fractal) extext))
                                      (fractal-newtext (mrosetta-update fractal :inner fractal-text :sdata fractal-exdata)))
                                 (setq instance-newtext (concat instance-newtext fractal-newtext)))))
                         ;; Update end-elements
                         (let ((left-buffer (match-string (mrosetta-mlexpression-left-rbuffer-key mlexpression) extext))
                               (right-buffer (match-string (mrosetta-mlexpression-right-rbuffer-key mlexpression) extext)))
                           (when (eq (mrosetta-mlexpression-extype mlexpression) :match)
                             ;; Update match text, including ignorable matches
                             (let ((prefix (mrosetta-mlexpression-match-prefix mlexpression))
                                   (suffix (mrosetta-mlexpression-match-suffix mlexpression))
                                   (match (or instance-exdata
                                              (match-string (mrosetta-mlexpression-rmatch-key mlexpression) extext))))
                               (setq instance-newtext (concat left-buffer prefix match suffix right-buffer))))
                           (when (eq (mrosetta-mlexpression-extype mlexpression) :literal)
                             ;; Include the literal, with surrounding buffer
                             (let ((literal (mrosetta-mlexpression-match-literal mlexpression)))
                               (setq instance-newtext (concat left-buffer literal right-buffer))))))
                       (setq newtext (concat newtext instance-newtext))))
                   ;; Return the updated text
                   newtext)))))))
#+END_SRC

* Demos
This section covers various examples of metalanguage syntax.

#+NAME: demo-init
#+BEGIN_SRC emacs-lisp :noweb yes :session mrosetta-demo
<<dependencies>>

<<mrosetta-keychain>>
<<mrosetta-keychain-generate-key>>

<<mrosetta-mlexpression>>

<<mrosetta-mlsyntax>>
<<mrosetta-mlsyntax-modifiers>>

<<mrosetta-parse-literal>>
<<mrosetta-parse-literal-symbol>>
<<mrosetta-parse-word>>
<<mrosetta-parse-word-symbol>>
<<mrosetta-parse-word-uppercase>>
<<mrosetta-parse-word-uppercase-symbol>>
<<mrosetta-parse-word-capitalized>>
<<mrosetta-parse-word-capitalized-symbol>>
<<mrosetta-parse-word-plurality>>
<<mrosetta-parse-word-plurality-symbol>>
<<mrosetta-parse-paragraph>>
<<mrosetta-parse-paragraph-symbol>>
<<mrosetta-parse-paragraph-plurality>>
<<mrosetta-parse-paragraph-plurality-symbol>>
<<mrosetta-parse-substring>>
<<mrosetta-parse-substring-symbol>>
<<mrosetta-parse-prefix>>
<<mrosetta-parse-prefix-symbol>>
<<mrosetta-parse-suffix>>
<<mrosetta-parse-suffix-symbol>>
<<mrosetta-parse-contextual>>
<<mrosetta-parse-contextual-symbol>>
<<mrosetta-parse-modifier-uppercase-symbol>>
<<mrosetta-parse-modifier-lowercase-symbol>>
<<mrosetta-parse-modifier>>
<<mrosetta-parse-modifier-symbol>>
<<mrosetta-parse-optionality>>
<<mrosetta-parse-optionality-symbol>>
<<mrosetta-parse-key>>
<<mrosetta-parse-key-symbol>>
<<mrosetta-parse-ignorable>>
<<mrosetta-parse-ignorable-symbol>>
<<mrosetta-parse-list>>
<<mrosetta-parse-list-symbol>>
<<mrosetta-parse-element>>
<<mrosetta-parse-element-symbol>>
<<mrosetta-parse-of>>
<<mrosetta-parse-of-symbol>>

<<mrosetta-parse>>
<<mrosetta-compile>>
<<mrosetta-process>>
<<mrosetta-update>>

mrosetta-mlsyntax
#+END_SRC

#+RESULTS: demo-init
: ((of . mrosetta-parse-of) (element . mrosetta-parse-element) (list . mrosetta-parse-list) (ignorable . mrosetta-parse-ignorable) (as . mrosetta-parse-key) (optional . mrosetta-parse-optionality) (to . mrosetta-parse-modifier) (contextual . mrosetta-parse-contextual) (suffixed . mrosetta-parse-suffix) (prefixed . mrosetta-parse-prefix) (with . mrosetta-parse-substring) (paragraphs . mrosetta-parse-paragraph-plurality) (paragraph . mrosetta-parse-paragraph) (words . mrosetta-parse-word-plurality) (Word . mrosetta-parse-word-capitalized) (WORD . mrosetta-parse-word-uppercase) (word . mrosetta-parse-word) (literal . mrosetta-parse-literal))

Note that by metalanguage syntax, the outermost expression is auto-parenthesized, thus making it a legitimate list expression.

#+NAME: demo-mlexpression
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input="" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition)))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-process mlexpression :text input))
#+END_SRC

** Words
*** Uppercase Word
Match a single uppercase word.

#+NAME: demo-word-uppercase
#+BEGIN_EXAMPLE
WORD as status
#+END_EXAMPLE

We'll use a following example of input text.

#+NAME: demo-word-uppercase-text
#+BEGIN_EXAMPLE
The current status is OPERATIONAL.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-uppercase, input=demo-word-uppercase-text )

#+RESULTS:
: (status . "OPERATIONAL")

*** Capitalized Word
Match a single capitalized word.

#+NAME: demo-word-capitalized
#+BEGIN_EXAMPLE
Word as title
#+END_EXAMPLE

#+NAME: demo-word-capitalized-text
#+BEGIN_EXAMPLE
Report: All systems operational
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-capitalized, input=demo-word-capitalized-text )

#+RESULTS:
: (title . "Report")

*** A Prefixed Word
Match a single word defined by a specific prefix.

#+NAME: demo-word-prefixed
#+BEGIN_EXAMPLE
"#" prefixed word as tag
#+END_EXAMPLE

#+NAME: demo-word-prefixed-text
#+BEGIN_EXAMPLE
A new task has been created for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-prefixed, input=demo-word-prefixed-text )

#+RESULTS:
: (tag . "devops")

*** A Suffixed Word
Match a single word defined by a specific suffix.

#+NAME: demo-word-suffixed
#+BEGIN_EXAMPLE
"!" suffixed word as priority
#+END_EXAMPLE

#+NAME: demo-word-suffixed-text
#+BEGIN_EXAMPLE
A new critical! issue submitted.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-suffixed, input=demo-word-suffixed-text )

#+RESULTS:
: (priority . "critical")

*** Word with Specific Content
Match a word containing specific content, such as a single character or substring.

#+NAME: demo-word-content
#+BEGIN_EXAMPLE
word with "/" as project
#+END_EXAMPLE

#+NAME: demo-word-content-text
#+BEGIN_EXAMPLE
A new card added in backend/api.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-content, input=demo-word-content-text )

#+RESULTS:
: (project . "backend/api")

*** Word to Uppercase
Modify the matched word to uppercase.

#+NAME: demo-word-to-uppercase
#+BEGIN_EXAMPLE
"!" prefixed word as priority to uppercase
#+END_EXAMPLE

#+NAME: demo-word-to-uppercase-text
#+BEGIN_EXAMPLE
[!high] Received a new support ticket.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-uppercase, input=demo-word-to-uppercase-text )

#+RESULTS:
: (priority . "HIGH")

*** Word to Lowercase
Modify the matched word to lowercase.

#+NAME: demo-word-to-lowercase
#+BEGIN_EXAMPLE
"#" prefixed word as label to lowercase
#+END_EXAMPLE

#+NAME: demo-word-to-lowercase-text
#+BEGIN_EXAMPLE
New message received marked for #Support!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-to-lowercase, input=demo-word-to-lowercase-text )

#+RESULTS:
: (label . "support")

*** List of Words
Match a list of words matching defined criteria.

#+NAME: demo-word-list
#+BEGIN_EXAMPLE
":" prefixed words as tags
#+END_EXAMPLE

#+NAME: demo-word-list-text
#+BEGIN_EXAMPLE
Task completed successfully :devops :api!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-word-list, input=demo-word-list-text )

#+RESULTS:
: (tags "devops" "api")

** Paragraphs
*** Paragraph Based on Criteria
Match a paragraph of text conforming with specified criteria. Note that in order to successfully match a paragraph of text, both boundaries need to be either explicitly or contextually specified.

When explicitly setting boundaries, the left boundary is implicitly the first possibly matched character.

#+NAME: demo-paragraph
#+BEGIN_EXAMPLE
": " prefixed "." suffixed paragraph as status
#+END_EXAMPLE

#+NAME: demo-paragraph-text
#+BEGIN_EXAMPLE
Status update: API service started successfully.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph, input=demo-paragraph-text )

#+RESULTS:
: (status . "API service started successfully")

*** List of Paragraphs
Match a list of consecutive paragraphs defined by specified criteria.

#+NAME: demo-paragraph-list
#+BEGIN_EXAMPLE
"." suffixed paragraphs as statements to lowercase
#+END_EXAMPLE

#+NAME: demo-paragraph-list-text
#+BEGIN_EXAMPLE
One task completed. Three tasks updated. Two tasks created.
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-paragraph-list, input=demo-paragraph-list-text )

#+RESULTS:
: (statements "one task completed" "three tasks updated" "two tasks created")

** Complex Expressions
*** All-inclusive Match
Match multiple elements alongside ignorable information within human readable text. Structure the semantic match within a root property.

#+NAME: demo-complex
#+BEGIN_EXAMPLE
element of ((WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)) as task
#+END_EXAMPLE

#+NAME: demo-complex-text
#+BEGIN_EXAMPLE
CRITICAL Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex, input=demo-complex-text )

#+RESULTS:
: (task (priority . "critical") (project . "backend/api") (type . "devops"))

*** Optional Matches
Match multiple elements, one or more of which are optional in presence and aren't required to trigger a semantic match.

#+NAME: demo-complex-optional
#+BEGIN_EXAMPLE
(optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed word as type)
#+END_EXAMPLE

The following text example doesn't contain an optional element. As expected, the structured data output is processed and matched, excluding the missing optional element.

#+NAME: demo-complex-optional-text
#+BEGIN_EXAMPLE
Task created in backend/api for #devops!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-optional-text )

#+RESULTS:
: (:nokey (project . "backend/api") (type . "devops"))

By passing the example from above, containing the optional priority element, the output structure includes and matches the element.

#+CALL: demo-mlexpression( definition=demo-complex-optional, input=demo-complex-text )

#+RESULTS:
: (:nokey (priority . "critical") (project . "backend/api") (type . "devops"))

*** Complex Collections
Match multiple occurrences of expressions containing multiple elements.

#+NAME: demo-complex-collection
#+BEGIN_EXAMPLE
"!" suffixed list of ((optional WORD as priority to lowercase) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types))
#+END_EXAMPLE

#+NAME: demo-complex-collection-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops! Task created in web/home for #frontend #design! BLOCKER task created in backend/api for #backend!
#+END_EXAMPLE

#+CALL: demo-mlexpression( definition=demo-complex-collection, input=demo-complex-collection-text )

#+RESULTS:
: (:nokey ((priority . "critical") (project . "backend/api") (types "devops")) ((project . "web/home") (types "frontend" "design")) ((priority . "blocker") (project . "backend/api") (types "backend")))

** Text Regeneration
Update the original text with new semantic information from passed in structured data.

#+NAME: demo-mlexpression-update
#+BEGIN_SRC emacs-lisp :session mrosetta-demo :var definition="" input-text="" input-data=""" :results value verbatim
(let* ((mldefinition (car (read-from-string (concat "(" definition ")"))))
       (mlexpression (mrosetta-mlexpression :mldefinition mldefinition))
       (sdata `(:nokey . ,(car (read-from-string (concat "(" input-data ")"))))))
  (mrosetta-parse mlexpression)
  (mrosetta-compile mlexpression)
  (mrosetta-update mlexpression :text input-text :sdata sdata))
#+END_SRC

#+NAME: demo-regen
#+BEGIN_EXAMPLE
(WORD as priority) (ignorable contextual paragraph) (word with "/" as project) (ignorable contextual paragraph) ("#" prefixed words as types) (ignorable contextual paragraph)
#+END_EXAMPLE

#+NAME: demo-regen-text
#+BEGIN_EXAMPLE
CRITICAL task created in backend/api for #devops #backend!
#+END_EXAMPLE

The structured data from input text will look like so:

#+CALL: demo-mlexpression( definition=demo-regen, input=demo-regen-text )

#+RESULTS:
: (:nokey (priority . "CRITICAL") (project . "backend/api") (types "devops" "backend"))

Now, we can pass in an updated property or two. The properties not included will remain intact.

#+NAME: demo-regen-data
#+BEGIN_EXAMPLE
(priority . "BLOCKER") (types "backend" "frontend")
#+END_EXAMPLE

#+CALL: demo-mlexpression-update( definition=demo-regen, input-text=demo-regen-text, input-data=demo-regen-data )

#+RESULTS:
: "BLOCKER task created in backend/api for #backend #frontend!"

* Connectors
Supported connections through which structured semantic data is sent, in addition to semantic updates being received.

** Agnostic Interface
The general interface used to send/receive structured data in and out of the human textual context.

#+NAME: mrosetta-connector
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-connector ()
  ()
  "A base class defining the general interface used to send/receive structured data defined by Metarosetta expressions."
  :abstract t)
#+END_SRC
*** Expression Parameters
An interface for the Metarosetta context to get and set connector-specific parameters required for the connector to function.

The parameters are scoped to a defined metalanguage expression. Through such parameters, it's possible to set things like expression-specific connector endpoints, query parameters, contextual filters and so on.

#+NAME: mrosetta-connector-parameters
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-parameters ((connector-class (subclass mrosetta-connector)))
  "Get the connector-specific expression parameters required for the CONNECTOR-CLASS. Return a list of parameter keywords."
  (error "Connector implementation error: Method mrosetta-connector-parameters not implemented in `%s'" (symbol-name (eieio-class-name connector-class))))
#+END_SRC
*** Send
Send structured data to an API endpoint.

#+NAME: mrosetta-connector-send
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-send ((connector mrosetta-connector) _key _sdata _callback _cparameters)
  "Using the specified CONNECTOR, send the SDATA containing a list of processed text instances with specified connector-specific CPARAMETERS. The KEY defines the property symbol considered as an instance key, wherein the same-id instances are overwritten. Call back the CALLBACK function when done."
  (error "Connector implementation error: Method mrosetta-connector-send not implemented in `%s'" (symbol-name (eieio-object-class-name connector))))
#+END_SRC
*** Receive
Receive structured data from an API endpoint.

#+NAME: mrosetta-connector-receive
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-receive ((connector mrosetta-connector) _key _value _callback _cparameters)
  "Using the specified CONNECTOR, receive structured data entries whose KEY equals to VALUE with specified connector-specific CPARAMETERS. Call back the CALLBACK function when done."
  (error "Connector implementation error: Method mrosetta-connector-receive not implemented in `%s'" (symbol-name (eieio-object-class-name connector))))
#+END_SRC
** Implementations
This section contains all platform-specific connectors implementing the above specified interface for sending and receiving structured semantic data in sync with the human text in context.

*** Connector Helper Functions
Convenience wrappers around Emac' builtin ~url.el~.

**** Send and Receive JSON Data
Send the provided Lisp object (if any) as serialized JSON to the provided endpoint. Upon completion, call back the provided callback function along with the status code and payload, if any. In case of an error, call back the callback function with the status code and message.

#+NAME: mrosetta-connector-url-snr
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-connector-url-snr (url &rest uargs)
  "Send the provided :payload object, if provided, as JSON payload to the URL endpoint, while, within UARGS, specifying the connection :header-auth value and :callback function to call upon completion, with the :success status, :status-code and returned :payload object, if any, or :status-message in case of an error."
  (let ((full-url (concat url
                          ;; Append the query section if :qparams specified
                          (when (plist-get uargs :qparams)
                            (concat "?"
                                    ;; Map all the provided query parameters along with their corresponding values
                                    (mapconcat (lambda (parampair)
                                                 (let ((param (car parampair))
                                                       (value (cdr parampair)))
                                                   (concat param "=" value)))
                                               (plist-get uargs :qparams)
                                               "&")))))
        (url-request-method (plist-get uargs :verb))
        (url-request-extra-headers `(("Authorization" . ,(plist-get uargs :header-auth))
                                     ("Content-Type" . "application/json")))
        (url-request-data (when (plist-get uargs :payload)
                            (json-serialize (plist-get uargs :payload))))
        (callback (plist-get uargs :callback)))
    (with-current-buffer (url-retrieve-synchronously full-url)
      (let (success
            status-code
            status-message
            payload)
        ;; Start at the beginning of the current buffer
        (goto-char (point-min))
        ;; Set the status code
        (setq status-code (url-http-symbol-value-in-buffer 'url-http-response-status (current-buffer)))
        ;; Move past header data
        (goto-char url-http-end-of-headers)
        ;; Get and parse the payload data
        (setq payload (json-parse-buffer :object-type 'alist))
        ;; Parse the status code
        (if (eq (/ status-code 100) 2)
            ;; If 2xx signal success
            (setq success t)
          ;; Else, set the status message from the payload
          (setq status-message (cdr (assq 'message payload))))
        ;; Call back the callback function with the response data
        (funcall callback
                 :success success
                 :status-code status-code
                 :status-message status-message
                 :payload payload))
      (kill-buffer))))
#+END_SRC
*** Coda
Coda is a user-friendly platform-agnostic app platform, where apps take form of /documents/. For more info see their [[https://coda.io/][website]].

This connector enables two-way synchronization between human-readable text and its structured semantics persisted and organized as Coda table entries.

Please note that, at this time, the Coda connector *only* supports non-nested semantic structures, where property values can either be simple values like strings or numbers and lists of simple values.

**** Connector Class
To interact with Coda, a Coda connector instance is created with a valid API token set by the ~:token~ keyword.

#+NAME: mrosetta-connector-coda
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-connector-coda (mrosetta-connector)
  ((token
    :initarg :token
    :type string
    :documentation "The bearer token used to authenticate against the Coda API."
    :reader mrosetta-connector-coda-token)))
#+END_SRC
**** Expression Parameters
Return the list of expression-specific parameters the Coda connector needs in order to locate the corresponding table which the matched semantic data is synced to.

Namely, the ~:doc-id~ which sets the targeted Coda document id and the ~:table-id~ which sets the expression-corresponding Coda table id.

#+NAME: mrosetta-connector-coda-parameters
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-parameters ((_connector-class (subclass mrosetta-connector-coda)))
  "Return the expression-related connector parameters of the Coda CONNETOR-CLASS."
  `(:doc-id
    :table-id))
#+END_SRC
**** Send Semantic Data
Send the provided semantic data to a Coda table. Note that the table schema must match the metalanguage expression's output structure, including the property naming. The ~key~ symbol denotes the property considered as the match instance identifier, where previous records with the same id get overwritten with the newly sent ones.

As noted above, the connector parameter defined by the ~:doc-id~ keyword sets the targeted Coda document id, while ~:table-id~ the corresponding table id.

In terms of ~callback~, the callback's first argument receives either ~t~ if operation successful, or ~nil~ otherwise. If unsuccessful, an argument defined by the ~:message~ key contains a human-readable message pertaining to the nature of the error in context.

#+NAME: mrosetta-connector-coda-send
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-send ((connector mrosetta-connector-coda) key sdata callback cparameters)
  "Using the specified Coda CONNECTOR, send the SDATA list of processed textual instances, defined by the KEY property, with specified CPARAMETERS. Specify CALLBACK function for response callback."
  (let ((token (mrosetta-connector-coda-token connector))
        (doc-id (plist-get cparameters :doc-id))
        (table-id (plist-get cparameters :table-id))
        (payload `((rows . [])
                   (keyColumns . ,(vector (symbol-name key))))))
    ;; Process the semantic data into a compatible payload structure, iterating over all provided instances within the semantic data structure
    (setf (cdr (assq 'rows payload)) (vconcat (mapcar (lambda (instance)
                                                        ;; Map all property-value pairs to a payload-compatible format
                                                        `((cells . ,(vconcat (mapcar (lambda (pvpair)
                                                                                       `((column . ,(symbol-name (car pvpair)))
                                                                                         (value . ,(let ((value (cdr pvpair)))
                                                                                                     (if (listp value)
                                                                                                         (vconcat value)
                                                                                                       value)))))
                                                                                     instance)))))
                                                      sdata)))
    ;; Send the data
    (mrosetta-connector-url-snr (concat "https://coda.io/apis/v1/docs/" doc-id "/tables/" table-id "/rows")
                                :verb "POST"
                                :header-auth (concat "Bearer " token)
                                :payload payload
                                :callback (lambda (&rest cbargs)
                                            (let ((success (plist-get cbargs :success))
                                                  (status-message (plist-get cbargs :status-message)))
                                              (funcall callback success :message status-message))))))
#+END_SRC
**** Receive Semantic Data
Receive semantic data from a Coda table based on query parameters.

The query is defined through the ~key~ and ~value~ arguments, along with the standard ~:doc-id~ and ~:table-id~ connector parameters.

In terms of ~callback~, the callback's first argument receives the resulting semantic data in the form of a list of semantic property-value instances, or ~nil~ if the operation was unsuccessful. If so, it receives the ~:message~ defined argument containing the human-readable error message.

#+NAME: mrosetta-connector-coda-receive
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-connector-receive ((connector mrosetta-connector-coda) key value callback cparameters)
  "Using the specified Coda CONNECTOR, receive semantic data based on the provided KEY property and corresponding VALUE, with specified CPARAMETERS. Specify CALLBACK function for response callback containing the requested data."
  (let* ((token (mrosetta-connector-coda-token connector))
         (doc-id (plist-get cparameters :doc-id))
         (table-id (plist-get cparameters :table-id))
         ;; Method-internal connector parameters
         (page-token (plist-get cparameters :page-token))
         (sdata (or (plist-get cparameters :sdata) '())))
    ;; Receive the data
    (mrosetta-connector-url-snr (concat "https://coda.io/apis/v1/docs/" doc-id "/tables/" table-id "/rows")
                                :verb "GET"
                                :header-auth (concat "Bearer " token)
                                :qparams (if page-token
                                             ;; Fetch the next page of the request in current context
                                             `(("pageToken" . ,page-token))
                                           ;; Create a new request based on parameter criteria
                                           `(("query" . ,(concat "\"" (symbol-name key) "\""
                                                                 ":"
                                                                 (when (stringp value) "\"")
                                                                 value
                                                                 (when (stringp value) "\"")))
                                             ("useColumnNames" . "true")
                                             ("valueFormat" . "simpleWithArrays")))
                                :callback (lambda (&rest cbargs)
                                            (let ((success (plist-get cbargs :success))
                                                  (status-message (plist-get cbargs :status-message))
                                                  (payload (plist-get cbargs :payload)))
                                              (or (and success
                                                       ;; Request successful, process received payload
                                                       (let ((payload-items (cdr (assq 'items payload)))
                                                             (next-page-token (cdr (assq 'nextPageToken payload))))
                                                         ;; Compile the current payload into the sdata object
                                                         (and payload-items
                                                              (setq sdata `(,@sdata ,@(mapcar (lambda (payload-item)
                                                                                                (mapcar (lambda (pvpair)
                                                                                                          (let ((property (car pvpair))
                                                                                                                (value (cdr pvpair)))
                                                                                                            `(,property . ,(if (vectorp value)
                                                                                                                               `(,@value)
                                                                                                                             value))))
                                                                                                        (cdr (assq 'values payload-item))))
                                                                                              payload-items)))
                                                              (or (and next-page-token
                                                                       ;; Move on to the next page of data
                                                                       (prog1 t
                                                                         (mrosetta-connector-receive connector key value callback `(:doc-id ,doc-id
                                                                                                                                    :table-id ,table-id
                                                                                                                                    :page-token ,next-page-token
                                                                                                                                    :sdata ,sdata))))
                                                                  ;; No more pages, return the compiled data
                                                                  (prog1 t
                                                                    (funcall callback sdata))))))
                                                  ;; Something went wrong, return the error message
                                                  (prog1 t
                                                    (funcall callback nil :message status-message))))))))
#+END_SRC
* Contexts
Compatible environments in which metalanguage expressions can be defined and input text natively processed.

** Org
Define context-specific metalanguage expressions which automatically process matching org-mode headers.

*** Org Helper Functions
Helper functions to get and set targeted org headers.

**** Get Heading
Get the full text of the heading, excluding the leading asterisks.

#+NAME: mrosetta-context-org-heading-get
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-context-org-heading-get ()
  "Get the full org heading at point as plain string, excluding the leading asterisks."
  (let ((curr-pos (line-beginning-position)))
    ;; Skip the leading asterisks and spaces
    (while (or (char-equal (char-after curr-pos) ?*)
               (char-equal (char-after curr-pos) ?\s))
      (setq curr-pos (1+ curr-pos)))
    ;; Get rest of heading content as string
    (buffer-substring-no-properties curr-pos (line-end-position))))
#+END_SRC
**** Set Heading
Set the full text of the heading, preserving the leading asterisks.

#+NAME: mrosetta-context-org-heading-set
#+BEGIN_SRC emacs-lisp :tangle yes
(defun mrosetta-context-org-heading-set (heading-text)
  "Set the full text of the org heading at point to HEADING-TEXT, while preserving the leading asterisks."
  ;; Start at the beginning of set line
  (goto-char (line-beginning-position))
  ;; Skip the leading asterisks and spaces
  (while (or (char-equal (following-char) ?*)
             (char-equal (following-char) ?\s))
    (forward-char))
  ;; Delete the rest of heading content
  (delete-region (point) (line-end-position))
  ;; Insert the new content at point
  (insert heading-text))
#+END_SRC
*** Match Index
In order to keep track of all the matched headings across all defined metalanguage expressions agnostic of the org file where the definitions (or matches) are written, an index structure serves as a singular source of truth.

In terms of implementation and data persistence, the index is structured as a persistent composition, with all the elements classified by their matching expression.

**** Collection Manager
A per-collection object used to manage items contained within along with their collection-dependent properties such as unique id.

#+NAME: mrosetta-context-org-collection
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-collection ()
  ((keychain
    :initarg :keychain
    :initform (mrosetta-keychain)
    :type mrosetta-keychain
    :documentation "The keychain instance used to generate item keys within the scope of the encompassing collection instance.")
   (item-class
    :initarg :item-class
    :type symbol
    :documentation "The containing items' class symbol.")
   (items
    :initform '()
    :type list
    :documentation "An alist of items, mapped by id, contained within the encompassing collection instance."
    :reader mrosetta-context-org-collection-items))
  "A collection manager of tracked org entry items within a specific scope. Must be subclassed with items of specific type.")
#+END_SRC

***** Setting Items
Add or update items within the collection instance.

#+NAME: mrosetta-context-org-collection-set
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-collection-set ((collection mrosetta-context-org-collection) item)
  "Add or reset the ITEM within the managed org COLLECTION."
  (when (not (eq (slot-value collection 'item-class)
                 (eieio-object-class item)))
    (error "Collection class mismatch error: The provided item is incompatible with the encompassing collection"))
  (let ((item-id (or (mrosetta-context-org-entry-id item)
                     (mrosetta-keychain-generate-key (slot-value collection 'keychain)))))
    (mrosetta-context-org-entry-id-set item item-id)
    ;; Add the new item to collection, potentially replacing an existing one
    (setf (slot-value collection 'items) (assq-delete-all item-id (slot-value collection 'items)))
    (push `(,item-id . ,item) (slot-value collection 'items))
    item))
#+END_SRC
***** Getting Items
Get an item from the collection instance.

#+NAME: mrosetta-context-org-collection-get
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-collection-get ((collection mrosetta-context-org-collection) item-id)
  "Get an item from the COLLECTION defined by the provided ITEM-ID. Return the item or nil if none present."
  (cdr (assq item-id (slot-value collection 'items))))
#+END_SRC
**** Org Entries
An index element referring to an org entry. These can be either metalanguage expressions or matches themselves. Both contain general as well as specific properties.

#+NAME: mrosetta-context-org-entry
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-entry ()
  ((id
    :initarg :id
    :initform 'nil
    :type (or null number)
    :documentation "The entry identifier within the scope of its encompassing collection."
    :reader mrosetta-context-org-entry-id
    :writer mrosetta-context-org-entry-id-set)
   (org-file
    :initarg :org-file
    :type string
    :documentation "The org file within which the encompassing entry is set."
    :reader mrosetta-context-org-entry-file))
  "An org entry reference matched within the Metarosetta framework."
  :abstract t)
#+END_SRC

***** ML Expression Org Entry
An index element referring to an org entry which defines a metalanguage expression. These definitions can be defined *anywhere* within *any* org file, as long as they're a proper org heading.

Naturally, updating this org entry within its original context automatically updates the expression itself.

#+NAME: mrosetta-context-org-mlexpression
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-mlexpression (mrosetta-context-org-entry)
  ((mldefinition
    :initarg :mldefinition
    :type list
    :documentation "The metalanguage definition referring to the org entry in context."
    :reader mrosetta-context-org-mlexpression-mldefinition
    :writer mrosetta-context-org-mlexpression-mldefinition-set)
   (cparameters
    :initarg :cparameters
    :initform '()
    :type list
    :documentation "The list of connector-specific parameters in form of an alist containing parameter-value pairs."
    :reader mrosetta-context-org-mlexpression-cparameters
    :writer mrosetta-context-org-mlexpression-cparameters-set)
   (match-collection
    :initarg :match-collection
    :initform (mrosetta-context-org-collection :item-class 'mrosetta-context-org-match)
    :type mrosetta-context-org-collection
    :documentation "The managed collection of all current matches corresponding to the metalanguage expression in context."
    :reader mrosetta-context-org-mlexpression-match-collection)
   (match-compilation
    :initarg :match-compilation
    :initform '()
    :type (list-of mrosetta-context-org-match)
    :documentation "The compiled list corresponding to the collection of matches. Used only for (de)serialization."))
  "An org entry referencing a particular metalanguage definition.")
#+END_SRC
***** ML Expression Match Org Entry
An index element referring to a matching org entry in context of a particular metalanguage expression.

#+NAME: mrosetta-context-org-match
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-match (mrosetta-context-org-entry)
  ((sync-id
    :initarg :sync-id
    :initform '0
    :type number
    :documentation "A synchronization id specifying the exact version of the match. Each update, from any side, increments the sync id."
    :reader mrosetta-context-org-match-sync-id
    :writer mrosetta-context-org-match-sync-id-set))
  "An org entry referencing a specific match in context of a particular metalanguage definition.")
#+END_SRC

****** Methods
******* Confirm Sync
Confirm successful synchronization by updating the sync id of the match.

#+NAME: mrosetta-context-org-match-sync-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-match-sync-update ((match mrosetta-context-org-match))
  "Update the sync id of the MATCH."
  (setf (slot-value match 'sync-id) (1+ (slot-value match 'sync-id))))
#+END_SRC
**** Index Persistence
A datastore object used as an entry point for the indexed data, as well as a point of serialization to and deserialization from the disk.

#+NAME: mrosetta-context-org-db
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org-db (eieio-persistent)
  ((file :initarg :file)
   (mlexpression-collection
    :initarg :mlexpression-collection
    :initform (mrosetta-context-org-collection :item-class 'mrosetta-context-org-mlexpression)
    :type mrosetta-context-org-collection
    :documentation "A managed collection of all defined and tracked metalanguage expressions in scope of the Metarosetta package."
    :reader mrosetta-context-org-db-mlexpression-collection)
   (mlexpression-compilation
    :initarg :mlexpression-compilation
    :initform '()
    :type (list-of mrosetta-context-org-mlexpression)
    :documentation "The compiled list corresponding to the collection of mlexpressions. Used only for (de)serialization."))
  "The root index object for all metalanguage definitions and matches within the org context.")
#+END_SRC
**** Index Compilation
In order to persist the org index using ~eieio-persistent~ methods, all collection objects must be compiled into strictly-typed linear lists.

#+NAME: mrosetta-context-org-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defgeneric mrosetta-context-org-compile (context-org-object)
  "Compile the CONTEXT-ORG-OBJECT into a compatible format for serialization to disk.")
#+END_SRC

***** Collection
Compile the collection for serialization to disk. Also compile all nested collections, if any.

#+NAME:  mrosetta-context-org-compile-collection
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((collection mrosetta-context-org-collection))
  "Recursively compile the items contained within the COLLECTION. Return the compiled list."
  (mapcar (lambda (item-pair)
            (let ((item (cdr item-pair)))
              (mrosetta-context-org-compile item)))
          (slot-value collection 'items)))
#+END_SRC
***** Entries
Compile the index entries themselves.

****** Base Entry
The default compilation method matching any org entry.

#+NAME: mrosetta-context-org-compile-entry
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((entry mrosetta-context-org-entry))
  "Compile the ENTRY for serialization to disk."
  ;; Nothing to compile, all slots are directly compatible
  entry)
#+END_SRC
****** ML Expression
Compile the metalanguage expression org context index entry.

#+NAME: mrosetta-context-org-compile-mlexpression
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((mlexpression-entry mrosetta-context-org-mlexpression))
  "Compile the MLEXPRESSION-ENTRY for serialization to disk."
  (setf (slot-value mlexpression-entry 'match-compilation)
        (mrosetta-context-org-compile (slot-value mlexpression-entry 'match-collection)))
  (cl-call-next-method mlexpression-entry))
#+END_SRC
****** Root
Compile the root ~db~ object.

#+NAME: mrosetta-context-org-compile-db
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-compile ((db mrosetta-context-org-db))
  "Compile the root DB entry object for serialization to disk."
  (setf (slot-value db 'mlexpression-compilation)
        (mrosetta-context-org-compile (slot-value db 'mlexpression-collection)))
  db)
#+END_SRC
**** Index Decompilation
Upon loading a previously saved instance of the org index, all collection objects must be decompiled for proper use.

#+NAME: mrosetta-context-org-decompile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defgeneric mrosetta-context-org-decompile (context-org-object &optional compilation)
  "Decompile the contents of the CONTEXT-ORG-OBJECT from the provided COMPILATION, or an inner slot if structured as such.")
#+END_SRC

***** Collection
Decompile the collection from a provided serialized list of compatible items.

#+NAME: mrosetta-context-org-decompile-collection
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((collection mrosetta-context-org-collection) &optional compilation)
  "Recursively decompile the COMPILATION of items into the COLLECTION."
  (setf (slot-value collection 'items)
        (mapcar (lambda (item)
                  `(,(mrosetta-context-org-entry-id item) . ,(mrosetta-context-org-decompile item)))
                compilation))
  collection)
#+END_SRC
***** Entries
Decompile the index entries.

****** Base Entry
The default decompilation method matching any org entry.

#+NAME: mrosetta-context-org-decompile-entry
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((entry mrosetta-context-org-entry) &optional _compilation)
  "Decompile the contents of the ENTRY from a compilation slot within, not the provided COMPILATION argument."
  ;; Nothing to decompile, all slots are directly usable
  entry)
#+END_SRC
****** ML Expression
Decompile the metalanguage expression org context index entry.

#+NAME: mrosetta-context-org-decompile-mlexpression
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((mlexpression-entry mrosetta-context-org-mlexpression) &optional _compilation)
  "Decompile the contents of the MLEXPRESSION-ENTRY from a compilation slot within, not the provided COMPILATION argument."
  (mrosetta-context-org-decompile (slot-value mlexpression-entry 'match-collection)
                                  (slot-value mlexpression-entry 'match-compilation))
  ;; Clear the compiled list after decompilation
  (setf (slot-value mlexpression-entry 'match-compilation) '())
  (cl-call-next-method mlexpression-entry))
#+END_SRC
****** Root
Decompile the root ~db~ object.

#+NAME: mrosetta-context-org-decompile-db
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-decompile ((db mrosetta-context-org-db) &optional _compilation)
  "Decompile the contents of DB from a compilation slot within, not the provided COMPILATION argument."
  (mrosetta-context-org-decompile (slot-value db 'mlexpression-collection)
                                  (slot-value db 'mlexpression-compilation))
  ;; Clear the compiled list after decompilation
  (setf (slot-value db 'mlexpression-compilation) '())
  db)
#+END_SRC
*** Context Object
The object handling all Metarosetta-related operations within the org context.

#+NAME: mrosetta-context-org
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-context-org ()
  ((index-file
    :initform 'nil
    :type (or null string)
    :documentation "The file to which the Metarosetta context will persist all current data from the corresponding index datastore."
    :reader mrosetta-context-org-index-file)
   (index
    :initform 'nil
    :type (or null mrosetta-context-org-db)
    :documentation "The active datastore of the current Metarosetta context, containing all defined metalagnuage definitions with their respectively tracked matches."
    :reader mrosetta-context-org-index)
   (mlexpressions
    :initform '()
    :type list
    :documentation "The current session's cache containing all compiled metalanguage expressions active in current context."
    :reader mrosetta-context-org-mlexpressions)
   (sync-interval
    :initform 'nil
    :type (or null number)
    :documentation "The synchronization interval for the current context. If non-nil, specifies the number of seconds between synchronization requests using the provided connector instance."
    :reader mrosetta-context-org-sync-interval)
   (connector
    :initarg :connector
    :type mrosetta-connector
    :documentation "The connector instance to use within the current context"
    :reader mrosetta-context-org-connector))
  "The Metarosetta org context object. Handles all Metarosetta-related operations within the org context.")
#+END_SRC

**** Load Context
Load the context index from previous Emacs sessions.

#+NAME: mrosetta-context-org-load
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-load ((context mrosetta-context-org) index-file)
  "If not already loaded or loaded with something else, (re)load the index datastore from INDEX-FILE, or create a new one if none exists, and compile all indexed Metalanguage expressions within the CONTEXT."
  (when (or (not (slot-value context 'index-file))
            (not (string-equal (slot-value context 'index-file)
                               index-file)))
    (setf (slot-value context 'index-file) index-file)
    ;; Load the index datastore
    (let ((index (setf (slot-value context 'index) (or (when (file-exists-p index-file)
                                                         (eieio-persistent-read index-file 'mrosetta-context-org-db))
                                                       (mrosetta-context-org-db :file index-file)))))
      ;; Decompile index entries
      (mrosetta-context-org-decompile index)
      ;; Initialize the registered Metalanguage expression instances
      (setf (slot-value context 'mlexpressions)
            (mapcar (lambda (org-mlexpression-pair)
                      (let* ((org-mlexpression-id (car org-mlexpression-pair))
                             (org-mlexpression-entry (cdr org-mlexpression-pair))
                             (mlexpression (mrosetta-mlexpression :mldefinition (mrosetta-context-org-mlexpression-mldefinition org-mlexpression-entry))))
                        ;; Parse and compile the metalanguage expression
                        (mrosetta-parse mlexpression)
                        (mrosetta-compile mlexpression)
                        ;; Return the metalanguage expression pair
                        `(,org-mlexpression-id . ,mlexpression)))
                    (mrosetta-context-org-collection-items (mrosetta-context-org-db-mlexpression-collection index))))))
  ;; Just return the loaded context
  context)
#+END_SRC
**** Save Context
Persist context index after quitting Emacs.

#+NAME: mrosetta-context-org-save
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-save ((context mrosetta-context-org))
  "Save CONTEXT index to the file defined within."
  (let ((index (slot-value context 'index)))
    ;; Compile index entries into serializable form
    (mrosetta-context-org-compile index)
    ;; Save the index datastore
    (eieio-persistent-save index)))
#+END_SRC
**** Handler Functions
This section covers the operational functionality of the org context.

***** Process Org Heading
Process the org heading at point.

#+NAME: mrosetta-context-org-process
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-process-heading ((context mrosetta-context-org))
  "Process the heading at point by the provided Metarosetta CONTEXT."
  (let ((heading-text (mrosetta-context-org-heading-get)))
    (and heading-text
         (or (and (string-match "#mrosetta[[:blank:]]+\\(.+\\)" heading-text)
                  ;; Process the Metarosetta Metalanguage expression definition
                  (let* ((input-text (match-string 1 heading-text))
                         (mldefinition (car (read-from-string (concat "(" input-text ")"))))
                         (mlexpression-id (let ((id-property (org-entry-get (point) "mrosetta-mlexpression-id")))
                                            (when (and id-property
                                                       (not (string-empty-p id-property)))
                                              (string-to-number id-property))))
                         (mlexpression-index (mrosetta-context-org-db-mlexpression-collection (mrosetta-context-org-index context)))
                         (mlexpression-index-entry (or (let ((entry (mrosetta-context-org-collection-get mlexpression-index mlexpression-id)))
                                                         (when entry
                                                           (mrosetta-context-org-mlexpression-mldefinition-set entry mldefinition)
                                                           entry))
                                                       (mrosetta-context-org-mlexpression :org-file (buffer-file-name)
                                                                                          :mldefinition mldefinition)))
                         (mlexpression (mrosetta-mlexpression :mldefinition mldefinition))
                         (connector (mrosetta-context-org-connector context))
                         (cparameters (mrosetta-connector-parameters (eieio-object-class connector))))
                    (prog1 t ;; Regardless of the processing result, the match itself is valid and should return as such
                      ;; Fetch connector-specific parameters from org-entry and update the object
                      (mrosetta-context-org-mlexpression-cparameters-set mlexpression-index-entry
                                                                         (mapcar (lambda (cparameter)
                                                                                   `(,cparameter . ,(org-entry-get (point)
                                                                                                                   (concat "mrosetta-mlexpression-connector-"
                                                                                                                           ;; Convert keyword symbol to simple string
                                                                                                                           (substring (symbol-name cparameter) 1)))))
                                                                                 cparameters))
                      ;; Index the entry
                      (setq mlexpression-index-entry (mrosetta-context-org-collection-set mlexpression-index mlexpression-index-entry))
                      (setq mlexpression-id (mrosetta-context-org-entry-id mlexpression-index-entry))
                      ;; Parse and compile the Metalanguage expression
                      (mrosetta-parse mlexpression)
                      (mrosetta-compile mlexpression)
                      ;; Cache the Metalanguage expression, replacing the previous entry if needed
                      (setf (slot-value context 'mlexpressions) (assq-delete-all mlexpression-id (slot-value context 'mlexpressions)))
                      (push `(,mlexpression-id . ,mlexpression) (slot-value context 'mlexpressions))
                      ;; Populate the org entry istelf with Metarosetta properties
                      ;; Expression ID
                      (org-entry-put (point) "mrosetta-mlexpression-id" (number-to-string mlexpression-id))
                      ;; Connector-specific parameters
                      (dolist (cparameter-pair (mrosetta-context-org-mlexpression-cparameters mlexpression-index-entry))
                        (let ((key (car cparameter-pair))
                              (value (cdr cparameter-pair)))
                          (org-entry-put (point)
                                         (concat "mrosetta-mlexpression-connector-"
                                                 (substring (symbol-name key) 1))
                                         (or value ""))))
                      ;; Notify the user
                      (message "Mrosetta Metalanguage expression processed successfully!"))))
             (let* ((did-match nil)
                    (mlexpression-cache (mrosetta-context-org-mlexpressions context))
                    (mlexpression-ids (mapcar (lambda (mlexpression-pair) (car mlexpression-pair))
                                              mlexpression-cache)))
               ;; Check if provided heading matches any of the active Metalanguage expressions
               (while (let ((mlexpression-id (pop mlexpression-ids)))
                        (and mlexpression-id
                             (let* ((mlexpression (cdr (assq mlexpression-id mlexpression-cache)))
                                    (exdata (mrosetta-process mlexpression :text heading-text)))
                               ;; If matched, sync through connector in context and stop iterating
                               ;; If not, continue to the next possible Metalanguage expression match
                               (not (and exdata
                                         (let* ((sdata (cdr exdata))
                                                (connector (mrosetta-context-org-connector context))
                                                (mlexpression-index-entry (mrosetta-context-org-collection-get (mrosetta-context-org-db-mlexpression-collection (mrosetta-context-org-index context))
                                                                                                               mlexpression-id))
                                                (cparameters (mapcan (lambda (cparameter-pair)
                                                                       `(,(car cparameter-pair) ,(cdr cparameter-pair)))
                                                                     (mrosetta-context-org-mlexpression-cparameters mlexpression-index-entry)))
                                                (mlexpression-match-index (mrosetta-context-org-mlexpression-match-collection mlexpression-index-entry))
                                                (match-id (let ((id-property (org-entry-get (point) "mrosetta-match-id")))
                                                            (when (and id-property
                                                                       (not (string-empty-p id-property)))
                                                              (string-to-number id-property))))
                                                (match-index-entry (or (mrosetta-context-org-collection-get mlexpression-match-index match-id)
                                                                       (mrosetta-context-org-match :org-file (buffer-file-name))))
                                                (match-sync-id (mrosetta-context-org-match-sync-update match-index-entry)))
                                           (prog1 t ;; Regardless if the sync actually succeeded, the match itself is valid and should return as such
                                             ;; Add index entry, if new
                                             (setq match-index-entry (mrosetta-context-org-collection-set mlexpression-match-index match-index-entry))
                                             (setq match-id (mrosetta-context-org-entry-id match-index-entry))
                                             ;; Add sync metadata
                                             (setq sdata `((Org_ID . ,match-id)
                                                           (Org_Sync . "yes")
                                                           (Org_Did_Sync . "yes")
                                                           (Org_Sync_ID . ,match-sync-id)
                                                           ,@sdata))
                                             ;; Sync the processed semantic match data
                                             (mrosetta-connector-send connector
                                                                      ;; The identifier property symbol
                                                                      'Org_ID
                                                                      ;; The list of match instances to send
                                                                      `(,sdata)
                                                                      ;; Callback function
                                                                      (lambda (did-succeed &rest params)
                                                                        ;; Notify the user
                                                                        (if did-succeed
                                                                            (message "Mrosetta Metalanguage match synced successfully!")
                                                                          (let ((msg (plist-get params :message)))
                                                                            (message "Mrosetta send error: %s" msg))))
                                                                      cparameters)
                                             ;; Update the org entry itself
                                             (org-entry-put (point) "mrosetta-match-id" (number-to-string match-id))
                                             (org-entry-put (point) "mrosetta-match-sync-id" (number-to-string match-sync-id))))
                                         (setq did-match t)))))))
               ;; Since while always returns nil, surface out the processing result
               did-match)))))
#+END_SRC

#+RESULTS: mrosetta-context-org-process
: mrosetta-context-org-process-heading

***** Update Org Heading
Sync all tracked matches with the specified connector endpoint.

#+NAME: mrosetta-context-org-update
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-update ((context mrosetta-context-org))
  "Update all tracked org heading entries within CONTEXT."
  (let ((mlexpression-index (mrosetta-context-org-db-mlexpression-collection (mrosetta-context-org-index context)))
        (mlexpression-cache (mrosetta-context-org-mlexpressions context))
        (connector (mrosetta-context-org-connector context)))
    ;; Update all tracked matches accross all defined Metalanguage expressions
    (dolist (mlexpression-index-entry-pair (mrosetta-context-org-collection-items mlexpression-index))
      (let* ((mlexpression-index-entry (cdr mlexpression-index-entry-pair))
             (mlexpression-id (mrosetta-context-org-entry-id mlexpression-index-entry))
             (mlexpression-match-index (mrosetta-context-org-mlexpression-match-collection mlexpression-index-entry))
             (cparameters (mapcan (lambda (cparameter-pair)
                                    `(,(car cparameter-pair) ,(cdr cparameter-pair)))
                                  (mrosetta-context-org-mlexpression-cparameters mlexpression-index-entry)))
             (mlexpression (cdr (assq mlexpression-id mlexpression-cache))))
        ;; Fetch any match instances marked as unsynced
        (mrosetta-connector-receive connector
                                    ;; The query property symbol
                                    'Org_Did_Sync
                                    ;; The query property value to match
                                    "no"
                                    ;; Callback function
                                    (lambda (sdata &rest params)
                                      (if sdata
                                          (let ((match-sync-ids '()))
                                            (dolist (instance-data sdata)
                                              (let* ((exdata `(,(mrosetta-mlexpression-key mlexpression) . ,instance-data))
                                                     (match-id (cdr (assq 'Org_ID instance-data)))
                                                     (match-sync-id (cdr (assq 'Org_Sync_ID instance-data)))
                                                     (match-index-entry (mrosetta-context-org-collection-get mlexpression-match-index match-id))
                                                     (match-org-file (mrosetta-context-org-entry-file match-index-entry)))
                                                ;; Push match ID for response payload
                                                (push `(,match-id . ,match-sync-id) match-sync-ids)
                                                ;; Update the org heading
                                                (org-map-entries (lambda ()
                                                                   (let* ((heading-text (mrosetta-context-org-heading-get))
                                                                          (updated-heading-text (mrosetta-update mlexpression
                                                                                                                 :text heading-text
                                                                                                                 :sdata exdata)))
                                                                     ;; Update the heading text
                                                                     (mrosetta-context-org-heading-set updated-heading-text)
                                                                     ;; Update the heading properties
                                                                     (org-entry-put (point) "mrosetta-match-sync-id" match-sync-id)
                                                                     ;; Update the match index entry
                                                                     (mrosetta-context-org-match-sync-id-set match-index-entry match-sync-id)
                                                                     ;; Notify the user
                                                                     (message "Mrosetta Metalanguage match with id %s updated in file %s!"
                                                                              (number-to-string match-id)
                                                                              (number-to-string match-org-file))))
                                                                 (concat "+mrosetta-match-id="
                                                                         "\"" match-id "\"")
                                                                 `(,match-org-file))))
                                            ;; Send response confirmation
                                            (let ((response-sdata (mapcar (lambda (match-sync-id-pair)
                                                                            `((Org_ID . ,(car match-sync-id-pair))
                                                                              (Org_Did_Sync . "yes")
                                                                              (Org_Sync_ID . ,(cdr match-sync-id-pair))))
                                                                          match-sync-ids)))
                                              (mrosetta-connector-send connector
                                                                       'Org_ID
                                                                       response-sdata
                                                                       (lambda (did-succeed &rest params)
                                                                         (if did-succeed
                                                                             (message "Mrosetta update for Metalanguage expression with id %s confirmed successfully!"
                                                                                      (number-to-string mlexpression-id))
                                                                           (let ((msg (plist-get params :message)))
                                                                             (message "Mrosetta send error: %s" msg))))
                                                                       cparameters)))
                                        (let ((msg (plist-get params :message)))
                                          (message "Mrosetta receive error: %s" msg))))
                                    cparameters)))))
#+END_SRC
***** Sync
Periodically sync local org entries with remote connector endpoints defined within respective Metalanguage expression declarations.

#+NAME: mrosetta-context-org-sync
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-sync ((context mrosetta-context-org))
  "Update all tracked org headings of defined Metalanguage expressions within provided CONTEXT. Repeat every SYNC-INTERVAL specified within the CONTEXT slot, or nil for no repitition."
  (let ((sync-interval (mrosetta-context-org-sync-interval context)))
    ;; Run update within context
    (mrosetta-context-org-update context)
    ;; Schedule next update, if sync-interval set
    (when sync-interval
      (run-at-time (format "%s min" (number-to-string sync-interval))
                   nil
                   #'mrosetta-context-org-sync
                   context))))
#+END_SRC

To start sync, call ~mrosetta-context-org-sync-start~ on the ~context~ object with the specified sync interval in minutes.

#+NAME: mrosetta-context-org-sync-start
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-sync-start ((context mrosetta-context-org) sync-interval)
  "Commence with periodic synchronization within the specified CONTEXT. SYNC-INTERVAL specifies the synchronization interval in minutes."
  (when (setf (slot-value context 'sync-interval) sync-interval)
    (mrosetta-context-org-sync context)))
#+END_SRC

To stop sync, call ~mrosetta-context-org-sync-stop~ on the ~context~ object.

#+NAME: mrosetta-context-org-sync-stop
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-context-org-sync-stop ((context mrosetta-context-org))
  "Stop the periodic synchronization within the specified CONTEXT."
  (setf (slot-value context 'sync-interval) nil))
#+END_SRC
* Configuration Example
An example configuration of Metarosetta within an Emacs configuration file.

#+NAME: config-setup
#+BEGIN_SRC emacs-lisp :noweb yes :session mrosetta-config
<<demo-init>>

<<mrosetta-connector>>
<<mrosetta-connector-parameters>>
<<mrosetta-connector-send>>
<<mrosetta-connector-receive>>

<<mrosetta-connector-url-snr>>

<<mrosetta-connector-coda>>
<<mrosetta-connector-coda-parameters>>
<<mrosetta-connector-coda-send>>
<<mrosetta-connector-coda-receive>>

<<mrosetta-context-org-heading-get>>
<<mrosetta-context-org-heading-set>>

<<mrosetta-context-org-collection>>
<<mrosetta-context-org-collection-set>>
<<mrosetta-context-org-collection-get>>

<<mrosetta-context-org-entry>>
<<mrosetta-context-org-mlexpression>>
<<mrosetta-context-org-match>>
<<mrosetta-context-org-match-sync-update>>

<<mrosetta-context-org-db>>

<<mrosetta-context-org-compile>>
<<mrosetta-context-org-compile-collection>>
<<mrosetta-context-org-compile-entry>>
<<mrosetta-context-org-compile-mlexpression>>
<<mrosetta-context-org-compile-db>>

<<mrosetta-context-org-decompile>>
<<mrosetta-context-org-decompile-collection>>
<<mrosetta-context-org-decompile-entry>>
<<mrosetta-context-org-decompile-mlexpression>>
<<mrosetta-context-org-decompile-db>>

<<mrosetta-context-org>>
<<mrosetta-context-org-load>>
<<mrosetta-context-org-save>>
<<mrosetta-context-org-process>>
<<mrosetta-context-org-update>>
<<mrosetta-context-org-sync>>
<<mrosetta-context-org-sync-start>>
<<mrosetta-context-org-sync-stop>>

"Mrosetta components loaded successfully!"
#+END_SRC

#+RESULTS: config-setup
: Mrosetta components loaded successfully!

** Init
Initialize a Metarosetta org context instance with the corresponding connector.

#+NAME: config-token
#+BEGIN_EXAMPLE
76d4327a-5bbb-437f-bd15-affc1170d041
#+END_EXAMPLE

#+NAME: config-init
#+BEGIN_SRC emacs-lisp :session mrosetta-config :var token=config-token
(defvar mrosetta-context-org-default (mrosetta-context-org :connector (mrosetta-connector-coda :token token)))
#+END_SRC

#+RESULTS: config-init
: mrosetta-context-org-default

** Load
Load the context before using it.

#+NAME: config-load
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(mrosetta-context-org-load mrosetta-context-org-default "~/org/mrosetta-index.db")
"Context loaded!"
#+END_SRC

#+RESULTS: config-load
: Context loaded!

** Save on Exit
Save the current context index before quitting Emacs.

#+NAME: config-save
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(add-hook 'kill-emacs-hook
          (lambda () (mrosetta-context-org-save mrosetta-context-org-default)))
"Hook added!"
#+END_SRC

#+RESULTS: config-save
: Hook added!

*** Remove Set Hook
If needed, remove the hook set above

#+NAME: config-save-remove
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(remove-hook 'kill-emacs-hook
             (lambda () (mrosetta-context-org-save mrosetta-context-org-default)))
"Hook removed!"
#+END_SRC

#+RESULTS: config-save-remove
: Hook removed!

** Process Heading
A simple keymap definition to trigger Metarosetta on a specific org heading.

#+NAME: config-process-heading
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(map! :map org-mode-map
      :localleader
      :desc "Metarosetta Heading"
      :n "m" (cmd! (mrosetta-context-org-process-heading mrosetta-context-org-default)))
"Keymap added!"
#+END_SRC

#+RESULTS: config-process-heading
: Keymap added!

** Sync
Start synchronization every 5 minutes.

#+NAME: config-sync-start
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(mrosetta-context-org-sync-start mrosetta-context-org-default 5)
#+END_SRC

Stop synchronization.

#+NAME: config-sync-stop
#+BEGIN_SRC emacs-lisp :session mrosetta-config
(mrosetta-context-org-sync-stop mrosetta-context-org-default)
#+END_SRC
* Registration
#+NAME: registration
#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'metarosetta)
#+END_SRC
* Footer
#+NAME: footer
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el ends here
#+END_SRC
