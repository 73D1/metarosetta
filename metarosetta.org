#+TITLE: Project Metarosetta Emacs Package

* Header
** Name and Definition
#+NAME: title
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el --- A semantically-driven interconnectivity framework -*- lexical-binding: t -*-
#+END_SRC
** Signature
#+NAME: signature
#+BEGIN_SRC emacs-lisp :tangle yes
;; Author: Bruno Tedeschi <me@btedeschi.com>
#+END_SRC
** Summary
#+NAME: summary
#+BEGIN_SRC text
This package adds Metarosetta expression language support to Org-mode.

It enables in-context definition of semantic protocols, within Org-mode, which automatically translate human-input text into a machine-digestible API-compatible structure particular to a given context.

For details and language specification, please refer to the original package documentation and source org file.
#+END_SRC

#+NAME: commentary
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
;;; Commentary:

;; <<summary>>
#+END_SRC
** Code Marker
#+NAME: code-marker
#+BEGIN_SRC emacs-lisp :tangle yes
;;; Code:
#+END_SRC
* Dependencies
#+NAME: dependencies
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'eieio)
#+END_SRC
* The Metalanguage
The metalanguage specification and parser.

** The Expression Object
An entity defining a particular expression. Using the metalanguage syntax as input, it constructs all underlying logic to parse textual input and structures to map semantic information to machine-readable output.

Designed as an inherently recursive fractal object.

*** Properties
All the properties contained within the expression object. These are of course defined as slots.

**** Definition
The metalanguage-specified definition of the expression in context.

This is stored as a quoted lisp list.

#+NAME: mldefinition
#+BEGIN_SRC emacs-lisp
(mldefinition
 :initarg :mldefinition
 :initform (error "Cannot create an expression without a definition!")
 :type list
 :documentation "The metalanguage-specified definition of the expression in context."
 :reader mrosetta-mldefinition)
#+END_SRC
**** Expression Type
Specifies the exact type of the expression in context.

The property itself is a ~symbol~ indicating the type of the expression.

#+NAME: extype
#+BEGIN_SRC emacs-lisp
(extype
 :type symbol
 :documentation "A symbol specifying the type of the encompassing expression instance. Can be either a :literal, :match or :fractal."
 :reader mrosetta-extype)
#+END_SRC

The following are the possible expression types:

***** Literal Quote
Denotes the simplest expression defining statically quoted text which matches itself within any passed input.

The quote expression type is specified as a ~:literal~.
***** Match
An expression matching semantically significant information. These are either words or paragraphs of captured text.

A match expression is specified as a ~:match~.
***** Fractal
An expression matching a sequence of its nested child expressions.

A fractal expression is specified as a ~:fractal~.
**** Fractals
All the fractal elements existing within the encompassing expression instance. Only ~:fractal~ instances can contain sub-expressions themselves.

The property itself is a list of ~mrosetta-expression~ instances.

#+NAME: fractals
#+BEGIN_SRC emacs-lisp
(fractals
 :initform '()
 :type list
 :documentation "A list of mrosetta-expression instances contained within the encompassing expression instance."
 :reader mrosetta-fractals)
#+END_SRC
**** Regular Expression Properties
This section contains all the properties pertaining to the encompassing expression's regex, its group keys and resulting matches of the current input, if processed.

***** Regex Keychain
In order to properly parse and distribute regex matches across the fractal expression tree, each expression object needs to have a number identifier unique to the encompassing tree.

To manage this, each tree has a single /keychain/ instance shared across all expression objects within a single fractal tree.

#+NAME: rkeychain
#+BEGIN_SRC emacs-lisp
(rkeychain
 :initarg :rkeychain
 :initform (mrosetta-keychain)
 :type mrosetta-keychain
 :documentation "The regex keychain instance managing keys for the encompassing expression tree."
 :reader mrosetta-rkeychain)
#+END_SRC

****** The Keychain
Key management is encapsulated within a simple keychain class which holds all generated keys, their respective assignments and is of course capable of generating keys unique within a single instance of the keychain object.

******* Class Definition
The class itself is designed as a no-argument constructor as the key generator is automatically initialized upon creation.

#+NAME: mrosetta-keychain
#+BEGIN_SRC emacs-lisp :tangle yes
(defclass mrosetta-keychain ()
  ((lastkey
    :initform '0
    :type number
    :documentation "The last key generated and assigned to a group within the context of a single keychain instance."
    :reader mrosetta-lastkey))
  "A regex group key generator.")
#+END_SRC
******* Behavior
This section covers all defined behavior for the keychain class.

******** Generate Key
Register for a new key with a particular expression instance.

#+NAME: mrosetta-generate-regex-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-generate-regex-key ((keychain mrosetta-keychain))
  "Generate a new key within a provided KEYCHAIN."
  (let ((key (+ 1 (slot-value keychain 'lastkey))))
    (setf (slot-value keychain 'lastkey) key)))
#+END_SRC
***** Regular Expression
The compiled regular expression of the metalanguage expression in context.

This is the regex used under the hood when parsing through human-readable input.

#+NAME: regex
#+BEGIN_SRC emacs-lisp
(regex
 :type string
 :documentation "The compiled regular expression of the expression in context."
 :reader mrosetta-regex)
#+END_SRC

In addition, each match-extracting regular expression has a corresponding group key by which the respective match is extracted.

#+NAME: regex-key
#+BEGIN_SRC emacs-lisp
(regex-key
 :type number
 :documentation "The regex matching group key for the encompassing expression instance."
 :reader mrosetta-regex-key)
#+END_SRC

Since the metalanguage supports plural matches of enumerable text clauses, an additional regular expression is required in order to capture a single instance of such clauses. In cases of single-matching expressions, ~regex~ is equivalent to ~rinstance~.

#+NAME: rinstance
#+BEGIN_SRC emacs-lisp
(rinstance
 :type string
 :documentation "The compiled regular expression matching a single instance of a possibly plural-matching expression."
 :reader mrosetta-rinstance)
#+END_SRC

#+NAME: rinstance-key
#+BEGIN_SRC emacs-lisp
(rinstance-key
 :type number
 :documentation "The regex group key for matching a single instance of a possibly plural-matching metalanguage expression in context."
 :reader mrosetta-rinstance-key)
#+END_SRC

****** Base
The foundational element from which the matching regular expression is constructed.

#+NAME: rbase
#+BEGIN_SRC emacs-lisp
(rbase
 :type string
 :documentation "The regular expression used as a foundational base in compilation of the match-extracting regular expression."
 :reader mrosetta-rbase)
#+END_SRC
****** Match
The regular expression of the match itself.

#+NAME: rmatch
#+BEGIN_SRC emacs-lisp
(rmatch
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression of the encompassing expression's semantic match."
 :reader mrosetta-rmatch)
#+END_SRC

The regex is paired with its group key used for match extraction.

#+NAME: rmatch-key
#+BEGIN_SRC emacs-lisp
(rmatch-key
 :initform 'nil
 :type (or null number)
 :documentation "The regex group key for the encompassing expression's output value match."
 :reader mrosetta-rmatch-key)
#+END_SRC
****** Prefix
The regular expression used for matching a specified prefix of the expression in context, if any.

#+NAME: rprefix
#+BEGIN_SRC emacs-lisp
(rprefix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified prefix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-rprefix)
#+END_SRC

The regex is paired with its group key used for the prefix match extraction.

#+NAME: rprefix-key
#+BEGIN_SRC emacs-lisp
(rprefix-key
 :initform 'nil
 :type (or null number)
 :documentation "The regex group key for the encompassing expression's prefix match. Either a group number or nil."
 :reader mrosetta-rprefix-key)
#+END_SRC
****** Suffix
The regular expression used for matching a specified suffix of the expression in context, if any.

#+NAME: rsuffix
#+BEGIN_SRC emacs-lisp
(rsuffix
 :initform 'nil
 :type (or null string)
 :documentation "The regular expression matching a specified suffix of the encompassing expression instance. Either a regex string or nil."
 :reader mrosetta-rsuffix)
#+END_SRC

The regex is paired with its group key used for the suffix match extraction.

#+NAME: rsuffix-key
#+BEGIN_SRC emacs-lisp
(rsuffix-key
 :initform 'nil
 :type (or null number)
 :documentation "The regex group key for the encompassing expression's suffix match. Either a group number or nil."
 :reader mrosetta-rsuffix-key)
#+END_SRC
**** Key
The property key to which the expression output value is assigned, if the expression itself is denoted as such.

#+NAME: key
#+BEGIN_SRC emacs-lisp
(key
 :initform 'nil
 :type (or null string)
 :documentation "The property key to which the expression output value is assigned, if any. Either a string or nil."
 :reader mrosetta-key)
#+END_SRC
**** Specifier Properties
All specifier parameters defined for the encompassing expression instance.

***** Uppercase
Match only uppercase words.

#+NAME: is-uppercase
#+BEGIN_SRC emacs-lisp
(is-uppercase
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only uppercase words. Either non-nil or nil."
 :reader mrosetta-is-uppercase)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: is-capitalized
#+BEGIN_SRC emacs-lisp
(is-capitalized
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches only capitalized words. Either non-nil or nil."
 :reader mrosetta-is-capitalized)
#+END_SRC
***** Boundary Properties
Specifies whether the match of the encompassing expression has static left or right boundaries.

****** Left Boundary
Specifies a statically set match prefix, if the expression defines one.

#+NAME: match-prefix
#+BEGIN_SRC emacs-lisp
(match-prefix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the prefix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-prefix)
#+END_SRC
****** Right Boundary
Specifies a statically set match suffix, if the expression defines one.

#+NAME: match-suffix
#+BEGIN_SRC emacs-lisp
(match-suffix
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the suffix all possible expression matches should have, if any. Either a string or nil."
 :reader mrosetta-match-suffix)
#+END_SRC
***** Content
Match only words containing specific characters or substrings.

#+NAME: match-substring
#+BEGIN_SRC emacs-lisp
(match-substring
 :initform 'nil
 :type (or null string)
 :documentation "Specifies a specific substring all possible expression matches should contain, if any. Either a string or nil."
 :reader mrosetta-match-substring)
#+END_SRC
***** Literal
Match only and exactly the literal text specified here.

This slot is only used in ~:literal~ expressions.

#+NAME: match-literal
#+BEGIN_SRC emacs-lisp
(match-literal
 :initform 'nil
 :type (or null string)
 :documentation "Specifies the literal string that the expression maches exclusively. Either a string or nill."
 :reader mrosetta-match-literal)
#+END_SRC
**** Modifier
Modifiers are useful when matched text needs to be formatted and /normalized/ before being structured within the machine-digestible output.

A modifier property is defined as a symbol referencing a stored function capable of a particular modification, like ~upcase~ for uppercasing the entirety of the output, or ~downcase~ for lowercasing.

#+NAME: modifier
#+BEGIN_SRC emacs-lisp
(modifier
 :initform 'nil
 :type (or null symbol)
 :documentation "Specifies a symbol referencing a stored modifier function, if any. Either a symbol or nil."
 :reader mrosetta-modifier)
#+END_SRC
**** Optionality
Specifies whether the entire expression and its fractals within (if any) are optional in presence.

#+NAME: is-optional
#+BEGIN_SRC emacs-lisp
(is-optional
 :initform 'nil
 :documentation "Specifies whether the encompassing expression is optional to match within input text. Either non-nil or nil."
 :reader mrosetta-is-optional)
#+END_SRC
**** Contextuality
Specifies whether the encompassing expression should be considered as contextual. Contextual expressions are matched but never included in structured semantic output.

#+NAME: is-contextual
#+BEGIN_SRC emacs-lisp
(is-contextual
 :initform 'nil
 :documentation "Specifies whether the encompassing expression should be considered as contextual only. Either non-nil or nil."
 :reader mrosetta-is-contextual)
#+END_SRC
**** Plurality
If the expression defines a plural match, then the output value is in list form and this property is non-nil.

#+NAME: is-plural
#+BEGIN_SRC emacs-lisp
(is-plural
 :initform 'nil
 :documentation "Specifies whether the encompassing expression matches plural values or just a single one. Either nil or non-nil."
 :reader mrosetta-is-plural)
#+END_SRC
*** Class Definition
The /expression/ class is defined below, containing all the properties listed above.

#+NAME: mrosetta-mlexpression
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defclass mrosetta-mlexpression ()
  (
   <<mldefinition>>
   <<extype>>
   <<fractals>>
   <<rkeychain>>
   <<regex>>
   <<regex-key>>
   <<rinstance>>
   <<rinstance-key>>
   <<rbase>>
   <<rmatch>>
   <<rmatch-key>>
   <<rprefix>>
   <<rprefix-key>>
   <<rsuffix>>
   <<rsuffix-key>>
   <<key>>
   <<is-uppercase>>
   <<is-capitalized>>
   <<match-prefix>>
   <<match-suffix>>
   <<match-substring>>
   <<match-literal>>
   <<modifier>>
   <<is-optional>>
   <<is-contextual>>
   <<is-plural>>
  )
  "The Metarosetta Expression object used to define a contextual translational expression for semantic processing.")
#+END_SRC
** Language Specification
The purpose of the language is to facilitate expressions which unambiguously define a translation protocol between human-readable text and machine-digestible data structures, with the semantics completely preserved, based on an arbitrarily defined pattern of human input within a specific context.

All keywords within the specification are stored as symbols which map to their respective parse functions.

#+NAME: mrosetta-mlsyntax
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax '())
#+END_SRC

*** Literal Quote
The simplest expression defining statically quoted text which should appear literally within input text.

#+NAME: mrosetta-parse-literal
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-literal ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the :right arg content within ARGS as a literal quote into the MLEXPRESSION instance in context."
  (let ((literal-quote (plist-get args :right)))
    (when (eq literal-quote nil)
      (error "Metalanguage syntax error: Literal expression without quoted content"))
    (setf (slot-value mlexpression 'extype) :literal)
    (setf (slot-value mlexpression 'rbase) (regexp-quote literal-quote))
    (setf (slot-value mlexpression 'match-literal) literal-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage itself defines this expression through the ~literal~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-literal-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(literal . mrosetta-parse-literal) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-literal-example
#+BEGIN_SRC text
(literal "Status Update:")
#+END_SRC
*** Word
An expression used to capture a variable word from within input text.

#+NAME: mrosetta-parse-word
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) "[[:word:]]+")
  args)
#+END_SRC

The metalanguage defines this expression through the ~word~ keyword.

#+NAME: mrosetta-parse-word-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(word . mrosetta-parse-word) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-example
#+BEGIN_SRC text
(word)
#+END_SRC

**** Word Specifiers
In addition to the ability to match any kind of word, the metalanguage specification also supports matching only specific words based on different criteria.

***** Uppercase
Match only uppercase words.

#+NAME: mrosetta-parse-word-uppercase
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-uppercase ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse an uppercase word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9]+")
  (setf (slot-value mlexpression 'is-uppercase) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~WORD~ keyword. Note that the metalanguage syntax is case-sensitive, where case is also part of the syntax itself.

#+NAME: mrosetta-parse-word-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(WORD . mrosetta-parse-word-uppercase) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-uppercase-example
#+BEGIN_SRC text
(WORD)
#+END_SRC
***** Capitalized
Match only capitalized words.

#+NAME: mrosetta-parse-word-capitalized
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-capitalized ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a capitalized word expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) "[A-Z0-9][a-z0-9]+")
  (setf (slot-value mlexpression 'is-capitalized) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~Word~ keyword.

#+NAME: mrosetta-parse-word-capitalized-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(Word . mrosetta-parse-word-capitalized) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-word-capitalized-example
#+BEGIN_SRC text
(Word)
#+END_SRC
**** Word Plurality
Instead of a single value, capture all value occurrences matching defined criteria within the encompassing expression context.

#+NAME: mrosetta-parse-word-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-word-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural words expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) t)
  (mrosetta-parse-word mlexpression args))
#+END_SRC

The metalanguage defines this expression through the ~words~ keyword.

#+NAME: mrosetta-parse-word-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(words . mrosetta-parse-word-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-word-plurality-example
#+BEGIN_SRC text
(words)
#+END_SRC
*** Paragraph
An expression used to capture a variable paragraph from within input text.

A paragraph is considered all text within specified boundaries. If no boundaries are set, the entire input is matched.

#+NAME: mrosetta-parse-paragraph
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a paragraph epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'extype) :match)
  (setf (slot-value mlexpression 'rbase) ".+")
  args)
#+END_SRC

The metalanguage defines this expression through the ~paragraph~ keyword.

#+NAME: mrosetta-parse-paragraph-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraph . mrosetta-parse-paragraph) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-paragraph-example
#+BEGIN_SRC text
(paragraph)
#+END_SRC

**** Paragraph Plurality
Like words, it's possible to capture multiple paragraph occurrences matching the expression-defined criteria.

Note that this construct only makes sense if paragraphs are clearly bounded.

#+NAME: mrosetta-parse-paragraph-plurality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-paragraph-plurality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse a plural paragraph expression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) t)
  (mrosetta-parse-paragraph mlexpression args))
#+END_SRC

The metalanguage defines this expression through the ~paragraphs~ keyword.

#+NAME: mrosetta-parse-paragraph-plurality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(paragraphs . mrosetta-parse-paragraph-plurality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mroseta-parse-paragraph-plurality-example
#+BEGIN_SRC text
(";" suffixed paragraphs)
#+END_SRC
*** Specifiers
**** Content Specifier
Match only elements containing specific characters or content.

#+NAME: mrosetta-parse-substring
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-substring ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :right arg within ARGS as matching element substring into the MLEXPRESSION instance in context."
  (let* ((substring-quote (plist-get args :right))
         (rsubstring-quote (regexp-quote substring-quote))
         (rbase (slot-value mlexpression 'rbase)))
    (when (eq substring-quote nil)
      (error "Metalanguage syntax error: Substring match expression without quoted content"))
    (setf (slot-value mlexpression 'rmatch)
          (concat "\(?:"
                  "\(?:" rsubstring-quote "\)?" rbase "\(?:" rsubstring-quote "\(?" rbase "\)?" "\)+"
                  "\|"
                  "\(?:" "\(?:" rbase "\)?" rsubstring-quote "\)+" rbase "\(?:" rsubstring-quote "\)?"
                  "\)"))
    (setf (slot-value mlexpression 'match-substring) substring-quote))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines this expression through the ~with~ keyword with the accompanying quote.

#+NAME: mrosetta-parse-substring-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(with . mrosetta-parse-substring) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-substring-example
#+BEGIN_SRC text
(word with "-")
#+END_SRC
**** Boundaries
Match only elements with the specified prefix or suffix. Note that the prefix or suffix itself isn't part of the match.

***** Prefix
Match only elements prefixed with the supplied quoted content.

#+NAME: mrosetta-parse-prefix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-prefix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element prefix into the MLEXPRESSION instance in context."
  (let ((prefix-quote (plist-get args :left)))
    (when (eq prefix-quote nil)
      (error "Metalanguage syntax error: Prefix match expression without quoted content"))
    (setf (slot-value mlexpression 'rprefix) (regexp-quote prefix-quote))
    (setf (slot-value mlexpression 'match-prefix) prefix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~prefixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-prefix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(prefixed . mrosetta-parse-prefix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-prefix-example
#+BEGIN_SRC text
("#" prefixed word)
#+END_SRC
***** Suffix
Match only elements suffixed with the supplied quoted content.

#+NAME: mrosetta-parse-suffix
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-suffix ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse quoted text from :left arg within ARGS as matching element suffix into the MLEXPRESSION instance in context."
  (let ((suffix-quote (plist-get args :left)))
    (when (eq suffix-quote nil)
      (error "Metalanguage syntax error: Suffix match expression without quoted content"))
    (setf (slot-value mlexpression 'rsuffix) (regexp-quote suffix-quote))
    (setf (slot-value mlexpression 'match-suffix) suffix-quote))
  (plist-put args :left nil))
#+END_SRC

The metalanguage defines this expression through the ~suffixed~ keyword with the accompanying quote preceding the keyword.

#+NAME: mrosetta-parse-suffix-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(suffixed . mrosetta-parse-suffix) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-suffix-example
#+BEGIN_SRC text
(";" suffixed word)
#+END_SRC
*** Modifiers
Modify captured elements before structured output.

Modifiers are defined as contextual arguments succeeding the general modifier keyword.

#+NAME: mrosetta-mlsyntax-modifiers
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar mrosetta-mlsyntax-modifiers '())
#+END_SRC

**** Uppercase
Transform captured elements to uppercase format.

To do so, use the ~uppercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-uppercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(uppercase . upcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-uppercase-example
#+BEGIN_SRC text
(word to uppercase)
#+END_SRC
**** Lowercase
Transform captured elements to lowercase format.

To do so, use the ~lowercase~ argument following the ~to~ modifier keyword.

#+NAME: mrosetta-parse-modifier-lowercase-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(lowercase . downcase) mrosetta-mlsyntax-modifiers)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-modifier-lowercase-example
#+BEGIN_SRC text
(word to lowercase)
#+END_SRC
**** Modifier Argument Parser
All modifier contextual arguments are handled by a central modifier parser.

#+NAME: mrosetta-parse-modifier
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-modifier ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the modifier symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((modifier-symbol (plist-get args :right)))
    (when (eq modifier-symbol nil)
      (error "Metalanguage syntax error: Modifier expression without contextual argument symbol"))
    (setf (slot-value mlexpression 'modifier)
          (cdr (assq modifier-symbol mrosetta-mlsyntax-modifiers))))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the modifier context through the ~to~ keyword followed by the contextual arguments listed above.

#+NAME: mrosetta-parse-modifier-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(to . mrosetta-parse-modifier) mrosetta-mlsyntax)
#+END_SRC
*** Optionality
Specify whether the encompassing expression should be considered as an optional, or required match.

Input text without an optional expression match still gets processed, structured and output. Any input not matching all mandatory expressions is disregarded.

All defined expressions are considered as mandatory by default.

#+NAME: mrosetta-parse-optionality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-optionality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse expression optionality into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-optional) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~optional~ keyword.

#+NAME: mrosetta-parse-optionality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(optional . mrosetta-parse-optionality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-optionality-example
#+BEGIN_SRC text
(optional word)
#+END_SRC
*** Assignment
Assign a key to the resulting value of the encompassing expression.

#+NAME: mrosetta-parse-key
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-key ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the key symbol from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((key-symbol (plist-get args :right)))
    (when (eq key-symbol nil)
      (error "Metalanguage syntax error: Key assignment without contextual key symbol"))
    (setf (slot-value mlexpression 'key) key-symbol))
  (plist-put args :right nil))
#+END_SRC

The metalanguage defines the assignment expression through the ~as~ keyword followed by the key symbol.

#+NAME: mrosetta-parse-key-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(as . mrosetta-parse-key) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-key-example
#+BEGIN_SRC text
(word as a_property)
#+END_SRC
*** Contextuality
Specify whether the encompassing expression should be considered as contextual. As noted above, contextual expressions are matched but never included in structured semantic output.

Context is considered as semantically insignificant text occurring before and after the semantic match itself.

While this text is unimportant for structured semantics, it remains an intrinsic part of the human-readable form. This provides an ability to regenerate the human-readable text with updated semantic information from a machine-generated source. I.e., it enables true two-way trans-operability between the human and machine forms.

#+NAME: mrosetta-parse-contextuality
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-contextuality ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse expression contextuality into the MLEXPRESSION instance in context. This function utilizes no ARGS."
  (setf (slot-value mlexpression 'is-contextual) t)
  args)
#+END_SRC

The metalanguage defines this expression through the ~contextual~ keyword.

#+NAME: mrosetta-parse-contextuality-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(contextual . mrosetta-parse-contextuality) mrosetta-mlsyntax)
#+END_SRC

A usage example is as follows:

#+NAME: mrosetta-parse-contextuality-example
#+BEGIN_SRC text
(contextual ":" suffixed paragraph)
#+END_SRC
*** Collections
Instead of matching a single occurrence of a complex expression, repetitively capture the corresponding expression within input text containing the recurring pattern, while structuring the resulting match as a list.

Collections are essential in matching of targeted semantics from within enumerated clauses of text.

The metalanguage defines collection expressions through two keywords: ~list~ and ~of~.

The ~list~ specifies the type of the encompassing /parent/ expression, while the ~of~ designates its fractal content.

#+NAME: mrosetta-parse-list
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-list ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the list epxression into the MLEXPRESSION instance in context. This expression utilizes no ARGS."
  (setf (slot-value mlexpression 'is-plural) t)
  args)
#+END_SRC

#+NAME: mrosetta-parse-list-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(list . mrosetta-parse-list) mrosetta-mlsyntax)
#+END_SRC

#+NAME: mrosetta-parse-of
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse-of ((mlexpression mrosetta-mlexpression) &rest args)
  "Parse the sub-expression from :right arg within ARGS into the MLEXPRESSION instance in context."
  (let ((sub-expression (plist-get args :right)))
    (when (or (eq sub-expression nil) (nlistp sub-expression))
      (error "Metalanguage syntax error: Sub-expression assignment without contextual expression"))
    (mrosetta-parse mlexpression sub-expression))
  (plist-put args :right nil))
#+END_SRC

#+NAME: mrosetta-parse-of-symbol
#+BEGIN_SRC emacs-lisp :tangle yes
(push '(of . mrosetta-parse-of) mrosetta-mlsyntax)
#+END_SRC
** Expression Parsing
Parse the metalanguage-specified definition within an expression instance.

#+NAME: mrosetta-parse
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-parse ((mlexpression mrosetta-mlexpression) &optional sub-definition)
  "Parse the metalanguage-specified definition within the MLEXPRESSION instance. Optionally, parse the explicitly-set SUB-DEFINITION instead."
  (let ((mldefinition (if (eq sub-definition nil)
                          (copy-tree (slot-value mlexpression 'mldefinition))
                        (copy-tree sub-definition)))
        (larg nil)
        (element nil)
        (rarg nil))
    (while (> (length mldefinition) 0)
      (setq element (pop mldefinition)
            rarg (car mldefinition))
      (when (symbolp element)
        ;; The element is a metalanguage keyword, so lookup the corresponding function and parse accordingly
        (let ((leftout-args (funcall (cdr (assq element mrosetta-mlsyntax)) mlexpression :left larg :right rarg)))
          (setq larg nil)
          (when (eq (plist-get leftout-args :right) nil)
            (pop mldefinition))))
      (when (and (listp element) (> (length element) 0))
        ;; The element is a nested fractal expression
        (setf (slot-value mlexpression 'extype) :fractal)
        (let ((fractal-mlexpression (mrosetta-mlexpression :mldefinition element :rkeychain (slot-value mlexpression 'rkeychain))))
          (setf (slot-value mlexpression 'fractals) `(,@(slot-value mlexpression 'fractals) ,fractal-mlexpression))
          (mrosetta-parse fractal-mlexpression))
        (setq larg nil))
      (when (stringp element)
        ;; The element is a quoted string, so just pass it along
        (setq larg element)))))
#+END_SRC
** Expression Compilation
Compile the entire fractal tree within the root expression instance into a regular expression structure.

#+NAME: mrosetta-compile
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-compile ((mlexpression mrosetta-mlexpression))
  "Compile the MLEXPRESSION instance into a regular expression structure."
  (let* ((rkeychain (slot-value mlexpression 'rkeychain))
         (regex)
         (regex-key (mrosetta-generate-regex-key rkeychain))
         (rinstance)
         (rinstance-key (mrosetta-generate-regex-key rkeychain))
         (rmatch (slot-value mlexpression 'rmatch))
         (rmatch-key (mrosetta-generate-regex-key rkeychain))
         (rprefix (slot-value mlexpression 'rprefix))
         (rsuffix (slot-value mlexpression 'rsuffix))
         (is-optional (slot-value mlexpression 'is-optional))
         (is-plural (slot-value mlexpression 'is-plural)))
    (if (eq (slot-value mlexpression 'extype) :fractal)
        ;; Fractal Expressions cannot have end-matches
        (when rmatch
          (error "Metalanguage syntax error: End-matching expressions, like words or paragraphs, must be defined with parentheses"))
        ;; Recursively compile all nested fractal expression instances
        (let ((fractals (slot-value mlexpression 'fractals)))
          (dolist (fractal fractals)
            (setq rmatch (concat rmatch "[[:blank:]]+" (mrosetta-compile fractal)))))
      ;; Literal or end Match
      (when (eq rmatch nil)
        (setq rmatch (slot-value mlexpression 'rbase))))
    ;; Compile the total match, instance and expression-encompassing regular expressions
    (setq rmatch (concat "\(?" rmatch-key ":" rmatch "\)"))
    (setq rinstance (concat "\(?" rinstance-key ":" rprefix rmatch rsuffix "\)"))
    (setq regex (concat "\(?" regex-key ":"
                        rinstance
                        (when is-plural "+")
                        "\)"
                        (when is-optional "?")))
    (setf (slot-value mlexpression 'rmatch-key) rmatch-key
          (slot-value mlexpression 'rmatch) rmatch
          (slot-value mlexpression 'rinstance-key) rinstance-key
          (slot-value mlexpression 'rinstance) rinstance
          (slot-value mlexpression 'regex-key) regex-key
          (slot-value mlexpression 'regex) regex)))
#+END_SRC
* Text Processing
Process human-readable source text and output the semantic data structure, as defined by the metalanguage expression in context.

#+NAME: mrosetta-process
#+BEGIN_SRC emacs-lisp :tangle yes
(cl-defmethod mrosetta-process ((mlexpression mrosetta-mlexpression) htext)
  "Process human-readable text within the HTEXT string and return the semantic data structure as defined by the MLEXPRESSION instance."
  (let ((sdata '()))
    (save-match-data
      (and (string-match (mrosetta-regex mlexpression) htext)
           ;; Found match for the entirety of the expression
           (let ((mtext (match-string (mrosetta-regex-key mlexpression) htext))
                 (pos))
             (save-match-data
               ;; Iterate over all instance occurrences within the matching expression text
               (while (string-match (mrosetta-rinstance mlexpression) mtext pos)
                 (setq pos (match-end 0))
                 ;; Process the exact match as defined by the expression
                 (let ((instance-sdata)
                       (match (match-string (mrosetta-rmatch-key mlexpression) mtext)))
                   ;; Cases where the expression is a :fractal
                   (when (eq (mrosetta-extype mlexpression) :fractal)
                     ;; Recursively process all fractals within
                     (let ((fractals (mrosetta-fractals mlexpression)))
                       (dolist (fractal fractals)
                         (let ((fractal-sdata (mrosetta-process fractal (match-string (mrosetta-regex-key fractal) mtext))))
                           (when fractal-sdata
                             (setq instance-sdata `(,@instance-sdata ,fractal-sdata)))))))
                   ;; Cases where the expression is a :match
                   (when (and (eq (mrosetta-extype mlexpression) :match)
                              (not (mrosetta-is-contextual mlexpression)))
                     ;; Just store the semantic end-match
                     (setq instance-sdata match))
                   (setq sdata `(,@sdata ,instance-sdata))))))))
    (when (> (length sdata) 0)
      ;; Splice instance data in case of a singular expression
      (when (not (mrosetta-is-plural mlexpression))
        (setq sdata (car sdata)))
      ;; Return the structured semantic data object
      `(,(or (mrosetta-key mlexpression) :nokey) . ,sdata))))
#+END_SRC
* Contexts
** Org
* Connectors
** REST
* Registration
#+NAME: registration
#+BEGIN_SRC emacs-lisp :tangle yes
(provide 'metarosetta)
#+END_SRC
* Footer
#+NAME: footer
#+BEGIN_SRC emacs-lisp :tangle yes
;;; metarosetta.el ends here
#+END_SRC
